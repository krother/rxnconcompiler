<?xml version="1.0" encoding="UTF-8"?>
<XMI verified="false" xmi.version="1.2" timestamp="2015-06-25T10:27:36" xmlns:UML="http://schema.omg.org/spec/UML/1.3">
 <XMI.header>
  <XMI.documentation>
   <XMI.exporter>umbrello uml modeller http://umbrello.kde.org</XMI.exporter>
   <XMI.exporterVersion>1.6.4</XMI.exporterVersion>
   <XMI.exporterEncoding>UnicodeUTF8</XMI.exporterEncoding>
  </XMI.documentation>
  <XMI.metamodel xmi.version="1.3" href="UML.xml" xmi.name="UML"/>
 </XMI.header>
 <XMI.content>
  <UML:Model isSpecification="false" isAbstract="false" isLeaf="false" xmi.id="m1" isRoot="false" name="UML-Modell">
   <UML:Namespace.ownedElement>
    <UML:Stereotype visibility="public" isSpecification="false" namespace="m1" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="folder" name="folder"/>
    <UML:Stereotype visibility="public" isSpecification="false" namespace="m1" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="datatype" name="datatype"/>
    <UML:Model stereotype="folder" visibility="public" isSpecification="false" namespace="m1" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Logical View" name="Logical View">
     <UML:Namespace.ownedElement>
      <UML:Package stereotype="folder" visibility="public" isSpecification="false" namespace="Logical View" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Datatypes" name="Datatypes">
       <UML:Namespace.ownedElement>
        <UML:DataType stereotype="datatype" visibility="public" isSpecification="false" namespace="Datatypes" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="roUjrN5x9VrV" name="int"/>
        <UML:DataType stereotype="datatype" visibility="public" isSpecification="false" namespace="Datatypes" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="2T8bSm8YgxBV" name="char"/>
        <UML:DataType stereotype="datatype" visibility="public" isSpecification="false" namespace="Datatypes" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="87Hl5Afww7fn" name="bool"/>
        <UML:DataType stereotype="datatype" visibility="public" isSpecification="false" namespace="Datatypes" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="UikbCZ7E3DqV" name="float"/>
        <UML:DataType stereotype="datatype" visibility="public" isSpecification="false" namespace="Datatypes" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="zy1dvC72IOnN" name="double"/>
        <UML:DataType stereotype="datatype" visibility="public" isSpecification="false" namespace="Datatypes" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="WQHSYvD0bwcn" name="short"/>
        <UML:DataType stereotype="datatype" visibility="public" isSpecification="false" namespace="Datatypes" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Vh2Yss1qo3Ti" name="long"/>
        <UML:DataType stereotype="datatype" visibility="public" isSpecification="false" namespace="Datatypes" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="DakVyXqSy6sW" name="unsigned int"/>
        <UML:DataType stereotype="datatype" visibility="public" isSpecification="false" namespace="Datatypes" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="16Uc26QVnS2e" name="unsigned short"/>
        <UML:DataType stereotype="datatype" visibility="public" isSpecification="false" namespace="Datatypes" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="I3U64xoIYWlU" name="unsigned long"/>
        <UML:DataType stereotype="datatype" visibility="public" isSpecification="false" namespace="Datatypes" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="4ax0gnUhtyJt" name="string"/>
        <UML:DataType stereotype="datatype" visibility="public" isSpecification="false" namespace="Datatypes" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="5hPq9PUPSyWX" name="array"/>
        <UML:DataType stereotype="datatype" visibility="public" isSpecification="false" namespace="Datatypes" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="wInSpWwr6rrm" name="tuple"/>
        <UML:DataType stereotype="datatype" visibility="public" isSpecification="false" namespace="Datatypes" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="dLTWHlOKSlBa" name="dict"/>
        <UML:DataType stereotype="datatype" visibility="public" isSpecification="false" namespace="Datatypes" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="AdxaaT7UkswX" name="object"/>
        <UML:DataType stereotype="datatype" visibility="public" isSpecification="false" namespace="Datatypes" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="PqOVgDGJWjnn" name="set"/>
        <UML:DataType stereotype="datatype" visibility="public" isSpecification="false" namespace="Datatypes" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="BEpRW5sphWn8" name="undef">
         <UML:GeneralizableElement.generalization>
          <UML:Generalization xmi.idref="aUWU64DmHDbO"/>
         </UML:GeneralizableElement.generalization>
        </UML:DataType>
       </UML:Namespace.ownedElement>
      </UML:Package>
      <UML:Generalization discriminator="" visibility="public" isSpecification="false" namespace="Logical View" child="SB8tuHR4uOfU" xmi.id="qkyabs70jTTP" parent="AdxaaT7UkswX" name=""/>
      <UML:Generalization discriminator="" visibility="public" isSpecification="false" namespace="Logical View" child="5LhW07ZnqG86" xmi.id="FHeEvbLyw2Ux" parent="EnUCJkRim0MZ" name=""/>
      <UML:Generalization discriminator="" visibility="public" isSpecification="false" namespace="Logical View" child="5LhW07ZnqG86" xmi.id="ir1dsTY0VGyn" parent="AdxaaT7UkswX" name=""/>
      <UML:Generalization discriminator="" visibility="public" isSpecification="false" namespace="Logical View" child="k1uemhq0sxmv" xmi.id="es1l5CSBzyFr" parent="dLTWHlOKSlBa" name=""/>
      <UML:Class visibility="public" isSpecification="false" namespace="Logical View" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="6vEMLbAVCgfc" name="Test">
       <UML:GeneralizableElement.generalization>
        <UML:Generalization xmi.idref="8WvTDxOW0gkg"/>
       </UML:GeneralizableElement.generalization>
       <UML:Classifier.feature>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="47i2mRimI0VB" name="__init__">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="78AA1TYSzR58" type="4ax0gnUhtyJt"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="wIOwP9ASFtUz" name="name">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="KBjcBFnGNvQN" type="4ax0gnUhtyJt"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="OwnLMsSI8qEY" name="name">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="8v3UqRpEOcYk" type="4ax0gnUhtyJt"/>
          <UML:Parameter visibility="private" isSpecification="false" xmi.id="yP0DGSCadtAm" type="4ax0gnUhtyJt" value="" name="name"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
       </UML:Classifier.feature>
      </UML:Class>
      <UML:Generalization discriminator="" visibility="public" isSpecification="false" namespace="Logical View" child="6vEMLbAVCgfc" xmi.id="8WvTDxOW0gkg" parent="AdxaaT7UkswX" name=""/>
      <UML:Generalization discriminator="" visibility="public" isSpecification="false" namespace="Logical View" child="j3ngBQNek4cF" xmi.id="8RTpSN0mgU4Q" parent="dLTWHlOKSlBa" name=""/>
      <UML:Generalization discriminator="" visibility="public" isSpecification="false" namespace="Logical View" child="IA07MlrCZIEg" xmi.id="WzNs2uKV7Nii" parent="dLTWHlOKSlBa" name=""/>
      <UML:Generalization discriminator="" visibility="public" isSpecification="false" namespace="Logical View" child="Dduf1BV7qFwD" xmi.id="hTIBG84vSWhM" parent="EnUCJkRim0MZ" name=""/>
      <UML:Class visibility="public" isSpecification="false" namespace="Logical View" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="BP45bBkZ1pSH" comment="    Adapts Contingency to situation when the ctype will changed.&#xa;    One Contingency object can have two 'signs': positive and negative. &#xa;    It is used e.g. when flattening K+ into ! and x&#xa;" name="ContingencyWrapper">
       <UML:Classifier.feature>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="N8XmvtmdBNbU" comment="        Adapter pattern for ContingencyComponent. &#xa;" name="__init__">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="Ylhj6GCcqo5w" type="4ax0gnUhtyJt"/>
          <UML:Parameter visibility="private" isSpecification="false" xmi.id="WccU63hHRkK2" type="4ax0gnUhtyJt" value="" name="contingency"/>
          <UML:Parameter visibility="private" isSpecification="false" xmi.id="v4aut29E8gy3" type="4ax0gnUhtyJt" value="" name="mode"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="qkBHUVHNXrFO" name="__repr__">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="rPdz3b1bKiLP" type="4ax0gnUhtyJt"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="wVzkJ4h7pqOH" comment="        Returns contingency type based on&#xa;        the mode (positive or negative)&#xa;        and the oryginal type. &#xa;" name="get_ctype">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="KgfrVuGNHrML" type="4ax0gnUhtyJt"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="SNwl3FAxi9i2" comment="        Creates new contingency object with &#xa;        type asign based on mode and old type.&#xa;" name="get_contingency">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="CN91BWIVAvLf" type="4ax0gnUhtyJt"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
       </UML:Classifier.feature>
      </UML:Class>
      <UML:Generalization discriminator="" visibility="public" isSpecification="false" namespace="Logical View" child="qZ07QNQqiLbk" xmi.id="YlfHtLJ5iQ4s" parent="dLTWHlOKSlBa" name=""/>
      <UML:Generalization discriminator="" visibility="public" isSpecification="false" namespace="Logical View" child="qeeki9z1YCSm" xmi.id="yfVWrajDKFO8" parent="dLTWHlOKSlBa" name=""/>
      <UML:Generalization discriminator="" visibility="public" isSpecification="false" namespace="Logical View" child="NDXzAOrelJEV" xmi.id="k8tcenNQxX6X" parent="dLTWHlOKSlBa" name=""/>
      <UML:Class visibility="public" isSpecification="false" namespace="Logical View" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="p5fxNTiBTZpy" comment="    Component object keeps informations about name, domain and id.&#xa;    It is used in State. &#xa;" name="Component">
       <UML:Classifier.feature>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="NpCREKBOcYpj" comment=" for ipi states" name="__init__">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="1KodsbNpiD14" type="4ax0gnUhtyJt"/>
          <UML:Parameter visibility="private" isSpecification="false" xmi.id="w7qEO30D6g8T" type="4ax0gnUhtyJt" value="" name="name"/>
          <UML:Parameter visibility="private" isSpecification="false" xmi.id="7peaORXkEjBQ" type="4ax0gnUhtyJt" value="" name="domain"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="E0FKgOllDNKZ" comment="return str((self.name , self.domain, self.cid))" name="__repr__">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="opJ0WSQYmFBd" type="4ax0gnUhtyJt"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="qYQXkPZyPpH3" name="__eq__">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="hb0SoA3fiRAQ" type="4ax0gnUhtyJt"/>
          <UML:Parameter visibility="private" isSpecification="false" xmi.id="D2nOO7vAwFBS" type="4ax0gnUhtyJt" value="" name="other"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="ojPEYeFjg252" comment=" compare name value (should be unique)" name="__cmp__">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="eORLnZlcG8op" type="4ax0gnUhtyJt"/>
          <UML:Parameter visibility="private" isSpecification="false" xmi.id="91D3GOUvzULm" type="4ax0gnUhtyJt" value="" name="other"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="m3WR4aTBbeFp" comment="        Checks not only name (__cmp__) but also domain.&#xa;" name="exact_compare">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="kqq0zenjfI8j" type="4ax0gnUhtyJt"/>
          <UML:Parameter visibility="private" isSpecification="false" xmi.id="2ji0B4moQB7E" type="4ax0gnUhtyJt" value="" name="other"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
       </UML:Classifier.feature>
      </UML:Class>
      <UML:Generalization discriminator="" visibility="public" isSpecification="false" namespace="Logical View" child="gPRSmOkbKfX2" xmi.id="JNP3aWs7m5XS" parent="EnUCJkRim0MZ" name=""/>
      <UML:Generalization discriminator="" visibility="public" isSpecification="false" namespace="Logical View" child="bhiJVxIVYH6t" xmi.id="uUvJARP5CIX6" parent="AdxaaT7UkswX" name=""/>
      <UML:Class visibility="public" isSpecification="false" namespace="Logical View" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="EnUCJkRim0MZ" name="list"/>
      <UML:Generalization discriminator="" visibility="public" isSpecification="false" namespace="Logical View" child="mHcr9bv39eOH" xmi.id="kZinlQKlmOyX" parent="EnUCJkRim0MZ" name=""/>
      <UML:Generalization discriminator="" visibility="public" isSpecification="false" namespace="Logical View" child="CXFhncrex7CY" xmi.id="ZGiIuLz9d5Jw" parent="dLTWHlOKSlBa" name=""/>
      <UML:Generalization discriminator="" visibility="public" isSpecification="false" namespace="Logical View" child="lNO4J8bKjrXv" xmi.id="sF7Kksr95OJr" parent="8Wq9i8yrhK77" name=""/>
      <UML:Generalization discriminator="" visibility="public" isSpecification="false" namespace="Logical View" child="BEpRW5sphWn8" xmi.id="aUWU64DmHDbO" parent="8Wq9i8yrhK77" name=""/>
      <UML:Generalization discriminator="" visibility="public" isSpecification="false" namespace="Logical View" child="q4764XrJtgrn" xmi.id="YzoE26xixnzQ" parent="8Wq9i8yrhK77" name=""/>
      <UML:Generalization discriminator="" visibility="public" isSpecification="false" namespace="Logical View" child="cxUNVy2crBHu" xmi.id="xVFLzi7gp0kZ" parent="8Wq9i8yrhK77" name=""/>
      <UML:Class visibility="public" isSpecification="false" namespace="Logical View" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="aHDU9NKnS1ih" name="RxnconError">
       <UML:GeneralizableElement.generalization>
        <UML:Generalization xmi.idref="PcVX3Saejn6s"/>
       </UML:GeneralizableElement.generalization>
      </UML:Class>
      <UML:Class visibility="public" isSpecification="false" namespace="Logical View" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="xtnAwXedV2b0" name="Exception"/>
      <UML:Generalization discriminator="" visibility="public" isSpecification="false" namespace="Logical View" child="aHDU9NKnS1ih" xmi.id="PcVX3Saejn6s" parent="xtnAwXedV2b0" name=""/>
      <UML:Class visibility="public" isSpecification="false" namespace="Logical View" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="zebiQhZW6A7Z" comment="Class RxnconWarnings: colects info on problems &#xa;so they can be included in BNGL file as comments.&#xa;" name="RxnconWarnings">
       <UML:Classifier.feature>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="WNwhOSpxcXzl" comment="Stores inforation on logical problems in the rxncon input.&#xa;" name="__init__">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="r1IkZNhWzGFN" type="4ax0gnUhtyJt"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="wmu2wzZRKW6i" comment="        Based on given reacion and contingencies pool checks&#xa;        which states are missing (used in contingencies and not &#xa;        produced in reactions).&#xa;        Returns list of states. &#xa; states in reactions like P- or GAP, Ub- states from !, K+, K- contingencies and also x ---> domains from x need to be present and domains are only                  colected from produced states" name="calculate_missing_states">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="7U3Ry9At3oQU" type="4ax0gnUhtyJt"/>
          <UML:Parameter visibility="private" isSpecification="false" xmi.id="wvgXTfIIha0E" type="4ax0gnUhtyJt" value="" name="reaction_pool"/>
          <UML:Parameter visibility="private" isSpecification="false" xmi.id="viktyxGsj8ve" type="4ax0gnUhtyJt" value="" name="contingency_pool"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Tgm8EmMAS53P" comment="        makes set of strings out of self.not_applied_contingencies&#xa;        (list of objects).&#xa;        Removes redundant reactions.&#xa;" name="get_problem_reaction_str">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="2HHmQCOVfRvd" type="4ax0gnUhtyJt"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
       </UML:Classifier.feature>
      </UML:Class>
      <UML:Class visibility="public" isSpecification="false" namespace="Logical View" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Y3Wbru5IapPn" comment="    Compiler object translates given rxncon input (xls file or quick text)&#xa;    into BioNetGen source code (BNGL file).&#xa;    TODO: rename to RxnconCompiler (Copiler not specific)&#xa;    TODO: add functions for translation into other formats&#xa;    TODO: apply filters&#xa;    TODO: write any output write_bngl ---> write_output&#xa;" name="Compiler">
       <UML:Classifier.feature>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="ajx2oyRrDjbb" comment="        Keeps single xls object.&#xa;" name="__init__">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="ZZ89NXuxFrz3" type="4ax0gnUhtyJt"/>
          <UML:Parameter visibility="private" isSpecification="false" xmi.id="tz7YO0Au3gUs" type="4ax0gnUhtyJt" value="" name="input_data"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="nPu16TaxShWo" comment="        Writes bngl string to file.&#xa;" name="translate">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="Cv2Rl0TWPNVT" type="4ax0gnUhtyJt"/>
          <UML:Parameter visibility="private" isSpecification="false" xmi.id="hgjiKDYrkh17" type="4ax0gnUhtyJt" value="" name="add_translation"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
       </UML:Classifier.feature>
      </UML:Class>
      <UML:Class visibility="public" isSpecification="false" namespace="Logical View" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="r6QHlw4Ral9t" comment="    Manage the process that leads from the tabular data representation &#xa;    to the object oriented representation of reactions and contingencies.&#xa;    The process and objects are bngl-oriented.&#xa;    #KR: better 'The process and objects were designed to allow...'&#xa;    E.g. they were design to allow flexible and unambiguous &#xa;    translation to bngl string in later stage.&#xa;    The end product is a pool of ReactionContainer objects.&#xa;    Single ReactionContainer object corresponds to a RuleContainer object.&#xa;    Single ReactionContainer has all data necessary for translation into bngl.&#xa;    @type xls_tables:  dictionary&#xa;    @param xls_tables: rxncon input data&#xa;" name="Rxncon">
       <UML:Classifier.feature>
        <UML:Attribute visibility="private" isSpecification="false" xmi.id="RwmXklSiWdHT" type="w9mgAPbqJCmi" name="war"/>
        <UML:Attribute visibility="private" isSpecification="false" xmi.id="RaWxvRPMM9s6" type="savREAGHryH0" name="df"/>
        <UML:Attribute visibility="private" isSpecification="false" xmi.id="tIoPu5qJ9blQ" type="ldrlVHTRRF7b" name="xls_table"/>
        <UML:Attribute visibility="private" isSpecification="false" xmi.id="QGymOqsF6he0" type="lEa8AfhON7wu" comment="self.molecule_pool = reaction_factory.molecule_pool&#xa;self.reaction_pool = reaction_factory.reaction_pool" name="reaction_factory"/>
        <UML:Attribute visibility="private" isSpecification="false" xmi.id="vfNmnI1i5Tla" type="qeeki9z1YCSm" comment="self.contingency_pool = contingency_factory.parse_contingencies()" name="contingency_factory"/>
        <UML:Attribute visibility="private" isSpecification="false" xmi.id="VPapzHFJ9bqN" type="k1uemhq0sxmv" name="complex_pool"/>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="wgkgLjmXdoxM" comment="        Constructor creates basic objects with explicitly given information:&#xa;        - MoleculePool created by Reaction Factory  &#xa;        - ReactionPool created by Reaction Factory&#xa;        - ContingencyPool created by ContingencyFactory&#xa;        - ComplexPool created here using ComplexBuilder&#xa;        Data is supplemented by domain info for ppis with no domain specified by the user.&#xa;        MoleculePool - list of all right and left reactants from all reactions.&#xa;        ReactionPool - dict of all reactions. &#xa;                       rxncon reaction str: ReactionContiner object &#xa;                       (captures all possible alternative reactions&#xa;                       depending on conditions in which reaction can happen). &#xa;        ContingencyPool - dictionary of all contingencies.&#xa;                          rxncon_reaction_str: root contingency &#xa;                          (which contains all contingencies assign to this reaction).&#xa;        ComplexPool - dict of all complexes (defined as children-containing contingencies with '&lt;>').&#xa;                      '&lt;name>': AlternativeComplexes (which contains BiologicalComplex objects).&#xa;" name="__init__">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="zucYfkPbQ9Hl" type="4ax0gnUhtyJt"/>
          <UML:Parameter visibility="private" isSpecification="false" xmi.id="oQsBlMeaS5sB" type="4ax0gnUhtyJt" value="" name="xls_tables"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="r1GUoBoabemN" comment="        Rxncon object is represented as rxncon string &#xa;        (quick format).&#xa;" name="__repr__">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="0OvQRncPhCxK" type="4ax0gnUhtyJt"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="wMvKTB3KCKmy" comment="Uses ComplexBuilder to create ComplexPool.&#xa;1) uses information from biological_complex.biological_complex.ComplexPool to get a list of all boolean complexes defined&#xa;bools = self.contingency_pool.get_top_booleans()&#xa;2) itter over bool contingencies and create a ComplexBuilder object for each&#xa;3) further processing of each boolean contingencies in build_positive_complexes_from_boolean (function of biological_complexes.complexes.ComplexBuilder) to create alternative complex &#xa;- set alternative complex as value of complex_pool (object of biological_complex.biological_complex.ComplexPool ) the key is the boolean state self.complex_pool[str(bool_cont.state)] = alter_comp&#xa;&#xa;" name="create_complexes">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="VaZ5FJQDfLc7" type="4ax0gnUhtyJt"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="7EWmOR7Ln2fE" name="get_requirements_dict">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="BhZO1JKUstZ5" type="4ax0gnUhtyJt"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="AxIqJuxQ6RAV" comment="Prepares a list of complexes applicable to a give reaction.&#xa;@type  reaction_name: string&#xa;@param reaction_name: reaction string e.g. A_ppi_B_[bd_A].&#xa;@rtype:  list of AlternativeComplexes object&#xa;@return: all complexes defined by boolean contingencies applicable to a given reaction. if it is a boolean we should have build it and it should appear in self.complex_pool&#xa;&#xa;1) check if reaction name exists in contingency_pool (object of contingency.contingency_factory.ContingencyFactory(self.xls_tables).parse_contingencies()). If not return empty list&#xa;2) get the contignecies related to the reaction name: cont_root = self.contingency_pool[reaction_name]&#xa;3) iterate over the children of the contingency object. Check if the contingency state type is a boolean. if yes return the repective boolean contingency &lt;&lt; this will return only one possible boolean contingency we need a list >>" name="get_complexes">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="gAcY19dC7t2Q" type="4ax0gnUhtyJt"/>
          <UML:Parameter visibility="private" isSpecification="false" xmi.id="sHodIRpT8Mp9" type="4ax0gnUhtyJt" value="" name="reaction_name"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="mxosMyLCE9nW" comment="        Applys non-boolean contingencies.&#xa;        0, ? are ignored&#xa;" name="apply_contingencies">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="aoAhfA5R5tKR" type="4ax0gnUhtyJt"/>
          <UML:Parameter visibility="private" isSpecification="false" xmi.id="ZczhzppfxRBy" type="4ax0gnUhtyJt" value="" name="container"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="qdd4lOaK1X10" comment="        Function that changes domain name in contingencies &#xa;        with modification state (when domain is not provide by the user).&#xa;        Domain indicates which enzyme creates the state. &#xa;        State must match one of the states produced in the reactions.&#xa; TODO: make ContingencyUpdator class out of it. TODO: separate functions for different updates. TODO: refine this function. Add warnings." name="update_contingencies">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="KqdHHoGqaQVF" type="4ax0gnUhtyJt"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="ZbheSz4GcfKN" comment="        TODO: To be implemented.&#xa;        translation - get empty domains&#xa;        x, ! - get additional reaction / modify existing ones.&#xa;" name="update_reactions">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="4sh3Oh3iXe0n" type="4ax0gnUhtyJt"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="QGb0e6DDfsq6" name="get_input_dict">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="psMQXfnZVTct" type="4ax0gnUhtyJt"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="8dcdFcQfqzdU" comment="        Creates pool of reaction that produce states required in the system&#xa;        and adds them to the systems reaction pool (self.reaction_pool).&#xa;# How does it work????" name="add_missing_reactions">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="piPK9zEFbotq" type="4ax0gnUhtyJt"/>
          <UML:Parameter visibility="private" isSpecification="false" xmi.id="6pgjhUpXKAxp" type="4ax0gnUhtyJt" value="" name="states_list"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="OJWEJ7gNwK6c" comment="        Adds translation reaction for each protein to reaction_pool.&#xa; Add appropriate reaction_factory" name="add_translation">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="mu7642wtkJBs" type="4ax0gnUhtyJt"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
        <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="IN7t90kXIEjZ" comment="Transforms table into objects.&#xa;Groups the information that belong together.&#xa;Adds implicit information.&#xa;&#xa;- add_translation: when Trues add translation reaction for each protein # not available yet.&#xa;- add_missing_reactions: when True looks for required states that are not produced and adds proper reactions.&#xa;- add_complexes: when True applys boolean contingencies.&#xa;- add_contingencies: when True applys non-boolean contingencies.&#xa;&#xa;1) find missing states self.war.calculate_missing_states(self.reaction_pool, self.contingency_pool) war is an object of util.warnings.RxnconWarnings: input is reaction_pool (reaction.reaction_factory.ReactionFactory.reaction_pool) and contingency_pool (contingency.contingency_factory.ContingencyFactory.parse_contingencies())&#xa;2) if add_missing_reactions call add_missing_reactions(list(self.war.not_in_products)) and add the missing products and reactions&#xa;3) if add_translation call add_translation() and add a translation reaction for each component of each reaction (not implemented)&#xa;4)iterate over reaction_pool (object of reaction.reaction_factory.ReactionFactory.reaction_pool). The elements are reaction_container, containing the single reactions for each reaction&#xa;4.1)if add_complex call get_complexes(react_container.name). this checks if there is a boolean contingency for this reaction&#xa;4.2) call ComplexApplicator(react_container, complexes).apply_complexes(). the ComplexApplicator class is initialised with the reaction container and complexes. complexes is empty either if add_complexes is false or there is no boolean contingency for the respective reaction. After this apply_complexes() is called&#xa;4.3) if add_contingencies the function apply_contingencies(react_container) is called and all non boolean contingencies are applied to the reaction container&#xa;4.4) call update_reactions (not implemented)&#xa;4.5) iterate over the reactions in reaction_container and call run_reaction() for each reaction. this translates the source to a respective product of the reaction." name="run_process">
         <UML:BehavioralFeature.parameter>
          <UML:Parameter kind="return" xmi.id="1VnjoxZ7KhyU" type="4ax0gnUhtyJt"/>
          <UML:Parameter visibility="private" isSpecification="false" xmi.id="59CmRA6ZKMRR" type="87Hl5Afww7fn" value="" comment="add_translation: when Trues add translation reaction for each protein # not available yet." name="add_translation"/>
          <UML:Parameter visibility="private" isSpecification="false" xmi.id="bLWq0iL4j2HG" type="87Hl5Afww7fn" value="" comment="add_missing_reactions: when True looks for required states that are not produced and adds proper reactions." name="add_missing_reactions"/>
          <UML:Parameter visibility="private" isSpecification="false" xmi.id="OJtDBrdEyp0P" type="87Hl5Afww7fn" value="" comment="add_complexes: when True applys boolean contingencies." name="add_complexes"/>
          <UML:Parameter visibility="private" isSpecification="false" xmi.id="05yIRPi1jErj" type="87Hl5Afww7fn" value="" comment="add_contingencies: when True applys non-boolean contingencies." name="add_contingencies"/>
         </UML:BehavioralFeature.parameter>
        </UML:Operation>
       </UML:Classifier.feature>
      </UML:Class>
      <UML:Package stereotype="folder" visibility="public" isSpecification="false" namespace="Logical View" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="OPXj5lavULUC" name="contingency">
       <UML:Namespace.ownedElement>
        <UML:Class visibility="public" isSpecification="false" namespace="OPXj5lavULUC" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="nE9Vw6BoS7rq" comment="    Applys contingency on &#xa;    - molecules&#xa;    - compelxes&#xa;    - reactions&#xa;    - reaction containers&#xa;" name="ContingencyApplicator">
         <UML:Classifier.feature>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="7tqNx2cF0HNl" name="__init__">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="urGKy786yzRv" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="CPFgPLeDXniU" type="4ax0gnUhtyJt" value="" name="war"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="z29zJWiTtx7J" comment="        Applys contingency on molecule.&#xa;        Side - indicates whether molecule belong to&#xa;        left or right substrate complex.&#xa;        It is important when we have homodimer states: &#xa;        indicates which domain is used.&#xa;mol.binding_sites.append(cont.state)" name="apply_on_molecule">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="0h12Bk1lc5KQ" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="HlWmXCGR2Uj0" type="4ax0gnUhtyJt" value="" name="mol"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="cr4YqUUnWdlp" type="4ax0gnUhtyJt" value="" name="cont"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="9TG3PMKg7qSc" type="4ax0gnUhtyJt" value="" name="side"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="ZoE5PzsWQ7Xp" comment="        mols      - molecules that are present in complex and in contingency &#xa;                    e.g. Complex: A, B, C; Cont: ! A--X  ---> [A]&#xa;        cont      - Contingency object, e.g. ! A--X&#xa;        component - the other component from contingency - one to be added&#xa;                    e.g. X&#xa;        compl     - complex&#xa;        reaction  - reaction in question&#xa;print 'add_molecule_to_complex'print mols, cont, component, compl check whether contingency state in not equal to product state  check conflicts between contingency and to_change (state that changes in the reaction) check whether domain is not occupied" name="add_molecule_to_complex">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="jHSd5lDpFT8t" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="TrTYfwBgbCgm" type="4ax0gnUhtyJt" value="" name="mols"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="xhYZnqzKeBO3" type="4ax0gnUhtyJt" value="" name="cont"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="8GXZL5MmwqLc" type="4ax0gnUhtyJt" value="" name="component"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="kUGLgw5bcd8N" type="4ax0gnUhtyJt" value="" name="compl"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="T6h5F56OKevf" type="4ax0gnUhtyJt" value="" name="reaction"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="OEV0pbNJf4Mv" comment="        it requires to set the binding_partners for the Intraprotein&#xa;" name="apply_positive_intraprotein">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="Rln7o82wZJMc" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="8RJS5C5mTXNX" type="4ax0gnUhtyJt" value="" name="reaction"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="IbKV2TPQhsQW" type="4ax0gnUhtyJt" value="" name="cont"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="VRMwxjTDIojL" comment="        it requires either&#xa;        - adding a new molecule to a complex&#xa;        - or incorporating two substrate complexes into one&#xa;        and not just editing existing molecules in a complex.&#xa;        It also needs to deal with a situation that there is already one complex.&#xa; situation when we need to join complexes what to do when two molecules are already in? e.g. A.B + C ! A--Bprint &quot;PROBLEM&quot;, mols1, mols2 TODO: Refactor make a function to check this condition. A--B, A and B present in substrates if A--B, A and B present in substrates but if reaction creates A and B we don't join. We want then A here one of mols from contingency is present in both complexes but it was added because of previously applayed contingency so we dont want to join. a molecule needs to be added to complexes  or complexes are already joined:" name="apply_positive_association">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="YiVpUCAjItfG" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="F6lwyAQPtEWh" type="4ax0gnUhtyJt" value="" name="reaction"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="KWbtpxVKNpFI" type="4ax0gnUhtyJt" value="" name="cont"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="34exG8cafETS" comment="        Helper function.&#xa;        Checks which component is already in the complex and adds the second one.&#xa;        What to do when both are already present??? (Not decided yet).&#xa; what to do when two molecules are already in? e.g. A.B + C ! A--Bprint &quot;PROBLEM&quot;, mols1, mols2" name="_add_components_to_complex">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="lAvWlO2Ndmg5" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="9wnUj2mFiG4D" type="4ax0gnUhtyJt" value="" name="compl"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="SEwl8az9cb4s" type="4ax0gnUhtyJt" value="" name="component1"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="khSPttr0ncVW" type="4ax0gnUhtyJt" value="" name="component2"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="cFlJTqWw2QfA" type="4ax0gnUhtyJt" value="" name="cont"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="ycKaEOSy3sLu" type="4ax0gnUhtyJt" value="" name="reaction"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="aA1cZenXG56S" comment="        Positive association won't get here.&#xa; only negative associations get here." name="apply_on_complex">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="0PsEUyfvU3Ot" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="RYOVPjNAsIfd" type="4ax0gnUhtyJt" value="" name="compl"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="ghyIRdN1nMeK" type="4ax0gnUhtyJt" value="" name="cont"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="nm2f2hGjMEzm" comment="        Gets reaction and x or ! contingency.&#xa;        For ! contingencies with input state creates additional substrate complex.&#xa;        For other states applays contingency on substrate complexes.&#xa;" name="apply_on_reaction">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="kD25PzrHJcux" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="rKndgPxeopqI" type="4ax0gnUhtyJt" value="" name="reaction"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="lVCEZY5KI5xL" type="4ax0gnUhtyJt" value="" name="cont"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="2rbqfP7OtHaS" comment="        Applys all input contingencies.&#xa;        Input contingency is applied by changing reaction rate &#xa;        (adding a local function).&#xa;        Rate depend on:&#xa;        - contingency type: different functions for !, x and K&#xa;        - whether reaction is reversible or irreversible&#xa;          (for reversible reaction kr always looks like for K even when its ! or x)&#xa;        Different rate function types:&#xa;        - k1*k_Input                     ---> function for ! [Input]&#xa;        - k1*(1-k_Input)                 ---> function for x [Input]&#xa;        - k1_1*(1-k_Input)+k1_2*k_Input  ---> for K+/K- and all reversed reactions  &#xa;          (complex must be able to dissociate even when input is not present an more)&#xa; establish new ids for rates - num1, num2 int we will have two rates here (because of reverse reaction). just multiply old rate by input rate. We don't need new rate numbers here. Because it is still one rate. here input rate is a switch between two rates." name="apply_input_on_container">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="auFTBotySd29" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="nek6hhPSsRXH" type="4ax0gnUhtyJt" value="" name="container"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="OMWhyQe0GDpt" type="4ax0gnUhtyJt" value="" name="cont"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="IRZ8q4QEQwvP" comment="        When applying K+/K- contingency rates need to be updated.&#xa;        This function returns a list of new ids which &#xa;        will be used for updating.&#xa;        e.g. &#xa;        ['1', None]&#xa;        ['3_5', '3_6']&#xa; TODO: Does this function belongs here? Trys to keep old id if possible" name="get_rate_ids">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="dEDHnqjQsQTp" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="LXNZiAQJ4fkF" type="4ax0gnUhtyJt" value="" name="reaction"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="TeCtFE1WeaeU" type="4ax0gnUhtyJt" value="" name="container"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="d2h3zaQI8mro" type="4ax0gnUhtyJt" value="" name="subrate"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="wH71uqGMUQFh" type="4ax0gnUhtyJt" value="" name="keep_old"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="1s77ewvaD1b8" comment="        Applys a contingency on a container.&#xa;        Top level function. It is called first and directs tasks to other functions.&#xa;        --- If contingency contains Input state:&#xa;            apply_input_on_container&#xa;        --- If ctype x or ! (no Input):&#xa;            apply_on_reaction&#xa;            --- If contingency state is Association then:&#xa;                apply_positive_association&#xa;        --- If ctype is K+ or K- (no Input):&#xa;            clone all the reactions in the container &#xa;            for each reaction (now two) apply one ! and one x&#xa;            (it is done like in previous step).&#xa;            Updates rate:&#xa;            reaction.rate.update_name&#xa;        Only normal contingencies are applied here.&#xa; TODO: some ugly stuff here - refactor.       emptying container and adding them again to get consistent ids.       Remove some iterations. Input contingencies are handled by adding function to reaction rate.rate_dict = self.prepare_rates_dict()print 'Len:', len(container)print 'Reaction in orig container:', reaction.substrat_complexes[0].molecules[0].modifications, reaction.substrat_complexes[0].molecules[0].modification_sitesprint 'Mod before cloning', reaction.substrat_complexes[0].molecules[0].modificationsprint 'Mod site before cloning', reaction.substrat_complexes[0].molecules[0].modification_sitesprint 'Mod after cloning', reaction.substrat_complexes[0].molecules[0].modificationsprint 'Mod site after cloning', reaction.substrat_complexes[0].molecules[0].modification_sites############## BUGprint 'After applying:', reaction.substrat_complexes[0].molecules[0].modifications, reaction.substrat_complexes[0].molecules[0].modification_sitesfor reaction in temp2:    print 'Reaction in temp2:', reaction.substrat_complexes[0].molecules[0].modifications, reaction.substrat_complexes[0].molecules[0].modification_sites" name="apply_on_container">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="kIbxJA3AyVRD" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="rqUJEh0ruC8h" type="4ax0gnUhtyJt" value="" name="container"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="0q7sGYiHOnO2" type="4ax0gnUhtyJt" value="" name="cont"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
         </UML:Classifier.feature>
        </UML:Class>
        <UML:Package stereotype="datatype" visibility="public" isSpecification="false" namespace="OPXj5lavULUC" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="tosP0U9k70Vc" name="contingency_factory">
         <UML:Namespace.ownedElement>
          <UML:Class visibility="public" isSpecification="false" namespace="tosP0U9k70Vc" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="qeeki9z1YCSm" comment="    Parses all contingencies from xls_tables['contingency_list'].&#xa;    E.g.&#xa;    A_ppi_B; ! A--C&#xa;    A_ppi_B; ! A--D&#xa;    A_ppi_B; K+ &lt;MM> &#xa;    &lt;MM>; AND B-{P} &#xa;    &lt;MM>; AND &lt;MM2>&#xa;    &lt;MM2>; OR C-{P}&#xa;    &lt;MM2>; OR D-{P}&#xa;    A_ppi_B : root&#xa;    root.children ---> [! A--C, ! A--D, K+ &lt;MM>]&#xa;" name="ContingencyFactory">
           <UML:GeneralizableElement.generalization>
            <UML:Generalization xmi.idref="yfVWrajDKFO8"/>
           </UML:GeneralizableElement.generalization>
           <UML:Classifier.feature>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="QyAjBWrUKkgM" name="__init__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="GqsLi6H62RpD" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="RyCltonvOoV8" type="4ax0gnUhtyJt" value="" name="xls_tables"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="xhfFPLbqKnaD" comment="        Returns a ContingencyPool object.&#xa;        It is a dict that holds all top nodes contingencies of a reaction.&#xa;        Key - reaction string. Value - list of contingencies. &#xa; Could be recurrent because of boolean nodes (we cannot add child if the parent is not there) but then we have risk that we have infinite loop  if the parent does not exist. For now we have parse_later but it may not be sufficient in all cases. children for booleans for which there was no parent in first roundself.parse_complexes(complexes)" name="parse_contingencies">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="aL7wAc4OSuh8" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="yyF1Q2ELjub8" name="check_cont_in_children">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="FYjwSI3fTyDP" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="FAxZwVlWqqQy" type="4ax0gnUhtyJt" value="" name="cont"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="QUMrM1zK0CLQ" type="4ax0gnUhtyJt" value="" name="children"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="TwtJmJGCla37" comment="        Parses single contingency from row.&#xa;        If it is not possible - parent is not yet there returns row.&#xa;" name="parse_contingency">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="2MMTIZqlVj2H" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="c1PcBj0OHjJj" type="4ax0gnUhtyJt" value="" name="row"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="2ISltTsTUH5e" comment="        Gets components from a reaction string.&#xa;        E.g. &#xa;        A_ppi_B&#xa;        A_[domain]_P+_C&#xa;        A_ppi_X_[domain]&#xa; TODO: does not belong here - should be done in a different place." name="get_components_from_reaction">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="s5eOmhdmx5Xo" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="y50FmJwmdJFv" type="4ax0gnUhtyJt" value="" name="reaction_string"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="ZPH1fKfdPgrC" comment="        Returns a parent (BooleanContingency object)&#xa;        for given contingency.&#xa;" name="find_parent">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="oyol2MYbjncO" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="xnyb6CWxH9L2" type="4ax0gnUhtyJt" value="" name="contingency"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="8G0XurhrceQj" comment="        Returns a list of all BooleanContingencies &#xa;        from given list of contingencies.&#xa;        It uses recurrence to check &#xa;        whether there are any booleans among children &#xa;        of the boolean that has been already found.&#xa;" name="get_booleans">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="G7Wzv7M1NKWF" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="ove34z5svubx" type="4ax0gnUhtyJt" value="" name="cont_list"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="9C6lqVSeQ6hS" comment="        Creates Contingency objects.&#xa;" name="create_contingency">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="dr0aGqQk3HbZ" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="3lIxfruvzPss" type="4ax0gnUhtyJt" value="" name="target_reaction"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="WCttWN6fZCRP" type="4ax0gnUhtyJt" value="" name="ctype"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="ft13yhV1Sly7" type="4ax0gnUhtyJt" value="" name="state"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
           </UML:Classifier.feature>
          </UML:Class>
          <UML:Class visibility="public" isSpecification="false" namespace="tosP0U9k70Vc" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="qZ07QNQqiLbk" comment="    ContingencyPool object is a container for all&#xa;    contingencies parsed from xls_tables['contingency_list'].&#xa;" name="ContingencyPool">
           <UML:GeneralizableElement.generalization>
            <UML:Generalization xmi.idref="YlfHtLJ5iQ4s"/>
           </UML:GeneralizableElement.generalization>
           <UML:Classifier.feature>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="V1lBQp3K9PPP" name="__init__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="57TLrdyvBSh6" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="YBXNKG3nHozf" comment="        Returns a list of all boolean contingencies.&#xa;" name="get_all_booleans">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="b00kNN8TUZmL" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="AiGLBvPh6x2P" comment="        Returns a list of boolean contingencies &#xa;        that are direct children of the root contingency.&#xa;" name="get_top_booleans">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="D3CSr98QA68X" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="TEyxoiGwRVGa" comment="        Removes contingency but only if it is in the top level&#xa;        (directly under the root).&#xa;" name="remove_contingency">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="EOZMSfrvuqqg" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="QfHVcHunK4G9" type="4ax0gnUhtyJt" value="" name="cont"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Y6cxbsX0YmV8" comment="        Allows to obtein states that need to be present in the system&#xa;        to allow contingencies (the context) to be fulfilled.&#xa;        (States that should be produced be reactions).&#xa;        @return: all states from x, !, and K contingencies except input states&#xa;        @rtype:  set&#xa;        @todo:   what about ! &lt;OR> are all states required? &#xa;" name="get_required_states">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="3NwLRCUfY1z0" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="hrtZhjFDprBP" comment="        Returns all contingencies with Covalent Modification state.&#xa;        Used when updating contingencies.&#xa;" name="get_kind_contingencies">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="QKIyKHw18pan" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="igNETsMWFGqe" type="4ax0gnUhtyJt" value="" name="kind"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Wn1KeAjKq4YH" comment="        Returns all contingencies with Covalent Modification state.&#xa;        Used when updating contingencies.&#xa;" name="get_modification_contingencies">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="wtm99cnaw3WE" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="LRFREnFlaE5D" comment="        Returns all contingencies with Covalent Modification state.&#xa;        Used when updating contingencies.&#xa;        Returns all contingencies with Relocalisation state.&#xa;        Used when updating contingencies.&#xa;" name="get_Intraprotein_contingencies">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="MmXAq4SkxEr4" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
           </UML:Classifier.feature>
          </UML:Class>
         </UML:Namespace.ownedElement>
        </UML:Package>
        <UML:Class visibility="public" isSpecification="false" namespace="OPXj5lavULUC" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="ehDEredXVdYT" comment="    Contingency object is a data structure for rxncon contingency.&#xa;    It contain information about target reaction, type of contingency,&#xa;    and state that influences the target reaction. &#xa;    Every contingency may have children.&#xa;" name="Contingency">
         <UML:Classifier.feature>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="K2TknPpOGpyU" comment="        @param target_reaction: A_ppi_B, &lt;Bool>&#xa;        @type target_reaction: string&#xa;        @param ctype: !, x, k+, k-, 0, and, or, 1--2&#xa;                    (normal: !, x, k+, k-, 0&#xa;                     boolean: and, or&#xa;                     complexes with defined geometry: 1--2)&#xa;        @type ctype: string&#xa;        @param state: A--B, A-{P}, B-{Mito}, &lt;Bool>&#xa;        @type state: State object&#xa;        @ivar children: each contingency (complex or boolean)&#xa;                        may contain children - other contingencies.&#xa;        @type children: list&#xa;        @ivar inharited_ctype: keeps normal ctype for contingencies &#xa;                               with boolean or complex ctype. It is &#xa;                               ctype of a parent.&#xa;        @type inharited_ctype: string&#xa;" name="__init__">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="57rYkP02RTmD" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="fMEgdnGIUTWM" type="4ax0gnUhtyJt" value="" name="target_reaction"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="sbb7OYZ2soiW" comment="Representation of contingency: ctype state, e.g. ! A--B" name="__repr__">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="Zwo4NIOQPDzA" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="czA2QxDIWmNv" comment="        Two ContingencyComponent objests are eqal when &#xa;        target reaction, ctype and states are eqal.&#xa;" name="__eq__">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="liMAvLIWKTWk" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="IxxBjdhIaTMv" type="4ax0gnUhtyJt" value="" name="other"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Oj0uVOnoJkx2" comment="Anables set operstion." name="__hash__">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="McKw5froNDwH" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="WFnqgJY22XuV" name="has_children">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="tiHCQEEmqWgt" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="9YhXjeoGrZ4V" comment="        Counts all leaf contingencies.&#xa;                &lt;MM>&#xa;                /  \&#xa;            &lt;MM2>   D-{P}&#xa;            /   \&#xa;        E-{P}  F-{P}&#xa;        &lt;MM> has 3 leafs&#xa;" name="count_leafs">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="rNGgrxX1TFWA" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="sbVs6PNz5f9U" type="4ax0gnUhtyJt" value="" name="node"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="rIOgrR9j2cb8" comment="        Returns all leaf contingencies.&#xa;" name="get_leafs">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="icP9pvKeBgI2" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="zw53bEXRZn5Q" type="4ax0gnUhtyJt" value="" name="node"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="7Pl91KFzHK2q" comment="        Returns all children - leafs and booleans.&#xa;" name="get_children">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="nSNy9f1E5kO4" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="WZF5KKU1vtAk" type="4ax0gnUhtyJt" value="" name="node"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="3b3Iu58QeMUz" comment="        Adds given contingency to children list.&#xa;" name="add_child">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="KYwNGISJsVbm" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="gy0bp8KcZhZi" type="4ax0gnUhtyJt" value="" name="contingency"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="ZiAB4c8ka8KQ" comment="        Checks whether given contingency is a child.&#xa;" name="is_parent">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="fRdXuFHRxPdz" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="Fc0oHXUb5OzM" type="4ax0gnUhtyJt" value="" name="contingency"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="2ljcs107bzts" comment="        Returns new Contingency object.&#xa;        It can have different ctype if specified.&#xa;" name="clone">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="mCChapgcaOCQ" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="WNUalTuOsXvk" type="4ax0gnUhtyJt" value="" name="ctype"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
         </UML:Classifier.feature>
        </UML:Class>
       </UML:Namespace.ownedElement>
      </UML:Package>
      <UML:Class visibility="public" isSpecification="false" namespace="Logical View" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="w9mgAPbqJCmi" name="util.warnings.RxnconWarnings"/>
      <UML:Package visibility="public" isSpecification="false" namespace="Logical View" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="rKsDP6CIv2ht" name="reaction">
       <UML:Namespace.ownedElement>
        <UML:Class visibility="public" isSpecification="false" namespace="rKsDP6CIv2ht" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="8Wq9i8yrhK77" comment="subtypes inside that behave in a different way? Add classes?" name="Reaction">
         <UML:Classifier.feature>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Kg4hurUhPNER" comment="Abstract class for rxncon reactions.&#xa;Concrete classes are: Interaction, Modification, SyntDeg, Relocalisation.&#xa;left_reactant:&#xa;right_reactant:&#xa;substrate_complexes:&#xa;" name="__init__">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="TtVN4XAD1zKj" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="7GYoaftuJwaE" comment="e.g. A_ppi_B" name="__repr__">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="n4tAP6btz4E3" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="bPEaOWJTnpFL" comment="        Prints detail information about reaction.&#xa;## REACTION: %s, %s&quot; % (self.name, self.rid)for prod in self.product_complexes:    prod.inspect()print &quot;Input conditions: %s&quot; % str(self.conditions)print &quot;Changed state:    %s&quot; % str(self.to_change) print &quot;Reaction rate:    %s&quot; % str(self.rate) " name="inspect">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="V8Go4o0pqszF" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="ya6vdLwEi9p4" comment="        Function specific for each type of reaction.&#xa;        Makes ready reaction out of one that has only substrate complexes.&#xa;        - updates substrate complexes&#xa;          (e.g.: TRSC has in substrate 2 complexes: polymerase and gene,&#xa;                  needs to be updated to just polymerase).&#xa;        - creates and adds product complexes &#xa;" name="run_reaction">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="f6XQummPs2Bx" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="oAke0krwIwrv" comment="Returns new instance.None # RxnconMolecule objectNone # RxnconMolecule object" name="clone">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="Fl8xuv1YzWyt" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="IkI8kS5WaoAa" comment="Function specific for each type of reaction." name="get_domain">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="Y0UouJk94s4x" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" ownerScope="classifier" isRoot="false" xmi.id="l3TkZRepAuxu" comment="Function specific for each type of reaction." name="add_substrate_complex">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="FrYIhaDSdgDA" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="M1RunZSLXw7R" type="4ax0gnUhtyJt" value="" name="compl"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="7rxHltA6sZyf" comment="        Returns State object that will change during the reaction:&#xa;        source state:  x State&#xa;        product state: ! State&#xa;" name="get_sp_state">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="8RygL55Zvcpa" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="C23oiEyn3u3m" comment="        Returns contingencies list.&#xa;        Contingencies define a context for a given reaction. &#xa;" name="get_contingencies">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="nBqdkpGqEEUZ" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Ha6CAvnMvoAb" name="get_specific_contingencies">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="Vd7hrcE6ALJK" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="27N31OpmZgNH" type="4ax0gnUhtyJt" value="" name="common_cont"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="E4eAqplqw8tv" comment="        Finds left and right complex in substrate_complexes.&#xa;        @param side: 'L', 'R', or 'LR' (stends for Left and Right)  &#xa;        @type side: string&#xa;    &#xa;        @return: left or right complex.&#xa;        @rtype: BiologicalComplex.&#xa;" name="get_substrate_complex">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="2laA4rUIv6Qj" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="Wif3M2KpfSWW" type="4ax0gnUhtyJt" value="" name="side"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="vCZpISkn9PqV" comment=" useing state_comp instead of state.components to avoid that A--A will be added as binding partner to A only once.state.components:" name="join_substrate_complexes">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="0DxuJNdDXD2o" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="P9L4ZrYba9le" type="4ax0gnUhtyJt" value="" name="state"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="dlbm8PIYYdc7" comment="        Returns product state as a contingency:&#xa;        x if state is destroyed&#xa;        ! if state is produced&#xa;" name="get_product_contingency">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="S9g3IPhIccAu" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="yo7Vz7JcqsNz" comment="        Returns source state as a contingency&#xa;" name="get_source_contingency">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="IfVoG5uiEalW" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="0Tna5xU1jZXi" comment="        Returns a list of complexes that don't change during the reaction.&#xa;" name="get_modifier">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="foJVfgSvJxjZ" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="1dHFE1kCUVmX" comment="        Returns the main id number e.g.&#xa;        1_1 ---> 1&#xa;        120_1 ---> 120&#xa;        33 ---> 33&#xa;" name="main_id">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="QFZAm4qRq7xT" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
         </UML:Classifier.feature>
        </UML:Class>
        <UML:Package visibility="public" isSpecification="false" namespace="rKsDP6CIv2ht" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Uqbbo6B51FmD" name="rate">
         <UML:Namespace.ownedElement>
          <UML:Class visibility="public" isSpecification="false" namespace="Uqbbo6B51FmD" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Y3YYHqxTRgLZ" comment="    Object Rate keeps info about rates for a single reaction.&#xa;    Rate is set when reaction is created (in ReactionFactory).&#xa;    Basic reat is a simple one e.g. k1.&#xa;    Rate needs to get updated:&#xa;    - when applying complexes - boolean contingencies on reaction:&#xa;      --- when k+/k- &lt;bool> (more rates, number of rates != number of rules!!!)&#xa;      --- when Input is a part of boolean (add a function)&#xa;    - when applying contingencies&#xa;      --- when k+/k- cont (more rates (*2), number of rates == number of rules)&#xa;      --- when Input is a part of contingency (add a function)&#xa;    We are not dealing with multiple input conditions for one reaction.&#xa;" name="Rate">
           <UML:Classifier.feature>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="2CxteQHl0ggt" comment=" rate names rate for irreversible reaction. forward rate. reverse rate. simple rate name can be exchanged with a functuin. it allows to include conditions e.g. input. e.g. ['kf1_1', 'kr1_1']. e.g. ['k_start']" name="__init__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="665YmP5pb2iD" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="lwMw7KldNI9c" type="4ax0gnUhtyJt" value="" name="reaction"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="RywRedINXdKd" name="__repr__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="x3EIJOuQS0wF" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="P12y2iCTg8sJ" comment="        Sets rate names based on reaction data.&#xa;        Name can be a simple name (e.g. k1, kf1, kr1, k1_1) &#xa;        or a function (we have three types of functions)&#xa;        &#xa;        For a reversible reaction frate and rrate have values and rate is None.&#xa;        For a irreversible reaction rate has a value and frate and frate are None.&#xa; rate for irreversible reaction forward rate reverse rate e.g. [kf1_1, kr1_1, k_start]" name="set_basic_rates">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="Qtjrrd6Gd6Ff" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="j9gFmyqh24zJ" type="4ax0gnUhtyJt" value="" name="reaction"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="mP6RVwkD5QSp" comment="        Returns rate names (or functions) as a list of strings.&#xa;" name="get_rates_for_reaction">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="PGWPITihNQYC" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="3cTgigLS5PtY" comment="        Returns ids used in this Rate object&#xa;        e.g. &#xa;        [1_1, 1_2]&#xa;        [1]&#xa;        One Rate may hace maximaly two such ids.&#xa;" name="get_ids">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="MdlP4DDRRhok" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="BWRWwzi0b9eH" comment="        Returns dict:&#xa;        {Rate_name: rate_value}&#xa;        All normal rate values are set to 1.&#xa;        All special (input) rate values are set to 0&#xa;" name="get_rate_values">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="p0jsNdRhEC7G" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="OIhnzVX80wcw" comment="        Exchanges number after k in the rate name with given value. &#xa;        E.g. &#xa;        1_2 ---> self.rate = k1_2&#xa;        3_2 ---> self.frate = kf3_2 &#xa; this part is for updating ones with two rates e.g. when K+ input this part is for updating rates with two rates e.g. k+ input or ppi input only reverse reaction has two rates: both forward and reverse reactions have two rates:" name="update_name">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="iR3iLfcHyXjT" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="vLuUUZjIXT8u" type="4ax0gnUhtyJt" value="" name="new_num"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="4ZcIkhZ6xEtw" type="4ax0gnUhtyJt" value="" name="new_num2"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="4TjbwpTyP3E7" comment="        Exchanges rate number with function.&#xa; reverse reaction always need two rates: dissociation even when input is not present. reverse reaction always need two rates: dissociation even when input is not present." name="update_function">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="0O4EnANziTbK" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="ilBf04agTdOp" type="4ax0gnUhtyJt" value="" name="contingency"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="Iy4HTniXGP6A" type="4ax0gnUhtyJt" value="" name="is_switch"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="Ea6bbLgK6rz4" type="4ax0gnUhtyJt" value="" name="num1"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="wZkNA6AR5EiY" type="4ax0gnUhtyJt" value="" name="num2"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
           </UML:Classifier.feature>
          </UML:Class>
         </UML:Namespace.ownedElement>
        </UML:Package>
        <UML:Package visibility="public" isSpecification="false" namespace="rKsDP6CIv2ht" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="uvdnvKhQ8Gzw" name="reaction_factory">
         <UML:Namespace.ownedElement>
          <UML:Class visibility="public" isSpecification="false" namespace="uvdnvKhQ8Gzw" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="vG7ZXBfwD7DN" name="reaction_factory.molecule_pool"/>
          <UML:Class visibility="public" isSpecification="false" namespace="uvdnvKhQ8Gzw" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="R1SJCAJ0OFAU" name="reaction_factory.reaction_pool"/>
          <UML:Class visibility="public" isSpecification="false" namespace="uvdnvKhQ8Gzw" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="lEa8AfhON7wu" comment="    Builds ReactionPool and MoleculePool.&#xa;    Uses either ReactionFactoryFromDict or ReactionFactoryFromList &#xa;    ReactionFactoryFromDict - classical parsing of input .&#xa;    ReactionFactoryFromList - for creating ractions for missing states.&#xa;" name="ReactionFactory">
           <UML:Classifier.feature>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="eDm9NYbPw5QV" comment="        Imput: xls_tables (dict) or list of states.&#xa;" name="__init__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="WLgtTal5mWE7" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="C7lGpvJY9rgK" type="4ax0gnUhtyJt" value="" name="imp"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="2qXztxS32EHp" comment="        Checks type of input and uses right factory.&#xa;" name="parse_reactions">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="nYtZ48g4wD3n" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="9bNIS2axNEoo" type="4ax0gnUhtyJt" value="" name="imp"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
           </UML:Classifier.feature>
          </UML:Class>
          <UML:Class visibility="public" isSpecification="false" namespace="uvdnvKhQ8Gzw" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="LLpqtswtYU6b" comment="    Builds ReactionPool and MoleculePool from the xls_tables dict. &#xa;" name="ReactionFactoryFromDict">
           <UML:Classifier.feature>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="tjoElcVC46GH" name="__init__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="5UWdwaDpK123" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="ZpE4ORQkmDYd" type="4ax0gnUhtyJt" value="" name="xls_tables"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="eVFgcTv9I9Df" comment="        Go through all rows in xls_tables['reaction_list']&#xa;        and cretes single ReactionContainer object or each row.&#xa;        Adds ReactionContainer to ReactionPool.&#xa;        Adds left and right reactant to  MoleculePool.&#xa;" name="parse_reactions">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="2i7Mi7PKacyA" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="ZbPLovxuNTVJ" type="4ax0gnUhtyJt" value="" name="xls_tables"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="5uJM1W1a5Ouu" comment="        Adds left and right reactant as Molecule objects. &#xa;        For ipi there is only single object as left and right reactant.&#xa;" name="add_reactants">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="e4QkQKchBMLU" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="HrmeKHvMy0gg" type="4ax0gnUhtyJt" value="" name="reaction"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="730gfyqjqA3s" type="4ax0gnUhtyJt" value="" name="row"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="dEqZFVFKYD0C" comment="&#xa;        Gets info common for all reactions into reaction object.&#xa;        @type row:  dict&#xa;        @param row: row from xls_tables['reaction_list']&#xa;        @rtype: specific Reaction object&#xa;" name="get_preliminary_reaction">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="Zv3lHMFta3Sp" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="Arv0zyqd0HLO" type="4ax0gnUhtyJt" value="" name="row"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Yg85t8H1xA2u" comment="        Takes a row and returns reaction object.&#xa; if subtype == Trnas second state changes in the reaction PT ipi is destinctive state: it is A_[a]--[b] where both domains are in the same protein.if reaction.rtype == 'Association':" name="get_reaction_object">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="pfvPgODF4LIv" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="6qY45rSfnTQ4" type="4ax0gnUhtyJt" value="" name="row"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
           </UML:Classifier.feature>
          </UML:Class>
          <UML:Class visibility="public" isSpecification="false" namespace="uvdnvKhQ8Gzw" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="RZxPjxJnnprr" comment="Builds ReactionPool and MoleculePool from a list of states." name="ReactionFactoryFromList">
           <UML:Classifier.feature>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="fHWSkwUZZOwF" name="__init__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="ZalLOcC3tiTd" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="m9SoSkhuHeH0" type="4ax0gnUhtyJt" value="" name="states_list"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="cvABJ7O5Eprh" comment="        Returns string that describes reaction type.&#xa;        E.g. 'ppi', 'p+'&#xa; TODO: find out more elegant way TODO: this won't be working add function for that." name="get_reaction_type">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="BGp3yIeaEpjX" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="ZZZrBqplQZ6m" type="4ax0gnUhtyJt" value="" name="state"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="w5bAuQpSzOH9" comment="        Creates reaction string e.g. A_[n]_ppi_B_[c] from state.&#xa;" name="get_reaction_str">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="VWkhLRDFWmOR" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="E6udfyPpEDsC" type="4ax0gnUhtyJt" value="" name="state"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="CDtCaALmEDPs" comment="        Adds left and right reactant as Molecule objects. &#xa;        For ipi there is only single object as left and right reactant.&#xa;" name="add_reactants">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="alSpysf7dKSd" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="9nfN0XXT1F9L" type="4ax0gnUhtyJt" value="" name="reaction"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="gMYC6wbI8SSg" type="4ax0gnUhtyJt" value="" name="state"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="px4oCD7qXg1d" comment="&#xa;        Gets info common for all reactions into reaction object.&#xa;" name="get_preliminary_reaction">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="f5AINatCYxzi" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="acug5MMd8pS4" type="4ax0gnUhtyJt" value="" name="state"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="96ZekaGLA81D" comment="        Takes a row and returns reaction object.&#xa;categories_dict = self.definitions.categories_dict" name="get_reaction_object">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="N1vvwse3yBgj" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="UOraDHfsNn8k" type="4ax0gnUhtyJt" value="" name="state"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="ju2t217WPw7a" comment="        Go through all states in states_list&#xa;        and cretes single ReactionContainer object for each state.&#xa;        Adds ReactionContainer to ReactionPool.&#xa;        Adds left and right reactant to  MoleculePool.&#xa;" name="parse_reactions">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="4QT0Z9hI3j95" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="DkQYXYJuXCoS" type="4ax0gnUhtyJt" value="" name="states_list"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
           </UML:Classifier.feature>
          </UML:Class>
         </UML:Namespace.ownedElement>
        </UML:Package>
        <UML:Class visibility="public" isSpecification="false" namespace="rKsDP6CIv2ht" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="lNO4J8bKjrXv" name="Interaction">
         <UML:GeneralizableElement.generalization>
          <UML:Generalization xmi.idref="sF7Kksr95OJr"/>
         </UML:GeneralizableElement.generalization>
         <UML:Classifier.feature>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="lVnor4eGBvVO" comment="        Creates product_complexes.&#xa;        ipi has separate function because it is special - &#xa;        has only one substrate complex (the same protein, a bond inside is added).&#xa;" name="run_ipi_reaction">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="7BNgGOXR0fKU" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="L8nF1RtlueZl" comment="        Assumes that there are always two substrate complexes.&#xa;if len(self.substrat_complexes) != 2:    raise TypeError('Protein-protein interaction can only happen between two complexes.')" name="run_reaction">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="gDzr8UEDeZss" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
         </UML:Classifier.feature>
        </UML:Class>
        <UML:Class visibility="public" isSpecification="false" namespace="rKsDP6CIv2ht" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="cxUNVy2crBHu" name="Relocalisation">
         <UML:GeneralizableElement.generalization>
          <UML:Generalization xmi.idref="xVFLzi7gp0kZ"/>
         </UML:GeneralizableElement.generalization>
         <UML:Classifier.feature>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="sKvgIdFvJZ25" comment="        Returns complex that doesn't change during reaction:&#xa;        - channel&#xa;        - transporter&#xa;        The substrate complex is returned &#xa;        (the same as product but different _id).&#xa;" name="get_modifier">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="2lQRx9M8wsBq" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="f7jvFvA6D3mV" comment="        Runs relocalisation reaction.&#xa;        Adds product complexes.&#xa;        Changes loc attrib for localisation of right molecule. &#xa;" name="run_reaction">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="gzO0XO3X8Rw5" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
         </UML:Classifier.feature>
        </UML:Class>
        <UML:Class visibility="public" isSpecification="false" namespace="rKsDP6CIv2ht" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="q4764XrJtgrn" comment="    Reactions: &#xa;    trsc (trancsription)&#xa;    trsl (translation)&#xa;    deg (degradation)&#xa;" name="SyntDeg">
         <UML:GeneralizableElement.generalization>
          <UML:Generalization xmi.idref="YzoE26xixnzQ"/>
         </UML:GeneralizableElement.generalization>
         <UML:Classifier.feature>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="HcGCPDc8Pgms" comment="        Returns complex that doesn't change during reaction:&#xa;        - protein that degrades other protein&#xa;        - polymerase&#xa;        - ribosom, mRNA&#xa;        A substrate complex is returned.&#xa;        (it is the same as product but has different _id)    &#xa;" name="get_modifier">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="0tAO8XotnZWh" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="7t8g5oEKOUVm" name="run_reaction">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="h7u6mfwmW79c" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
         </UML:Classifier.feature>
        </UML:Class>
        <UML:Package visibility="public" isSpecification="false" namespace="rKsDP6CIv2ht" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="CrzCfhXYaALW" name="reaction_container">
         <UML:Namespace.ownedElement>
          <UML:Class visibility="public" isSpecification="false" namespace="CrzCfhXYaALW" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="mHcr9bv39eOH" comment="Module reaction_container.py &#xa;containes classes that store the reactions for the entire rxncon system.&#xa;Class ReactionContainer(list) - container for alternative reactions &#xa;(e.g. reaction that has boolean, &#xa;complex or K+/K- contingencies).&#xa;Stores one ore more Reaction objects.&#xa;Class ReactionPool(dict)      - dictionary for all ReactionContainers &#xa;present in the system. &#xa;" name="ReactionContainer">
           <UML:GeneralizableElement.generalization>
            <UML:Generalization xmi.idref="kZinlQKlmOyX"/>
           </UML:GeneralizableElement.generalization>
           <UML:Classifier.feature>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Glu29sYgB5vx" comment="Container for alternative reactions as one reaction can happen&#xa;in many contexts (e.g. K+/K- contingency).&#xa;Enables obtaining info about properties common for all reactions inside&#xa;" name="__init__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="BUUWfszNASF5" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="KOjjDBsTumU2" comment="        @return: name and number of reactions in the container.&#xa;" name="__repr__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="c2in5biE5Dii" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="3h5D8KJQg0Au" comment="        Adds given reaction to the container.&#xa;        @type reaction:  Reaction object&#xa;        @param reaction: Reaction to add.&#xa; TODO: check whether it is reaction.  TODO: check whether it belongs to the container (same name). TODO: check whether id is free." name="add_reaction">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="Lp8Q0r64WBFc" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="90N4mp6Mpm7u" type="4ax0gnUhtyJt" value="" name="reaction"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="UY3AXD4gBQkv" comment="        Changs conteiner.rid and rid of each reaction.&#xa;        Subnumbers stay the same&#xa;        e.g. update_rid(8)&#xa;        container.rid = 8&#xa;        reaction1.rid = 8_1&#xa;        reaction2.rid = 8_2&#xa;        Automatically updates rate.&#xa;" name="update_rid">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="vNGPXT2125BZ" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="FoH5YOztB6HC" type="4ax0gnUhtyJt" value="" name="new_id"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="GGDRgyMtkbyJ" comment="        The source/product state of all reactions present in the continer.&#xa;" name="sp_state">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="zwAA2SKvnYIK" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="2KJ2NVZdjm2N" comment="        The product state of all reactions present in the continer.&#xa;" name="product_contingency">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="kOGVxFmw9u59" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="MP48yMS0fm22" comment="        The source state of all reactions present in the continer.&#xa;" name="source_contingency">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="FbeyNgJ63ZZ0" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="mJvvD04YN6gL" comment="        Requirements common for all reactions in the container.&#xa;        @rtype:  list of Contingency objects.&#xa;        @return: intersection of contingencies (context) &#xa;                 read from all reaction object.&#xa;" name="get_common_contingencies">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="R6J6qJ65uk1G" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="PKKQsrOeAJYN" comment="        Returns a list of complexe that don't change during the reaction.&#xa;        They are common for all the reactions in the container.&#xa;        @rtype:  list of BiologicalComplex objects.&#xa;        @return: substrat complexes that are not changed in the reaction.&#xa;" name="get_modifier">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="Havfhby8iICW" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="bIcU1biOu0om" comment="        For ich reaction chaecks all rates. &#xa;        From all rates checks which number after '_', is the highest.&#xa;        If reaction has only single rate returns 0.&#xa;        Returns int.&#xa;        e.g.&#xa;        kf1_1, kr1_1; kf1_2, kr1_2; kf1_3, kr1_3 ---> 3&#xa;        k1; k1 ---> 0 &#xa;" name="highest_subrate">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="rAO1UwOjVIOC" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="rLIXbS4Cigej" comment="        Removes all reactions.&#xa;" name="empty">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="FK79Ktv94IAW" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
           </UML:Classifier.feature>
          </UML:Class>
          <UML:Class visibility="public" isSpecification="false" namespace="CrzCfhXYaALW" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="CXFhncrex7CY" comment="    Contains all ReactionContainers for the system.&#xa;" name="ReactionPool">
           <UML:GeneralizableElement.generalization>
            <UML:Generalization xmi.idref="ZGiIuLz9d5Jw"/>
           </UML:GeneralizableElement.generalization>
           <UML:Classifier.feature>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="k8cODtIA3L8W" name="__init__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="Zd9GLTkfdtsx" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Ddmm4vEn1oBD" comment="        Allows to iter reactions sorted by id.&#xa;" name="__iter__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="fRLhmTBK4KaP" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="lL2PCuKPX6Ba" comment="        Return the highest id of the containers present.&#xa;" name="get_highest_id">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="zON0AWBqxWXj" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="yi120aSltU85" comment="Adds reactions from another pool." name="update_pool">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="Lf0GAVy8DzAB" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="PSUuWeUV2pUA" type="4ax0gnUhtyJt" value="" name="second_pool"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="ZaxS35VQW0K2" comment="        @return: states that are produced in the reactions&#xa;        @rtype:  set&#xa;" name="get_product_states">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="cnWcc0mwdnCl" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="IArU80ffaa6d" comment="        Produces collection of all states generated by this reaction pool as contingencies.&#xa;        @return: states that are produced in the reactions.&#xa;        @rtype:  set.&#xa;" name="get_product_contingencies">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="eb1AbMAB7gnj" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="eadGLo1byt34" comment="        Returns set of sets that are destroyed in the pool.&#xa;        E.g. in P-, Ub- GAP reactions.&#xa;" name="get_destroyed_states">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="rjkRHq3vR431" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="OECVsyDXYqlr" comment="        Finds Covalent Modification state in products of all reactions,&#xa;        when gicen state - check with name and modifier not with domain.&#xa;        Used when exchenging default bd domain in contingency.&#xa;" name="find_modification_product">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="BvOdxRcMdorW" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="ekSbbUdSDNuS" type="4ax0gnUhtyJt" value="" name="state"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="k21Gtm7VWY46" comment="        Findes relocalisation reactions.&#xa;        Returns a list of relocalisation states that have given mol name.&#xa;" name="find_relocalisation_product">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="RSd4ESazVbFM" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="2gYD3QfFL1qJ" type="4ax0gnUhtyJt" value="" name="state"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
           </UML:Classifier.feature>
          </UML:Class>
         </UML:Namespace.ownedElement>
        </UML:Package>
       </UML:Namespace.ownedElement>
      </UML:Package>
      <UML:Package visibility="public" isSpecification="false" namespace="Logical View" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="S0uaHtUc4SyQ" name="definitions">
       <UML:Namespace.ownedElement>
        <UML:Class visibility="public" isSpecification="false" namespace="S0uaHtUc4SyQ" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="NDXzAOrelJEV" comment="Class that gathers all reaction definitions parsing." name="ReactionDefinitions">
         <UML:GeneralizableElement.generalization>
          <UML:Generalization xmi.idref="k8tcenNQxX6X"/>
         </UML:GeneralizableElement.generalization>
         <UML:Classifier.feature>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="6Gf3nlb7Tk1c" name="__init__">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="4ogg7bxDrcGc" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="4K4bBVGOnaML" type="4ax0gnUhtyJt" value="" name="xls_tables"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="LpjoYiOc3SCC" comment="returns row from reaction_definition table." name="get_reaction_definitions_dict">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="xSaj0u44giln" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Jgy8IDid2RPa" comment="        Parsing possible localizations from reactions definitions from xls.&#xa;        Result is a dict {'Endosome':'Endosome', ...}&#xa;" name="get_localization_modifications">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="AoBBGNNCpvvo" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="pxqWgbHxHE6X" comment="returns a dictionary of reaction definitions -> directionality raise serious caseselse:TODO: reaction definition has no proper ID. What to do? Raise or fold?print 'WARNING: Reaction definition has no proper ID: %s'%str(row)" name="directionality_dict">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="Ro8TEY2MMDXa" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="YumLnf9ady6J" comment="Given p+ returns 'Covalent Modification'" name="get_reaction_category">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="zSfLdCtB4gXr" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="ZMGpaKK17TSJ" type="4ax0gnUhtyJt" value="" name="rtype"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="LeRwcWFAqUxQ" comment="        Given reaction type returns subclass.&#xa;        e.g. for p+ returns 'Covalent_trans_positive'&#xa;" name="get_reaction_subclass">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="1u13YWurAKol" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="mFPtipCfGp0r" type="4ax0gnUhtyJt" value="" name="rtype"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="o1teVo2G3P7k" comment="        Returns dict with four categories as keys &#xa;        and all reactions list as value.&#xa;" name="categories_dict">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="CKPQ7QI9IJCo" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
         </UML:Classifier.feature>
        </UML:Class>
       </UML:Namespace.ownedElement>
      </UML:Package>
      <UML:Package visibility="public" isSpecification="false" namespace="Logical View" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="DVAy06QCwPNb" name="molecule">
       <UML:Namespace.ownedElement>
        <UML:Package visibility="public" isSpecification="false" namespace="DVAy06QCwPNb" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="6s9h3TBVT34k" name="domain_factory">
         <UML:Namespace.ownedElement>
          <UML:Class visibility="public" isSpecification="false" namespace="6s9h3TBVT34k" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="savREAGHryH0" name="DomainFactory">
           <UML:Classifier.feature>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="21oRCtfukVsh" name="__init__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="7eQmwXWm7RDL" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="ZTaQPpQQqDr0" name="get_localisation_domain">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="6WuoznV6PusL" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="RM5YnIrKjSk8" comment="dsr = 'bd0'+row['Component%s[Name]'%('A' if ab=='B' else 'B')]" name="get_dsr">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="pRFYrye87DCP" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="H9Y6KN6QtzFs" type="4ax0gnUhtyJt" value="" name="row"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="kiw9cnU39ZZv" type="4ax0gnUhtyJt" value="" name="ab"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="aJpSI2I2jFBL" comment="        Produces domain string for associations.&#xa;        It gets state string as an input.&#xa;        Domain can be provided by the user. &#xa;        If not default domain is a name of the partner.&#xa;        'A' or 'B' indicates wheter function should return domain for &#xa;        left or for right partner.&#xa;        e.g. &#xa;        Fu--Bla, 'A' --> 'Bla'  &#xa;        Fu_[x]--Bla_[y], 'B' --> 'y'&#xa;        Used e.g. in contingencies parsing.&#xa; domain provided by the user. default domain: name of the partner.  domain provided by the user. default domain: name of the partner. " name="get_association_domain_from_str">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="Yb4HoDaoqxwy" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="0dN9Aw2zLIVC" type="4ax0gnUhtyJt" value="" name="state_str"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="G9JLKVktoXL4" type="4ax0gnUhtyJt" value="" name="side"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="uyvFEQSSalnu" comment="        Returns name of domain for association.&#xa;        row - row from xls_tables.&#xa;        side - A or B indicating left or right side of association.&#xa;        A: get domain name for left reactant &#xa;        (by defult name of partner - right reactant)&#xa;" name="get_association_domain_from_dict">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="Utq4ecxt7iu6" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="GVn3165ZgAoU" type="4ax0gnUhtyJt" value="" name="row"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="NOJCMDAEB4TO" type="4ax0gnUhtyJt" value="" name="side"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="nzfT7RxVoEfA" comment="        Returns name of domain for association.&#xa;        row - row from xls_tables.&#xa;        side - A or B indicating left or right side of association.&#xa;        A: get domain name for left reactant &#xa;        (by defult name of partner - right reactant)&#xa;" name="get_intraprotein_domain_from_dict">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="gBeSOJcn7yMw" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="RnMbrpzMjnOL" type="4ax0gnUhtyJt" value="" name="row"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="PJCV06bn6FEB" type="4ax0gnUhtyJt" value="" name="side"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="mJGT7foWw11w" comment="&#xa;        It is used in ...&#xa;" name="get_modification_domain_from_str">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="JXEOUbKGuZj1" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="7bhBqvNU51xT" type="4ax0gnUhtyJt" value="" name="state_str"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="CVW8WV3c6klu" name="get_modification_domain_from_dict">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="ZHDQgymf2NXe" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="g6Pl6MCPtQlN" type="4ax0gnUhtyJt" value="" name="row"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="z3bucItooNxI" type="4ax0gnUhtyJt" value="" name="reaction"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="ryuvigqOkF7q" type="4ax0gnUhtyJt" value="" name="component"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
           </UML:Classifier.feature>
          </UML:Class>
         </UML:Namespace.ownedElement>
        </UML:Package>
        <UML:Class visibility="public" isSpecification="false" namespace="DVAy06QCwPNb" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="5UB3DpAmKja3" comment="    Keeps data about a single molecule and its state.&#xa;    Molecule objects can be added.&#xa;    States can be added and removed to Molecule (e.g. add_bond, ...).&#xa;    Information about states, contingencies and domains can be obtained.&#xa;" name="Molecule">
         <UML:Classifier.feature>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="m9V9cSwTJB2D" comment="        Molecule holds information about:&#xa;        - name&#xa;        - bound molecules&#xa;        - empty binding sites  &#xa;        - modifications&#xa;        - empty modification sites&#xa;        - localisation&#xa; empty indictes that molecule take part in a reaction." name="__init__">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="GrFbapcKx5TZ" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="xyhwcpIfITgT" type="4ax0gnUhtyJt" value="" name="name"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="VN0pZ20W0iTa" name="__repr__">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="VjFlAvERmS0K" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="FadCf4jASjxz" name="__eq__">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="U7DEZDXpl81Q" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="lyVlewL9dYvo" type="4ax0gnUhtyJt" value="" name="other"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="ClYcSWbES5x6" comment="        Hash is molecule name and _id).&#xa;" name="__hash__">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="1HDfn6RHEeUn" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="pzaa7ayJJUwl" comment="        molA + molB means that molA will have additional:&#xa;        - modifications&#xa;        - modification_sites&#xa;        - binding_partners&#xa;        - binding_sites&#xa;        - info about alternative localisations&#xa;        comming from molB.&#xa;        Mol B won't change.&#xa;KR: when overloading the '+' operator with __add__    I expect the method to return something.    If it doesnt this is confusing.    Probably it would be better to rename the method    to any of merge(), join(), combine()         TODO: change this method into:&#xa;        new = self.clone()&#xa;        for mod in other.modifications:&#xa;            if mod not in new.modifications:&#xa;                new.modifications.append(mod)&#xa;        for site in other.modification_sites:&#xa;            if site not in new.modification_sites:&#xa;                new.modification_sites.append(site)&#xa;        for partner in other.binding_partners:&#xa;            if partner not in new.binding_partners:&#xa;                new.binding_partners.append(partner)&#xa;        for site in other.binding_sites:&#xa;            if site not in new.binding_sites:&#xa;                new.binding_sites.append(site)&#xa;        if new.localisation != other.localisation:&#xa;            new.alternative_localisations.append(other.localisation)&#xa;        return new&#xa;" name="__add__">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="meD0Gfm3eKbl" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="yVxQatUaAiDv" type="4ax0gnUhtyJt" value="" name="other"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="uZ2D3wz2SuQ2" comment="        Prints long summary about the molecule&#xa;## MOLECULE: %s (%s, %s)&quot; % (self.name, self._id, self.mid) print &quot;Localisation:       %s&quot; % str(self.localisation) " name="inspect">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="nvavbnrNR2Mf" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="h6iJQJ4Lq4Ws" comment="        Clones itself.&#xa;        E.g. returns another instance of itself&#xa;        which can be modified without modifing the origin.&#xa;KR: this copying means we're in performance hell.    As long as the MAPK runs OK --> no problem.        long-term question:        When MK wrote in the grant that his approach avoids       performance isssues of other methods,       does it really?" name="clone">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="1VsROIRBB27k" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="pw8FySufWbww" comment="        Returns all states asociated with this molecule&#xa;        based on associations, modifications and localisation&#xa;.get_state(self.name))).get_state(self.name)))" name="get_contingencies">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="uyFj2mb3FTUd" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="lunvwuflql0m" comment="        Returns molecule as Component instance.&#xa;        There is just information about name and no domains.&#xa;        @rtype: Component&#xa;" name="get_component">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="BvPhWLeOJr7L" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="diNr9pStjFof" name="has_state">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="Ri9iZG2BxP06" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="7TPvDPhOI66m" type="4ax0gnUhtyJt" value="" name="state"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="CSzuilXnDwjQ" comment=" TODO: exchange all the small functions with StateApplicator. " name="has_bond">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="mdHh2HmCjj4P" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="MQocVsPuaYd8" type="4ax0gnUhtyJt" value="" name="state"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="VcDiYw6sKsVp" comment="        TODO: collaps all has functions to one.&#xa;        #KR: why? I like it.&#xa;" name="has_binding_site">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="xc8hJD6opHUL" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="lsiJOLP8ygqy" type="4ax0gnUhtyJt" value="" name="state"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="DaEWRhJAX1Tv" comment="        TODO: find a comon interface and colaps all &#xa;              add/remove functions to add_state&#xa;KR: can one molecule have the same state twice?" name="add_bond">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="WEXJW0ehYqDz" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="Kt1GXrCVRLAl" type="4ax0gnUhtyJt" value="" name="state"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="VX92YdvrUx71" comment="        Goes through molecule.binding_sites and&#xa;        returns {'a': A_[a]--B_[b], ...}&#xa;" name="get_empty_binding_domains_states_dict">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="S241tI0MnANJ" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="mKUCdex7tSQP" type="4ax0gnUhtyJt" value="" name="side"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="lGADDICyahAB" comment="        Returns a list of domains.&#xa;        mode and occupied indicate which domains are we looking for:&#xa;        binding or covalent or binding, occupied or free.&#xa;        Side indicates which domain to pick in case of homodimers.&#xa; decide for which type of domains to search: looking for domains in proper list" name="get_domains">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="AuNsWMSQIQ7N" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="J5ICXiZykezb" type="4ax0gnUhtyJt" value="" name="mode"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="uxyh5J0oZBzl" type="4ax0gnUhtyJt" value="" name="occupied"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="RCj1rrCAwSLR" type="4ax0gnUhtyJt" value="" name="side"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="j6CIHB1gLkfC" comment="        Returns a list of all domains&#xa;        (both binding and modification and&#xa;        both empty and occupied).&#xa;        side - indicaes which domain to pick when &#xa;               there is an association which is a homodimer.&#xa;        Localisation is not included.&#xa;" name="get_all_domains">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="djTv7ZGofS5u" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="ZpLTHgvPYIH5" type="4ax0gnUhtyJt" value="" name="side"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="c6YvpD8O2RsH" name="domain_is_present">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="zqwzHoGMZwza" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="7ngd3xgefAXm" type="4ax0gnUhtyJt" value="" name="domain"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="joZMEeEoimkX" type="4ax0gnUhtyJt" value="" name="side"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="rgFWokHXYqrl" comment="        set the domain by considering the state type&#xa;" name="set_site">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="Xef5SWqubO2Q" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="S5ZArJiq9epO" type="4ax0gnUhtyJt" value="" name="state"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="S5kzziZqMmNA" type="4ax0gnUhtyJt" value="" name="side"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="hkEpM3Bm6ul5" comment="        side indicates in case of homodimers which &#xa;        component (domain) should be taken into account.&#xa; we cannot have two identical binding sites, domain names need to be different.if hash(state) not in [hash(st) for st in self.binding_sites]:and state_comp.domain not in self.get_empty_binding_domains():" name="add_binding_site">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="TW4XQoa07TwC" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="cLvw7G6esliI" type="4ax0gnUhtyJt" value="" name="state"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="FWAouDEavSNI" type="4ax0gnUhtyJt" value="" name="side"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="k0rajXty13mu" name="remove_bond">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="uXNvZ8pn6HvT" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="EyUAOpQpLSMm" type="4ax0gnUhtyJt" value="" name="state"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="GukNOha6hPgR" type="4ax0gnUhtyJt" value="" name="empty_domain"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="4LIQofA2XuOv" name="remove_binding_site">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="ZwzFLeeDB16k" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="9wWEBRhGnxeZ" comment="        Adds modification state to molecule.modifictions.&#xa;        If this modification in present in molecule.modification_sites&#xa;        then checks whether domain is the same and if yes, removes &#xa;        state from molecule.modification_sites.&#xa; Possible we have bug there" name="add_modification">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="h5Pq4WZCS5Qb" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="cmb8ez3Ev3RE" type="4ax0gnUhtyJt" value="" name="mod"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="U5pF2TodFOlu" name="remove_modification_site">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="PqoptEONHEbK" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="Lm6FnVTUatJc" type="4ax0gnUhtyJt" value="" name="mod"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="hNxvlin5SrKG" comment="if mod not in self.modification_sites:" name="add_modification_site">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="VB6nPh7444xo" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="Mliuc1UzrJmk" type="4ax0gnUhtyJt" value="" name="mod"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="kitAXBQrw9lZ" name="remove_modification">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="TwtWypIgVBr3" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="8EW0XJi2Smpr" type="4ax0gnUhtyJt" value="" name="mod"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="KHuGOenXsIVP" comment="        Adds given contingency to the molecule.&#xa;" name="add_contingency">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="WDm2Mb5grxvD" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="bDP3yFsR9jv6" type="4ax0gnUhtyJt" value="" name="cont"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
         </UML:Classifier.feature>
        </UML:Class>
        <UML:Class visibility="public" isSpecification="false" namespace="DVAy06QCwPNb" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="gPRSmOkbKfX2" comment="    MoleculePool object is a list of all reactants.&#xa;    During reactions parsing left and right reactant &#xa;    are added to molecule_pool. &#xa;    Containes Molecule instances. &#xa;" name="MoleculePool">
         <UML:GeneralizableElement.generalization>
          <UML:Generalization xmi.idref="JNP3aWs7m5XS"/>
         </UML:GeneralizableElement.generalization>
         <UML:Classifier.feature>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="jLtVQQxSi1WN" name="__init__">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="eFicMTOqyif9" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="bVapk3bUOSxp" comment="        Returns a dictionery of all molecules present in the system.&#xa;        Molecules have all possible domains and alternative localisations recorded.&#xa;        Molecule that appears in two independent reactions as independent instance&#xa;        will be represented as one molecule with domains from both reactions.&#xa;        molecule_name: MoleculeInstance&#xa;" name="get_system_molecules">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="ttHbumyW1e8L" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
         </UML:Classifier.feature>
        </UML:Class>
        <UML:Package visibility="public" isSpecification="false" namespace="DVAy06QCwPNb" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="ck9Iye8tcbiS" name="state">
         <UML:Namespace.ownedElement>
          <UML:Class visibility="public" isSpecification="false" namespace="ck9Iye8tcbiS" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="bgkRyFqXREYP" comment="    State object keeps information about state of 0, 1 or 2 components.&#xa;    E.g. &#xa;    - two components might interact &#xa;    - one component might be covalently modified&#xa;    - it can be also input or name of a boolean&#xa;    Types of states: &#xa;    - Null&#xa;    - Boolean&#xa;    - Association&#xa;    - Intraprotein  # intraprotein association  &#xa;    - Covalent Modification&#xa;    - Relocalisation&#xa;    - Input&#xa;    - Polymer&#xa;    - Component&#xa;" name="State">
           <UML:Classifier.feature>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="TQoa8kgevRgG" comment=": string that keeps information about state type: valid only for association: valid only for covalent modification e.g. Ub, P and Relocalisation.: valid only for covalent modification (always U) and Relocalisation (substrate localisation). only for localisation, distinguishes between products and substrates. only for asocciation, when A--A" name="__init__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="0jurhn5GUniQ" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="3WwSkUrBvdm1" name="components">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="LSfFtKVs1Pjg" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="BmxfYd3Z9z1u" name="components">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="JX1Luj15Twi1" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="Uq5NTrOnI129" type="4ax0gnUhtyJt" value="" name="components"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="ZkajjZbBNeWp" name="state_str">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="UscmuetD9vW3" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="cW75Sp52ZdjH" name="state_str">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="d4tmxPoZvveM" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="DISawxPQpzAh" type="4ax0gnUhtyJt" value="" name="state_str"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="kjMIN5ZYLz6H" name="type">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="wUgkTqR5uKrp" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="kdOdY3zHkLZ5" name="type">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="V9kOUaDCBcpk" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="O6dj3k10Cfkf" type="4ax0gnUhtyJt" value="" name="type"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="dpzN8WTXa4Ed" name="sid">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="oFbyuJeOTMkx" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="ux94XwoAjlWs" name="sid">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="NQ5qlpndluhI" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="HzNr3bUqp6oh" type="4ax0gnUhtyJt" value="" name="sid"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="rTRaExQTunIv" name="modifier">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="NllCpYtCwx3f" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="koJVjymYSD6e" name="modifier">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="Dj97gAnQy4uf" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="8X62IOxf7hrw" type="4ax0gnUhtyJt" value="" name="modifier"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="0eBQrI5xn9x5" name="not_modifier">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="VujdZaZmHgsx" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="ofMnhEQhsc8h" name="not_modifier">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="0ynHefDTIXEx" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="sBefKbinTRQ3" type="4ax0gnUhtyJt" value="" name="not_modifier"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="lcdbClI2uufC" name="loc">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="TOzunOxnMj30" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="MGRdldaWEB7Q" name="loc">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="KY3gF4ebI6C3" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="uNToF8yiUwcI" type="4ax0gnUhtyJt" value="" name="loc"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="hlXvwcKrzldE" name="homodimer">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="tcuMYXcs3dWI" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="iAr0E44wnZpj" name="homodimer">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="li8oLc61mw21" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="C9YBuAOmkG6I" type="4ax0gnUhtyJt" value="" name="homodimer"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="y4vldiSnqzxi" name="__repr__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="9LUtZY9LGF9a" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="rEZbAba6dVpF" comment="        Compares states only in respect to component names.&#xa;        To include domains in comparison use hash function.&#xa;" name="__eq__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="lLD0aKYPY71g" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="EH24EzkLIDEs" type="4ax0gnUhtyJt" value="" name="other"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="hbmK5bZHraJ3" comment="        Enables using states as keys in a dictionary&#xa;        and having sets of states.&#xa;return (str(self) + str(self.sid)).__hash__()" name="__hash__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="Z3PqGdi2xv0V" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="FYvmfuSMTDfW" comment="        Checks wchether stat contains a component.&#xa;        @type component:  Component&#xa;        @param component: component to check.&#xa;        @rtype:  True / False&#xa;" name="has_component">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="fsOclO8yu1ka" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="mEndm6fK84AO" type="4ax0gnUhtyJt" value="" name="component"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="vBuMMZt8mekY" comment="        Returns component when given a name.&#xa;        If state is Assosiation and homodimer&#xa;        returns component based on side:&#xa;        L - left component&#xa;        R - right component&#xa;" name="get_component">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="vywhdgDM36DW" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="lPsrT2D8scld" type="4ax0gnUhtyJt" value="" name="name"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="yratsKRlTL5p" type="4ax0gnUhtyJt" value="" name="side"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="6Ocz0LaxCAo2" comment="        Valid only for association states.&#xa;        Given a component returns second one.&#xa;" name="get_partner">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="KKmNQxrUMRTK" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="VFnwYtkTpg8Q" type="4ax0gnUhtyJt" value="" name="component"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="n4FxE30hIlcp" comment="        Creates new identical instance of State.&#xa;" name="clone">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="cMIS0PqIjdf7" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="YUbsv3Dg5QcJ" comment="        Checks whether 'bd' is a name of any domain in the state.&#xa;" name="has_bd_domain">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="UczkLbZyvqOt" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
           </UML:Classifier.feature>
          </UML:Class>
          <UML:Class visibility="public" isSpecification="false" namespace="ck9Iye8tcbiS" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="FCBwpo3MIcEB" comment="    StateFactory object producess State object based on a string.&#xa;" name="StateFactory">
           <UML:Classifier.feature>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="fPqkqS2I212N" name="__init__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="acJTSfMfsXbf" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="LezbGEkubYeP" comment="        Complete Association or Intraprotein state from str.&#xa;        Returns State object.&#xa; A_[a]--[b] A--B" name="get_dash_dash_state_from_string">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="O1qgfVSyVr5z" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="0eh0dkODKfem" type="4ax0gnUhtyJt" value="" name="state"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="J0R9V0ooemNs" type="4ax0gnUhtyJt" value="" name="state_str"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="08kZePzf1eff" type="4ax0gnUhtyJt" value="" name="state_id"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="rtnTdBKdH4Bv" comment="        Complete Modification or Relocalisation state from str.&#xa;        Returns State object.&#xa; e.g. P, Ub, truncated for Unmodified" name="get_dash_state_from_string">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="hj6rguf58QyD" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="R8YTmC89Bwpo" type="4ax0gnUhtyJt" value="" name="state"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="RGkv5puvhfOK" type="4ax0gnUhtyJt" value="" name="state_str"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="ogw5l7zCDVdz" type="4ax0gnUhtyJt" value="" name="state_id"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Fs6wWTFK9BQu" comment="        Produces State object from given string.&#xa;        When given id (e.g. 1--2) assigns ids to interacting components.&#xa; Empty state Association | Intraprotein Covalent Modification | Relocalisation PolymerisationInput single component" name="get_state_from_string">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="KpnTyBMGYPjQ" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="IN5VsgSYQXP4" type="4ax0gnUhtyJt" value="" name="state_str"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="R29ZQ8kgyraS" type="4ax0gnUhtyJt" value="" name="state_id"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="3AwThJV6Mddm" comment="        Returns state object.&#xa;        Input: row from xls_tables (dict), reaction object, state type (str).&#xa; e.g. P, Ub, truncated for Unmodified this is a special case PT has two states that change in the reaction  here the source_state is returned e.g. P, Ub, truncated for Unmodified" name="get_state_from_reaction">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="inJViFEoXBQC" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="jNQfEz8Wmvyl" type="4ax0gnUhtyJt" value="" name="row"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="6Izefh2irzAW" type="4ax0gnUhtyJt" value="" name="reaction"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="GfccIFNzalfn" type="4ax0gnUhtyJt" value="" name="category"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="sQvhN5DeinGz" comment="        Switch between two functions:&#xa;        - get_state_from_reaction&#xa;        - get_state_from_string&#xa;        depends on arguments.&#xa;" name="get_state">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="xkuSwIfojYU4" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="2bybLdO3QhY6" type="4ax0gnUhtyJt" value="" name="first_arg"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
           </UML:Classifier.feature>
          </UML:Class>
         </UML:Namespace.ownedElement>
        </UML:Package>
       </UML:Namespace.ownedElement>
      </UML:Package>
      <UML:Package visibility="public" isSpecification="false" namespace="Logical View" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="wWKzyIPAlY8l" name="biological_complex">
       <UML:Namespace.ownedElement>
        <UML:Class visibility="public" isSpecification="false" namespace="wWKzyIPAlY8l" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="SB8tuHR4uOfU" comment="KR: please complete docstrings" name="BiologicalComplex">
         <UML:GeneralizableElement.generalization>
          <UML:Generalization xmi.idref="qkyabs70jTTP"/>
         </UML:GeneralizableElement.generalization>
         <UML:Classifier.feature>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="W5aDW2aClIMC" comment=": indicate where complex appears: L, R, LR defines that e.g. complex exists only when Start, Osmostress ... indicates that complex does not change during the reaction" name="__init__">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="mH4PJoydyaqY" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="pWwp8uNczyqV" name="molecules">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="yQfjhzuREyqX" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="kmBiNzGATCxb" name="molecules">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="8sYLoOsXB1FW" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="6LE3H2WFS9y9" type="4ax0gnUhtyJt" value="" name="molecules"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="zUeSec2jxEkE" name="side">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="GHTgOPoVGMq4" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="liZuipOhH27t" name="side">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="g6TwSJyB0Y3i" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="e9cbNLnbaGIy" type="4ax0gnUhtyJt" value="" name="side"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="LRNaSUT6e4gz" name="input_conditions">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="PTZzirxMvPGL" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="iCXgkaO30lbS" name="input_conditions">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="DQg8pwUW8zCr" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="E5Ws9CpWeOVK" type="4ax0gnUhtyJt" value="" name="input_conditions"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="XZsXKUzWXUMg" name="is_positive">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="eCCIYfak5Gqt" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="AIPHHb6nAwKT" name="is_positive">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="OHmSWbLetkt9" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="OIzvmMZQWjh2" type="4ax0gnUhtyJt" value="" name="is_positive"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="LxwUuGvIWsCG" name="is_modifier">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="ElfiVKlrbVJ5" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="6eiyOb7iZ3CR" name="is_modifier">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="zbzZ7JeBvK9K" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="H5hmxt2Affs8" type="4ax0gnUhtyJt" value="" name="is_modifier"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="wE0TFAuVFbHC" name="__repr__">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="VHM8xDEuoBTt" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="U63OQAgKPgne" comment="        Complex length is equal to the number of its molecules.&#xa;        @rtype:  int&#xa;        @return: number of molecules.&#xa;" name="__len__">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="qh73HOFkeaqb" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="n4TZFxRi3U6T" comment="        Prints detailed information about a complex.&#xa;## %s' % self" name="inspect">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="emo1QZgGFnJW" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="AWEo44Np6qPL" comment="Complex A + Complex B&#xa;for helper_required_complexes:&#xa;Input1: positive complex&#xa;input2: root name&#xa;&#xa;1) clone the self object it is called new further on (in helper_required_complexes this is a negative complex)&#xa;2) iter over the molecules of the positive complex (first argument)&#xa;2.1) if the current molecule is not a member of new append the molecule to new&#xa;2.2) else if the root is not definded add the current molecule to new &#xa;2.3) else if a root is defined:&#xa;2.3.1) call get_shortest_path(root, mol)" name="complex_addition">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="ae9gVW2GM13e" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="OZF35uRdCZTl" type="SB8tuHR4uOfU" value="" name="other"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="bcTqNkKXHYJJ" type="4ax0gnUhtyJt" value="" name="root"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="7JYwJWAu8djU" comment="Returns a list of all molecules adjacent to the molecule with the given name (and optionally id)." name="get_partners">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="a2Chfv91xAeX" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="O31dcJwCx3rQ" type="4ax0gnUhtyJt" value="" name="mol_name"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="iB2JUwe4GxYR" type="roUjrN5x9VrV" value="" name="mid"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="RZhPcYpCPU3I" comment="        Returns a list of all possible paths &#xa;        from root to leaf nodes&#xa;        in a tree rooted at the given molecule.&#xa;        (paths represented as lists of molecules)&#xa; one node - the one we came from" name="get_branches">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="DokdIotTN6cy" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="CZDBd5TB7eql" type="4ax0gnUhtyJt" value="" name="mol_name"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="XzmSAPzbyhyY" type="4ax0gnUhtyJt" value="" name="mid"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="A49Hi00Dzng7" comment="        Returns a list of molecules for each &#xa;        subgraph originating from the given molecule.&#xa;KR: is it used?" name="get_top_branches">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="bUjZFNgP0LXJ" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="Cdh8IfgWRP7i" type="4ax0gnUhtyJt" value="" name="mol_name"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="B0BW4lUEpbUV" type="4ax0gnUhtyJt" value="" name="mid"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="1EnQbu8msHIw" comment=" Returns a list of all paths from mol1 to nodes that have the same name as mol2 except if mol1 and mol2 are adjacent, in which case the molecules' mid must match as well. The paths are returned sorted by length (ascending).&#xa;&#xa;1) check if mol1 or mol2 are contained in the molecule list of the self object (called new in complex_addition, in helper_required_complexes it is the negative complex). if none of both are a member None is returned.&#xa;2) a list called result and a list called stack is initialised&#xa;2.1.) the function get_partners is called with the name and mid of mol1&#xa;&#x9;- iter over the list of partners&#xa;&#x9;- check if the current molecule is the same as mol2&#xa;&#x9;&#x9;- if yes append the molecule to the result list&#xa;&#x9;&#x9;- if not append it to the stack list&#xa;2.2.) as long as we have molecules in the stack&#xa;&#x9;- This has to be completed if we have an example for this" name="get_paths">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="K2lCH17IlE94" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="ndO7lI1uGBaC" type="SB8tuHR4uOfU" value="" name="mol1"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="aLLWDmdyNz56" type="SB8tuHR4uOfU" value="" name="mol2"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="pVzqYT9wcqK6" comment="Returns the shortest path between two molecules that comes first alphabetically.&#xa;&#xa;1) call get_pats(mol1, mol2)" name="get_shortest_path">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="T343rN7vNeNn" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="kzUhnC6CmLFr" type="SB8tuHR4uOfU" value="" name="mol1"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="B0CfwACg7hLs" type="SB8tuHR4uOfU" value="" name="mol2"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="7qWX2UFHWEFn" comment="        Creates a new instance of BiologicalComplex identical to itself.&#xa;        @rtype:  BiologicalComplex&#xa;        @return: identical complex&#xa;new.molecules = copy.deepcopy(self.molecules)" name="clone">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="JGquIk0jm5ld" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="QsXlXsWch37j" comment="        Returns a dictionare with bonds prepared &#xa;        based on molecule.binding_partners of each molecule.&#xa;        {state: number}&#xa;        e.g.&#xa;        {A_[B]--B_[A]: 1}&#xa;print selfprint self.inspect() get all molecule-state data: get pairs molecule-state &amp; molecule-state state is the same get bonds numbers" name="get_bonds">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="XL11ZEmqUdkk" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="LlU7oDjE5Gza" comment="        Returns a list of molecules with given: name, mid and _id.&#xa;        - name (obligatory)&#xa;        - mid (not neccessary) - molecule id from contingency&#xa;        - _id (not neccessary) - uniq id of Molecule object.&#xa;" name="get_molecules">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="cYWgmTGtyRgV" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="6VCnYIX3dW3A" type="4ax0gnUhtyJt" value="" name="name"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="kp0FQlxkWPpI" type="4ax0gnUhtyJt" value="" name="mid"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="jDWMjXWSLUfj" comment="        TODO: Perhaps needs further attention.&#xa;        Gets molecules from complex and then filters them with given state.&#xa;        Returns only these molecules that have state &#xa;        (in any of attribute lists - modifications, modification_sites ...)&#xa;" name="get_molecules_on_state_condition">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="QTSlx7UDiywi" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="FcTj0J1cpXIc" type="4ax0gnUhtyJt" value="" name="name"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="yXTxy7QfLuz2" type="4ax0gnUhtyJt" value="" name="state"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="FwI4TZeQ45N0" comment="        Checks whether molecule with given name and mid (not obligatory)&#xa;        is present in complex.molecules.&#xa;        Returns False or True&#xa;" name="has_molecule">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="G7xKCIKN1ztf" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="DlfWdeY37zm4" type="4ax0gnUhtyJt" value="" name="name"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="4HFkDAQQ6jSX" type="4ax0gnUhtyJt" value="" name="mid"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="bQggPTkTiyEv" comment=" artefact? if ctype ANDNOT/ORNOT add_binding_site if we have several mols bound to one side and use a NOT we keep this empty A(C,D), C(A), D(A), B(....) drop C and D later check if site is occupied by other then ignore NOTs last always (if site is empty and later will be occupied then use the occupation) state: A--Bmol1 Amol B todo: if not s1 to site x but s2 can bind to x occupy x by s2 todo: check if site is occupied by other then ignore todo: split comp so that both criteria are fulfilled is an OR statement[A,B]KR: append to mol1.binding_partners here    or add method create_molecule(component)KR: this if could be delegated to Molecule" name="add_state">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="zDO1AIejiKP7" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="8eJELllbqht1" type="4ax0gnUhtyJt" value="" name="state"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="n8YT6kMENfSi" comment=" AND and OR are defined by the bracket we don't have to consider this here again just check if we have notand or notor todo: if multiple mol of the same name apply mod to all of them per default todo: A 1--2 A positional information for mod todo: say which subunit should be mod otherwise mod other wise grab just one     print &quot;mol1: &quot;, mol1mol1.add_modification(state.state) todo: make only same residues mutually exclusive todo: if the residue is different apply modification on it todo: not is only applied on residues which are not mentioned as used todo: check if this is needed or notor? if the state is not known and the ctype is andcheck if the state was set as modification site before fixme: this is a conflict raise this if yes remove this site and add the modification if not just add the modification if the state is not known as modification and the ctype is notand set the modification site" name="add_state_mod">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="3N4O2U6TeMjU" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="RBIHq9IqLhpV" type="4ax0gnUhtyJt" value="" name="complexes"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="zTFfnckZkI0q" type="4ax0gnUhtyJt" value="" name="state"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="WzIpg7KdaXGM" comment="        Colects all contingencies that are fulfilled in the complex.&#xa;        @rtypr:  list&#xa;        @return: contingencies neccesarry to build the complex.&#xa;" name="get_contingencies">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="A0tuJtlKGniH" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Imku7RObRhQ5" comment="        Remove molecule from comoplex.&#xa; TODO: what if afterwords we have two complexes?       Check whether all mols are connected and       we have 2 complexes then return them?" name="remove_molecule">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="P1ZgpFv51fz8" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="mihLGxfOyYIH" type="4ax0gnUhtyJt" value="" name="mol"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
         </UML:Classifier.feature>
        </UML:Class>
        <UML:Class visibility="public" isSpecification="false" namespace="wWKzyIPAlY8l" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="5LhW07ZnqG86" comment="    Object AlternativeComplexes keeps all complexes with the same identificator.&#xa;    E.g. obtained from the same boolean or complex contingency.&#xa;" name="AlternativeComplexes">
         <UML:GeneralizableElement.generalization>
          <UML:Generalization xmi.idref="FHeEvbLyw2Ux"/>
          <UML:Generalization xmi.idref="ir1dsTY0VGyn"/>
         </UML:GeneralizableElement.generalization>
         <UML:Classifier.feature>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="V7f0LblNb2y5" comment=": contingency type" name="__init__">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="XLhKPHxuOati" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="zPj1POAHVbIl" type="4ax0gnUhtyJt" value="" name="name"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Bc5kd4naTWcq" name="name">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="tm8OMO9rjqB8" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="561UesCpUFZ7" name="name">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="6EFn5OwASvc6" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="JKilqIbj2h7O" type="4ax0gnUhtyJt" value="" name="name"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="nmtF0QNJk32b" name="ctype">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="LcINJQkNexBh" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="K5qmyQrlDk0D" name="ctype">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="BlknivT2yJnw" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="9LUtOVSh7l3O" type="4ax0gnUhtyJt" value="" name="ctype"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="jefuOf5XzaPN" name="input_condition">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="3r3Ac6WlrGXX" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="B0Y7JL30zivL" name="input_condition">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="nGTcWy8gygnF" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="M0tLYIgb7jji" type="4ax0gnUhtyJt" value="" name="input_condition"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="1pG0XBLt9CEi" name="add_complex">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="g6RemDsn28nZ" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="StJac1IOHjyl" type="4ax0gnUhtyJt" value="" name="comp"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="H7RQJd6mWOK7" comment="        Returns  first complex that is not empty&#xa;        (contains molecules).&#xa;" name="get_first_non_empty">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="PaVgHTRxaraK" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="4S86atdp04FI" comment="        Removes all complexes from the AlternativeComplexes object&#xa;" name="empty">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="gM2CkMJ9wmnB" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="EC9m3j679EBh" comment="        Clones complexes inside so they become new objects&#xa;" name="clone">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="6pW6rjMX5Oin" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
         </UML:Classifier.feature>
        </UML:Class>
        <UML:Class visibility="public" isSpecification="false" namespace="wWKzyIPAlY8l" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="k1uemhq0sxmv" name="ComplexPool">
         <UML:ModelElement.templateParameter>
          <UML:TemplateParameter visibility="public" isSpecification="false" namespace="k1uemhq0sxmv" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Oxl1I54j4Dip" type="dLTWHlOKSlBa" name="ComplexPool"/>
         </UML:ModelElement.templateParameter>
         <UML:GeneralizableElement.generalization>
          <UML:Generalization xmi.idref="es1l5CSBzyFr"/>
         </UML:GeneralizableElement.generalization>
        </UML:Class>
        <UML:Package visibility="public" isSpecification="false" namespace="wWKzyIPAlY8l" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="cWwYvJ809FfC" name="complex_applicator">
         <UML:Namespace.ownedElement>
          <UML:Class visibility="public" isSpecification="false" namespace="cWwYvJ809FfC" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="5vg3rwsXWEIW" comment="    Interface between AlternativeComplex objects and ReactionContainer object.&#xa;" name="ComplexApplicator">
           <UML:Classifier.feature>
            <UML:Attribute visibility="private" isSpecification="false" xmi.id="cOiaCiyAnwSD" type="qBvSsMQXzZTC" name="builder "/>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="HoDLDZBIizEp" comment="1) assign reaction_container to reactions_container&#xa;2) create builder object from biological_complex.complex_builder.ComplexBuilder&#xa;3) check if complexes are empty. if yes no boolean contingecies are applied to the reaction. if not apply  prepare_complexes_to_apply(complexes[1]) where complex[1] are the alternative complexes generated in biological_complex.complex_builder.ComplexBuilder.build_positive_complexes_from_boolean in the rxncon.py  create_complexes part" name="__init__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="utpdq1QP8vR5" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="qlXzCSIhF7Rr" type="mHcr9bv39eOH" value="" name="reaction_container"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="lJFb6EruzMrA" type="5hPq9PUPSyWX" value="" name="complexes"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="uw6n9AXH4osD" comment="Gets single AlternativeComplexes object &#xa;Input: all positive complexes.&#xa;Output: all required complexes (combinations of positive and negative complexes).&#xa;Complexes can contain a complex with no molecules and just an input state.&#xa; &#xa;1) remove complexes containing no molecules&#xa;2) get possible roots&#xa;3) for each root &#xa;&#x9;- create a new AlternativeComplex with alter_complex.name&#xa;&#x9;- assign ctype and input conditions of alter_complex to the new AlternativeComplex&#xa;3.1) iter over alter_complex&#xa;&#x9;- check if the root is a member of the complex&#xa;&#x9;- if yes add it to alter_complex_of_root&#xa;&#x9;- if we found complexes containing the current root call builder.build_required_complexes(alter_complex_of_root, root) to build the required complexes" name="_prepare_alter_complex">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="XaTpTweT0JZp" type="5LhW07ZnqG86" value="" name="alter_complex"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="OLAT90gU1I9N" comment="@type input_complexes:  list of AlternativeComplexes&#xa;@param input_complexes: one or two AlternativeComplexes objects as a list. Alternative Complexes object keeps all complexes from one boolean contingency. &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Maximal two boolean contingency can be applied on a reaction.  WHY??? one can define arbitrary number of boolean contingencies to a reaction>>>>>>>>>>>>&#xa;&#xa;1) check if input_complex is of class AlternativeComplexes. &#xa;- if yes call _prepare_alter_complex(input_complexes)&#xa;- if no iterate over input_complexes and check each entry&#xa;&#x9;- if it belongs to AlternativeComplexes. clone the complex&#xa;&#x9;- if it is a list iter over the list and clone each element. generate a new list called alter_complex&#xa;&#x9;- call _prepare_alter_complex(alter_complex)&#xa;&#xa;" name="prepare_complexes_to_apply">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="14g6psbyz25I" type="5LhW07ZnqG86" value="" comment="is an object of AlternativeComplexes containing a list of complexes generated in build_positive_complexes_from_boolean (biological_complex.biological_complex.AlternativeComplexes)" name="input_complexes"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="qKhraoEC6nyP" comment="        BiologicalComplex.is_positive can have three values:&#xa;        - True&#xa;        - False&#xa;        - 'both' (when k+/k- input condition)&#xa;        Returns False when either only &#xa;        positive complexes are present or only negative.&#xa;        Returns True when positive and negative complexes &#xa;        are present or complexes that are both positive and negative at the time (K).&#xa;        It also returns True when reaction is reversible &#xa;        and complex contains input condition.&#xa;        (then we need two rates anyway for reversible reaction).&#xa;for reaction, compl in zip(self.reaction_container, self.complexes):" name="both_complex_types_present">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="TXVYL7kBPP20" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="Glgxy1o1YjqK" type="4ax0gnUhtyJt" value="" name="com"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="DEAK16hGpMBn" comment="        When there are alternative complexes to apply &#xa;        new reactions will be created (copies of basic one) &#xa;        and added to a ReactionContainer. In some cases they will &#xa;        all have the same rate, in some cases it needs to be changed.&#xa;        This function updates reaction rate.&#xa;        Rate has single digit when only positive &#xa;        or negative complexes are present.&#xa;        When both:&#xa;        - X_1 for positive &#xa;        - X_2 for negative&#xa;        Additionally it updates rates with functions &#xa;        if input conditions are present in complex.&#xa;        Arguments:&#xa;        - reaction (has already basic rate)&#xa;        - compl (may have input condition)&#xa;        - both_types if True means that X will be exchanged with X_1 or X_2.&#xa;" name="update_reaction_rate">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="Nq1TXfxK2XZo" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="NznvhdE88heT" type="4ax0gnUhtyJt" value="" name="reaction"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="pOcEmeCzqKJs" type="4ax0gnUhtyJt" value="" name="compl"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="Qz6DLH1iEmct" type="4ax0gnUhtyJt" value="" name="both_types"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Cjl245sS2wgN" name="set_basic_substrate_complex">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="yCJykqmuYYuc" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="Df3QRfJoTLHz" type="4ax0gnUhtyJt" value="" name="reaction"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="bl4dhiytN1Jm" name="set_reaction_id">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="Ddcl9XLkGQLx" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="fca8vq5u0Psk" type="4ax0gnUhtyJt" value="" name="reaction"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="6JqUK7Gzip6d" comment="if ele.ctype == &quot;or&quot;:" name="change_non_complex_molecule">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="TpqjDBfJUTnm" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="d9VdWMMkzyT8" type="4ax0gnUhtyJt" value="" name="reactant"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Z2kHpouSxO3U" name="get_or_conditions_of_other_reactant">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="WK1Sg5uQS67o" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="kPChMfnnUdVh" type="4ax0gnUhtyJt" value="" name="reaction"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="mAzEbm0AmiRZ" type="4ax0gnUhtyJt" value="" name="comp"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="juaCV5rHDqTo" comment="        applies the complexes as well as the alternative complexes&#xa;self.complexes = [[self.complexes[0][0],self.complexes[0][2]]]print &quot;self.complexes: &quot;, self.complexes" name="apply_complexes">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="bRxNAMxeew6K" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="zykS2pEmhowC" comment=" [A]  [A,B]" name="get_root_molecules">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="8V8lQD5PBopC" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="rnR4esrFKmaU" type="4ax0gnUhtyJt" value="" name="compl"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="d4yJquTihtkJ" comment="sth with product went wrong" name="add_substrate_complexes">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="0SoiLWz54WAN" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="lZW5L7ZSagD0" type="4ax0gnUhtyJt" value="" name="reaction"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="rGQ04FCgH8z8" type="4ax0gnUhtyJt" value="" name="complexes"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="dipBM0CDFcBJ" comment="        Creates BiologicalComplex with single Molecule inside.&#xa;        Adds this complex to reaction.substrat_complexes.&#xa;        Input:&#xa;        - mol:      Molecule object&#xa;        - reaction: Reaction object&#xa;        - side:     L, R, LR indicates on which side of reaction should be the complex.&#xa;" name="molecule2complex">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="5KgSHr9lzuGe" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="pOx7UwDVNzBg" type="4ax0gnUhtyJt" value="" name="mol"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="TAlXgwvHeiTy" type="4ax0gnUhtyJt" value="" name="reaction"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="hf9wFKD2gB7B" type="4ax0gnUhtyJt" value="" name="side"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
           </UML:Classifier.feature>
          </UML:Class>
         </UML:Namespace.ownedElement>
        </UML:Package>
        <UML:Package visibility="public" isSpecification="false" namespace="wWKzyIPAlY8l" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="iqiArkunGFkF" name="complex_builder">
         <UML:Namespace.ownedElement>
          <UML:Class visibility="public" isSpecification="false" namespace="iqiArkunGFkF" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="qBvSsMQXzZTC" comment="    Colection of algorithms creating groups of complexes.&#xa;    (BiologicalComplex objects keept by AlternativeComplexes).&#xa;" name="ComplexBuilder">
           <UML:Classifier.feature>
            <UML:Attribute visibility="private" isSpecification="false" xmi.id="qgLEi8cz8HRj" type="5hPq9PUPSyWX" name="states"/>
            <UML:Attribute visibility="private" isSpecification="false" xmi.id="kDbDadVjh1DC" type="5hPq9PUPSyWX" name="final_states"/>
            <UML:Attribute visibility="private" isSpecification="false" xmi.id="iS7aRKz307Ig" type="5LhW07ZnqG86" initialValue="str(bool_cont.state)" name="required_complexes"/>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="seFYnMhtfNLw" name="__init__"/>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="42S1atEQYTyL" comment="Gets all positive and negative complexes as a list of tuples:&#xa;        [(PositiveComplex: (NegativeComplex, NegativeComplex, ...)), ...)]&#xa;        Goes through Positive : (neg1, neg2, neg3 ...) pairs.&#xa;        1 iteration:&#xa;          required gets positive1&#xa;          negative1 = negative1&#xa;        2 iteration:&#xa;          requires gets positive2 + each negative1&#xa;          (there are so many new positive complexes as there were negative&#xa;          + means that complexes are added and create together one complex) &#xa;          negative change ???&#xa;        3 iteration:&#xa;          requires gets positive3 + each negative2&#xa;          negative change ???&#xa;          ...&#xa;Returns required complexes (AlternativeComplexes object) and list of negative complexes from the last iteration.&#xa;&#xa;1) create an object required_complexes (object of biological_complex.biological_complex.AlternativeComplexes: input '')&#xa;   create a list (negative) for negative complexes&#xa;2) iterate over the list of tuples all_single_complexes&#xa;2.1) if the list negative is empty:&#xa;&#x9;- add the positive complex to required_complexes&#xa;&#x9;- add the list of negative complexes to negative&#xa;2.2) if the list negative is not empty: (this will happen for OR case)&#xa;&#x9;- iter over the negative complexes in negative&#xa;&#x9;- merge root and positive complex with the current negative complex and add this new complex to required complex (required_complexes.add_complex(neg.complex_addition(comp[0], root)))&#xa;&#x9;- build all the combinations between negative and the negative complexes of the current positive complex" name="helper_required_complexes">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="XI8sbYyCYB5V" type="5hPq9PUPSyWX" value="" comment="is a list of tuple containing positive and the respective negative complexes" name="all_single_complexes"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="wAZ2rDxtDQvl" type="4ax0gnUhtyJt" value="" name="root"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="tBxuBJH8Rq8H" comment="        Sets input_conditions parameter &#xa;        for complexes in a ready required complexes&#xa;        (it ia a Contingency).&#xa;        It does it based on main contingency (!, x, K+, K-) &#xa;        and type of boolean (AND, OR).&#xa; single negative complex single positive complex single negative complex      single positive complexrequired_complexes[0].input_condition = Contingency(None, '!', input_cont.state)  # single positive complex k+/k- (which means ! and x)  single negative complex single positive complex" name="apply_input_contingency">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="6ZmBOaRUgm2b" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="13AFR50jECYm" type="4ax0gnUhtyJt" value="" name="bool_ctype"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="hjrxhQOPZlSi" type="5hPq9PUPSyWX" value="" name="input_cont"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="u9dFwk2dUuY9" type="5LhW07ZnqG86" value="" name="required_complexes"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="gBeLv35qCi38" type="5hPq9PUPSyWX" value="" comment="it is a list of required complexes and an additional interal list of negative complexes&#xa;[required_complexes,[negative complexes]]" name="result"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="GrXkpiisrM7B" comment="Builds all required complexes for one boolean contingeny.&#xa;@type root:  Molecule object&#xa;@param root: a molecule from a reaction for which complex will be applied.&#xa;&#xa;1) iterate over positive complexes call build_negative_complexes(comp, root) to build the negative complexes of each positive complex. Append the combination to an array as tuple all_single_complexes.append((comp, negative)) where comp is the positive complex and negative is a list of corresponding negative complexes&#xa;2) call a helper function with all_single_complexes and the root name (all_single_complexes, root) &#xa;3) check the ctype of the positive complex&#xa;3.1) if the ctype is !&#xa;&#x9;- set the positive complex as required_complexes&#xa;&#x9;-  if we have input conditions the function apply_input_contingencies is called&#xa;3.2) if the ctype is x&#xa;&#x9;- iter over the results from helper_required_complexes (combination of negative complexes) and add each to the required_complexes&#xa;3.3) if the ctype is k+&#xa;&#x9;- set the positive complex as required_complexes and iter over the results from helper_required_complexes and add each to required_complexes too&#xa;" name="build_required_complexes">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="4RMulU5Jdphv" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="z9P0rNdCAfal" type="5LhW07ZnqG86" value="" name="positive_complexes"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="feERUrmfEGVP" type="4ax0gnUhtyJt" value="" comment="is one of the reactants involved in the reaction" name="root"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="HwIIyrfYpVoZ" comment="        This function generates biological complexes from a flatten list of booleans (self.final_states)&#xa;        @param alter_comp: AlternativeComplex obj&#xa;        @return complexes: list of BiologicalComplex obj&#xa;        @type complexes: list&#xa;        @return alter_comp: AlternativeComplex obj&#xa; if state appears more than 1 warning if contra sign kill complex and make stronger warning  negative input multiple inputs TODO: loc ... A--B todo: make a clear error if the reaction is not defined each self.stack results in one comp[A, D, C, B]" name="create_basic_complexes_from_boolean">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="P2i1pNw7JCPF" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="NeX40GZ3fvxR" type="4ax0gnUhtyJt" value="" name="alter_comp"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="33nqYaNvCvxC" comment=" Builds positive complexes from boolean (containing children) contingency &lt;cont>. It can be normal boolean or defined complex (which is in fact AND boolean).&#xa;&#xa;#WARNING: so far boolean can have only interaction and modification states&#xa;&#xa;Returns AlternativeComplexes object.&#xa;Information about Input states is stored in AlternativeComplex.input_condition.&#xa;@param bool_cont:  ContingencyFactory obj&#xa;@return alter_complexes: list of AlternativeComplex obj&#xa;@type alter_complexes: list&#xa;&#xa;1) call get_state_sets input is boolean contingency creates final_states which is a list of list. each element within a list means an AND connection two seperate lists mean an OR connection&#xa;2) create a list alter_complexes: list append final_states to this list. This is just for later check if the complexes are all generated&#xa;3) create an AlternativeComplexes object: alter_comp input bool_cont.state (state name of the respective boolean contingency). assign the ctype (x,!,k+,k-) of the boolean contingency to the alter_comp.ctype&#xa;4) call complexes, alter_comp = self.create_basic_complexes_from_boolean(alter_comp) which creates the basic positive complexes.&#xa;5) sort the complexesby the number of their compoments&#xa;6) enumerate over the sorted complexes and create for each complex a complex id (cid). Add each complex from complexes to alter_comp&#xa;7) Add alter_comp to alter_complexes and return alter_complexes&#xa;" name="build_positive_complexes_from_boolean">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="Hk7axUoyVZp3" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="BY7DbpExmxz2" type="qeeki9z1YCSm" value="" name="bool_cont"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="7CwJ5uUFOj2q" name="check_state_connected_to_stack">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="xCQMtQAlcmok" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="sEe28U2ND7vA" type="4ax0gnUhtyJt" value="" name="state"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="cj87Jv9O85iD" type="4ax0gnUhtyJt" value="" name="state_stack"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Ho7Sw3cWkib1" comment="        This function checks if the state_group consists only of input&#xa;        if one of the elements is not an input False is returned&#xa;" name="check_if_input">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="iCxLyj5FXBfR" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="ckQko8vjKK3B" type="4ax0gnUhtyJt" value="" name="stack"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="CFvwyXwYFMG3" comment=" we do this later        This function checks the connectivity of the different state_groups (the connectivity of the state_group elements is not yet checked)&#xa;        The state_groups are assigned to lists one list for each molecule in the reaction.&#xa;        Example:&#xa;                        A_ppi_B; ! &lt;comp>&#xa;                        &lt;comp>; or A-{P}&#xa;                        &lt;comp>; or B-{P}&#xa;                        &lt;comp>; or &lt;compA>&#xa;                        &lt;compA>; and A--C&#xa;                        &lt;compA>; and A--D&#xa;                        &lt;comp>; or &lt;compB>&#xa;                        &lt;compB>; and B--E&#xa;                        &lt;compB>; and B--F&#xa;        final_states:  [[or A_[bd]-{P}], [or B_[bd]-{P}], [and B_[AssocE]--E_[AssocB], and B_[AssocF]--F_[AssocB]], [and A_[AssocC]--C_[AssocA], and A_[AssocD]--D_[AssocA]]]&#xa;        Step 1: iterate over final_states (containing all state_groups defined)&#xa;        Step 2: if its the first state_groupe generate a list in stacks containing the state_group&#xa;                Round1: stacks = [[[or A_[bd]-{P}]]]&#xa;        Step 3: check next state_group&#xa;                Round2: state_group = [or B_[bd]-{P}] _> [[[or A_[bd]-{P}]],[[or B_[bd]-{P}], ]]&#xa;                Round3: state_group = [and B_[AssocE]--E_[AssocB], and B_[AssocF]--F_[AssocB]]&#xa;                Round4: state_group = [and A_[AssocC]--C_[AssocA], and A_[AssocD]--D_[AssocA]]&#xa;            Step 3.1.: if one of the states in state_group overlaps with one already known in one of the lists of stacks than append&#xa;                       the state_group to the respective list&#xa;                Round3: stacks = [[[or A_[bd]-{P}]],[[or B_[bd]-{P}], [and B_[AssocE]--E_[AssocB], and B_[AssocF]--F_[AssocB]]]]&#xa;                Round4: stacks = [[[or A_[bd]-{P}],[and A_[AssocC]--C_[AssocA], and A_[AssocD]--D_[AssocA]]],[[or B_[bd]-{P}], [and B_[AssocE]--E_[AssocB], and B_[AssocF]--F_[AssocB]]]]&#xa;            Step 3.2.: if not create a new list stacks containing the state_group&#xa;                Round2: stacks = [[[or A_[bd]-{P}]],[[or B_[bd]-{P}]]]&#xa;            proceed with Step 3&#xa;        The result is a list containing two lists.&#xa;        One for A: [[or A_[bd]-{P}],[and A_[AssocC]--C_[AssocA], and A_[AssocD]--D_[AssocA]]]&#xa;        One for B: [[or B_[bd]-{P}], [and B_[AssocE]--E_[AssocB], and B_[AssocF]--F_[AssocB]]]&#xa;        Inputs connected with an OR are saved during the process and added to the respective lists afterwords.&#xa;        A_ppi_B &lt;comp>&#xa;        &lt;comp>; OR &lt;A>&#xa;        &lt;comp>; OR &lt;B>&#xa;        &lt;A>; AND A-{P}&#xa;        &lt;A>; AND &lt;NOTB>&#xa;        &lt;NOTB>; NOT B-{P}&#xa;        &lt;B>; AND B-{P}&#xa;        &lt;B>; AND &lt;NOTA>&#xa;        &lt;NOTA>; NOT A-{P}&#xa;        #&#xa;        final_states = [[AND A-{P}, ANDNOT B-{P}], [AND B-{P}, ANDNOT A-{P}]]&#xa; Step 1 Step 3 part of Step 3: iterate over stacks to get the single lists part of Step 3: iterate over the elements of the single lists Step 3.1 if we have a new state_group we have to check if a list with overlapping Molecules exists if the is an overlap append the state_group to the respective list if not the first element has an overlap than might be that one of the following has one Step 3.2 if there was no overlap in the existing lists we have an other group and append a new list to stacks we have to distinguish between normal states and inputs like [START] if the state_group is not a single input or a collection of and connected inputs we open a new list this is also done if one of the elements in state_group is not an input otherwise we save this state_group separately and apply it later to all the lists Step 2  here we apply the inputs to the respective lists" name="check_state_connection">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="S9lkTovC0qXz" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="ZaC5jsWv7Sq3" comment="Traverses through a contingencies list. Starts with root contingency that keeps all other contingencies. Uses get_states to go one level deeper until there are no more contingencies with children.  At the end the self.final_states list contain lists with states. Each list corresponding to a complex. &#xa;&#xa;1) append boolean contingency as list to states self.states.append([bool_cont])&#xa;2) while there is a boolean in self.states pop the last element of the list (state_list = self.states.pop()) and call get_states self.get_states(state_list)&#xa;&#xa;" name="get_state_sets">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="lBcm29jbiveR" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="xmbC6rEY1zIS" type="4ax0gnUhtyJt" value="" name="bool_cont"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="lBLrbBuWvUiz" comment="Moves contingencies from a given list to either self.states (booleans - children) or to self.final_states (leafs - no children)&#xa;We don't mix bool types hence if one child has a specific bool the other children have the same.&#xa;&#xa;final_states is the flatten version of the boolean contingencies.&#xa;&#xa;to_remove: array; stores boolean which will be processed&#xa;to_add: array; stores contingencies which are connected by AND&#xa;to_clone: array; stores contingencies which are connected by OR&#xa;&#xa;1) iterate over node_list, which is a list of contingencies (can contain boolean and states)&#xa;1.1) check if the current entry of node_list has children, if it has children than it is a boolen otherwise its a normal contingency&#xa;1.2) if boolean:&#xa;- add the boolean to to_remove&#xa;- check the type of boolean therefore we have to check only the type of one of the children because we don't mix boolean statements&#xa;- if the type is an AND or -- we extend the list of children to to_add&#xa;- if the type is an OR we have to check the type of the parent also, because we have to combine the children if the type of the parent is an AND. if the parent is an OR we can just flatten the list &#xa;2) iter over to_remove and remove the respective nodes from node_list (node_list stores contingencies. we only want to have non-boolean in this list at the end so we remove the boolean we have processed in this round)&#xa;3.1) if we added something to to_add&#xa;- append the nodes in to_add to node_list&#xa;- check if some of the nodes are still boolean (children of the current processed boolean can also be boolean). &#xa;&#x9;- if yes add the entire node_list to states. This states will be used in the function get_state_sets() as states&#xa;&#x9;- if no add node_list to final_states&#xa;&#xa;3.2 if we don't add somtehing to to_add we add something to to_clone (OR condition). &#xa;here we also have to considere the context of the respective OR meaning if we have lists in to_clone means that the parent of this children has an AND type and we have to build combinations of the lists &#xa;3.2.1) if we have lists in to_clone. Remove all lists from to_clone and just keep the single ORs. The removed lists are saved in another list object (to_combine) for later combination (we have to generate all possible combinations of the different OR conditions and add the single ORs to each list later)&#xa;&#xa;3.2.2) if we have entries in to_combine build the combinations and add them back to to_clone&#xa;3.2.3) iter over the nodes in to_clone&#xa;- if the current node is a tuple add this to node_list as list and asign it to result (result = node_list + list(node) # [] + [OR A--C] -> [[OR A--C]] # [AND A--D] + [OR A--C] -> [AND A--D, OR A--C])&#xa;- else just add the node as list to node_list and asign it then to result (result = node_list + [node])&#xa;3.2.4. iter over result and check if the nodes are boolean.&#xa;&#x9;- if yes add result to states. This states will be used in the function get_state_sets() as states.&#xa;&#x9;- if no add result to final_states&#xa;&#xa;&#xa;" name="get_states">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="V8aB1EcnNvew" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="1hbmS9cUULSB" type="5hPq9PUPSyWX" value="" name="node_list"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="4WSxyBwI5TYx" comment="@type complex:  BiologicalComplex&#xa;@param complex: complex to negate.&#xa;@type root_molecule:  string&#xa;@param root_molecule: name of reaction component - the molecule that always needs to be there.&#xa;&#xa;1) call get_states_from_complex(compl, root_molecule)&#xa;2) create alter_comp a new AlternativeComplex (biological_complex.biological_complex.AlternativeComplex) with name ''&#xa;3) as long as we have bindings/modifications (empty bindingsites and modifications are not concidered as long as we have a binding/modification)&#xa;&#x9;- for each binding/modification build a BiologicalComplex() (biological_complex.biological_complex.BiologicalComplex) &#xa;&#x9;- set is_positive to False&#xa;&#x9;- iter over the ordered sates (exclude the last element for the first iteration and until counter - rounds for the following) and call add_state on the complex which added the states (except the last or until counter) to the complex&#xa;&#x9;- get the mols of the last state (for the first round/or at position counter for the following rounds) which are conected to the complex, add an empty bindingsite for the first molecule&#xa;&#x9;- add the complex to alter_complex &#xa;&#x9;-> this results in a complex containing all bindings except the last one for the first round and for each following round one binding less  &#xa;&#x9;-> Hence we get for three AND combinations A--E,A--D,A--C the complexes A,D,E negating C and A,E negating D&#xa;4) if we generated the negative complexes for the different bindings we have to create a complex containing only the root, negating the left over binding A--E in this case&#xa;&#x9;- create a new BiologicalComplex() (biological_complex.biological_complex.BiologicalComplex)&#xa;&#x9;- set is_positive to False&#xa;&#x9;- create a Molecule object of the root molecule&#xa;&#x9;- add the first element of the ordered states as a empty binding site (A--E)&#xa;&#x9;- append the molecule to the new created BiologicalComplex() (biological_complex.biological_complex.BiologicalComplex)&#xa;&#x9;- add the complex to alter_comp&#xa;" name="build_negative_complexes">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="rjGvBpsP6Uaj" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="mFO7J6lykxND" type="SB8tuHR4uOfU" value="" name="compl"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="yrtJnXGp2in0" type="4ax0gnUhtyJt" value="" name="root_molecule"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="TknaR4gNuahf" comment="        Given single BiologicalComplex returns a list of &#xa;        interaction states that 'create' the complex.&#xa;        List is ordered according to the layers starting &#xa;        from states that include given root_molecule.&#xa;                 A&#xa;               / | \&#xa;              /  |  \&#xa;             /   |   \&#xa;            B    C    D&#xa;           / \       / \&#xa;          /   \     /   \&#xa;         F     E    G    H&#xa;              / \&#xa;             /   \&#xa;            K     J&#xa;        Returns: &#xa;        [ A--B, A--C, A--D,&#xa;          B--F, B--E, D--G, D--H,&#xa;          E--K, E--J ]&#xa;        Order within the layers is not important.&#xa;&#xa;result = list of two lists&#xa;stack is list of root molecule&#xa;1) as long as we have something in stacks&#xa;&#x9;- call states_mols = self._get_complex_layer(compl, stack, result)&#xa;&#xa;return a list of lists the first list contains bindings, modifications the second empty bindingsites, empty modification sites" name="get_states_from_complex">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="nNfhxKM3Hp8s" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="aqVzy4mkK9sb" type="SB8tuHR4uOfU" value="" name="compl"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="9GZGk8xBqljH" type="4ax0gnUhtyJt" value="" name="root_molecule"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="6EL5ZlFi1pwj" comment="Helper function for get_states_from_complex.&#xa;&#xa;already: list; stores information about modifications and bindings/empty binding sites we have already seen while process&#xa;result_pos: list; stores bindings, modifications&#xa;result_neg: list; stores empty binding sites/modification sites&#xa;new_roots: list; stores new roots which are used as stack later in get_states_from_complex()&#xa;&#xa;1) iter over rootlist&#xa;&#x9;- get molecule of complex which corresponds to the root&#xa;1.2) check bonds of this molecule&#xa;&#x9;if the bond is not known, append the bond to result_pos; set the binding partner as new root and append the new root to the list new_roots&#xa;1.3) check modification of this molecule&#xa;&#x9;if the modification is not known (not in already), append the modification to result_pos, there are no new_roots we have to concider&#xa;1.4) check binding sites&#xa;&#x9;if binding site is not known, append the binding site to result_neg; don't set a new root because we are looking on a site, that means that the partner is not bound hence there is no connection&#xa;1.5) check modification sites&#xa;&#x9;if modification site is not known, append the modification site to result_neg&#xa;" name="_get_complex_layer">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="J2KGgM8dk4sw" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="NisHda5BOYBM" type="SB8tuHR4uOfU" value="" name="compl"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="zOvED45IGQNp" type="4ax0gnUhtyJt" value="" name="root_list"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="uLNvMfGiO8z1" type="5hPq9PUPSyWX" value="" name="already"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
           </UML:Classifier.feature>
          </UML:Class>
         </UML:Namespace.ownedElement>
        </UML:Package>
       </UML:Namespace.ownedElement>
      </UML:Package>
      <UML:Package visibility="public" isSpecification="false" namespace="Logical View" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="VAPHgV2I0yrv" name="bngl">
       <UML:Namespace.ownedElement>
        <UML:Class visibility="public" isSpecification="false" namespace="VAPHgV2I0yrv" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="yResltQJ3Yq8" comment="    Translates rxncon reactions into BNGL string. &#xa;    Creates BNGL objects that mirror the Rxncon objects but are simpler.&#xa;    Main object used: BnglOutput - menages all strings production. &#xa;    @type reactions:      ReactionPool&#xa;    @param reactions:     dictionary of ReactionContainer objects.&#xa;                          Used to create RulePool (production done by RuleFactory).&#xa;    @type molecules:      MoleculePool&#xa;    @param molecules:     dictionary of all molecules present in the system.&#xa;                          Used to create molecules and species section.&#xa;    @type contingencies:  ContingencyPool&#xa;    @param contingencies: all contingencise for the system.&#xa;                          Used to generate warnings (list states that are not present).&#xa;" name="Bngl">
         <UML:Classifier.feature>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="k5Nmk5qeUM4r" comment=" list of ReactionContainer objects. all molecules in the system." name="__init__">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="H4uDOVrmx8ci" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="FAVLOYGKzuCj" type="4ax0gnUhtyJt" value="" name="reaction_pool"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="ob2p9qxrwKbe" type="4ax0gnUhtyJt" value="" name="molecules"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="ORIsnNj1VDMr" type="4ax0gnUhtyJt" value="" name="contingencies"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="jdBhXMQJxS84" type="4ax0gnUhtyJt" value="" name="warnings"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="VKjyX4pEh0vC" comment="        Returns BNGL source code as a string.&#xa;" name="get_src">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="MLUHmaM3eGE3" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
         </UML:Classifier.feature>
        </UML:Class>
        <UML:Package visibility="public" isSpecification="false" namespace="VAPHgV2I0yrv" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="zxzGAjVersvX" name="bngl_output">
         <UML:Namespace.ownedElement>
          <UML:Class visibility="public" isSpecification="false" namespace="zxzGAjVersvX" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="uJDReJoznpKI" comment="    BioNetGenOutput object creates all sections for BNGL file.&#xa;    Uses rule and molecules generated by BioNetGen. &#xa;" name="BnglOutput">
           <UML:Classifier.feature>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="FiqW2Y9L3PME" name="__init__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="GGGphbzQi9xe" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="DYZf1HFvYSKC" type="4ax0gnUhtyJt" value="" name="rule_pool"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="l99WwToC9fgC" type="4ax0gnUhtyJt" value="" name="molecule_pool"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="DnVECrSNN11N" type="4ax0gnUhtyJt" value="" name="warnings"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="alokOUubGPoS" name="create_sections_txt">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="EGqZGrwW5DJm" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="mHDUOA6yttiI" comment="Formats one section string." name="format_string">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="uBXn4G3Psv1q" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="Ncrbzf4BuslA" type="4ax0gnUhtyJt" value="" name="name"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="jheoswZeDm6b" type="4ax0gnUhtyJt" value="" name="value"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Y51SvmaeSDQK" comment="Returns BNGL source code as a string." name="get_src">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="9zzKj3tdEQPG" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="x9RazyvrKry7" name="create_worning_section">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="AJYtKUy0lvQO" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="BR7JjMYeVzDT" name="create_molecule_type_section">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="w6KGxGL5Xtyr" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Nvr8oFVzgaHN" name="create_seed_species_section">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="wn2QkFtgLBvG" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="QGJx8HpVAeez" name="create_rules_section">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="u7yYhDwb0w1l" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="BsPU4IiSX1Pf" comment=" input parameters\n&quot; normal parameters\n&quot;result = &quot;&quot;for rate in self.rates:    result += &quot;%s 1\n&quot; % rateself.parameters_txt = self.format_string('parameters', result)" name="create_parameters_section">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="GCARrmOjtMHY" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="YBAY5BHG4fi6" name="create_action">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="vQWSPv5e6E3x" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
           </UML:Classifier.feature>
          </UML:Class>
         </UML:Namespace.ownedElement>
        </UML:Package>
        <UML:Package visibility="public" isSpecification="false" namespace="VAPHgV2I0yrv" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="LvqLsfF5c8So" name="requirements">
         <UML:Namespace.ownedElement>
          <UML:Class visibility="public" isSpecification="false" namespace="LvqLsfF5c8So" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="j3ngBQNek4cF" comment="    Disctionary for requirements.&#xa;    Key: reaction as string e.g. 'A_ppi_B'&#xa;    Value: list of requirement lists.&#xa;" name="RequirementsPool">
           <UML:GeneralizableElement.generalization>
            <UML:Generalization xmi.idref="8RTpSN0mgU4Q"/>
           </UML:GeneralizableElement.generalization>
           <UML:Classifier.feature>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="hLnLppmsDDZp" name="__init__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="tJ9ao9SiUzLt" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
           </UML:Classifier.feature>
          </UML:Class>
          <UML:Class visibility="public" isSpecification="false" namespace="LvqLsfF5c8So" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="M9ZNd4jf4ihv" comment="    The RequirementsGenerator object goes through all contingencies &#xa;    using a tree traversal algorithm&#xa;    and generates requirements with only x and ! signs. &#xa;    Input: contingency root node&#xa;    Deals with !, x, boolean contingencies, ignores K+, K-, 0, ?&#xa;" name="RequirementsGenerator">
           <UML:Classifier.feature>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="WOGmCoydwZjH" name="__init__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="vbW0HBtoZ7Yk" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="1xLoC7MWGttt" type="4ax0gnUhtyJt" value="" name="root_node"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="vUNp35720QpA" comment="        Human readable string for boolean contingencies.&#xa;" name="__str__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="X9hl3Ycy98wR" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="JpDqwjasEwfF" comment="        Produces a string with all contingencies from the given node.&#xa;        Traverse contingencies downstream from the given node. &#xa;        When given root node creates complete string.&#xa;" name="_get_str">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="N4CWA6xRu8Io" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="zmGzC59hCoSF" type="4ax0gnUhtyJt" value="" name="node"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="sqe6kKJh6ZgH" comment="        Prepares a dict where requirements will be asign to contingencies.&#xa;        Key: contingency&#xa;        Value: empty RequirementNode object.&#xa;" name="_create_node_dict">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="JP1DYHzQ6eUo" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="cowpcP2xRCUa" type="4ax0gnUhtyJt" value="" name="node"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="ynW2LAHxwEkX" comment="        Recursively assigns requirements to given contingency.&#xa; and cont.ctype not in ['0', '?', 'k+', 'k-', 'x']:and  cont.ctype not in ['0', '?', 'k+', 'k-', 'x']: " name="requirements2nodes">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="rRIv5mk3XG3s" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="bnU0zyaGMcRu" type="4ax0gnUhtyJt" value="" name="cont"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="QLoNZYu8LM8L" comment="        Creates the final list of requirements.&#xa;        It is a list of lists where each list responds to one rule.&#xa;        When reaction has no contingencies it is equal [[]].&#xa;" name="get_requirements">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="LjZhJ1ZASr4X" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
           </UML:Classifier.feature>
          </UML:Class>
          <UML:Class visibility="public" isSpecification="false" namespace="LvqLsfF5c8So" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="doYA4b1SwpnT" comment="    Produces dictionary with requirements for all reactions.&#xa;" name="RequirementsFactory">
           <UML:Classifier.feature>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Nfbh2k0LRZ2k" name="__init__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="fADZz03Lec2g" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="aZs2QwX3k5Bm" type="4ax0gnUhtyJt" value="" name="xls_tables"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="K0zlZzVAYMAy" comment="        Prepares dictionary with requirements.&#xa;" name="generate_requirements">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="Iiz3l8nQJ0yG" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="z1bbbbFwbEfB" comment="        Prepares dictionary with requirement lists&#xa;        (requirements are strings).&#xa;        E.g.&#xa;        A_ppi_B; x A--C&#xa;        A_ppi_B; ! &lt;Bool>&#xa;        &lt;Bool>; OR A-{P}; OR B-{P}&#xa;        'A_ppi_B': [['x A--C', '! A-{P}'], ['x A--C', '! B-{P}']] &#xa;" name="get_requirements_dict">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="D9JlVTjn9gov" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
           </UML:Classifier.feature>
          </UML:Class>
         </UML:Namespace.ownedElement>
        </UML:Package>
        <UML:Package visibility="public" isSpecification="false" namespace="VAPHgV2I0yrv" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="x0UpqNK9HAT9" name="rule">
         <UML:Namespace.ownedElement>
          <UML:Class visibility="public" isSpecification="false" namespace="x0UpqNK9HAT9" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="QUvOOEf7XZyP" name="Rule">
           <UML:Classifier.feature>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Uxcx7bdHZH8P" name="__init__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="J9goicBAYn8f" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="DnfaiiB8C6UZ" type="4ax0gnUhtyJt" value="" name="reaction"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Mjvvy3JBrwmX" comment="Returns reaction arrow depending on reaction reversibility." name="arrow">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="fvdpz7OIG34w" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="dF6B3CrPtkJr" name="rates">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="la3cWn79ikzh" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="rLy5O012G6BH" name="rate_values">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="I0eAkv1WV260" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
           </UML:Classifier.feature>
          </UML:Class>
          <UML:Class visibility="public" isSpecification="false" namespace="x0UpqNK9HAT9" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Dduf1BV7qFwD" name="RuleContainer">
           <UML:GeneralizableElement.generalization>
            <UML:Generalization xmi.idref="hTIBG84vSWhM"/>
           </UML:GeneralizableElement.generalization>
           <UML:Classifier.feature>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="QmhqIMCroqN5" comment=" only to produce contingency string" name="__init__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="mnrM3b8TNnIe" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="KHaQ5kW1PhnI" type="4ax0gnUhtyJt" value="" name="reaction_container"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="9STwJq1d7b3B" name="add_rule">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="RQFnDXRN0uJJ" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="LXClEy10lsKo" type="4ax0gnUhtyJt" value="" name="rule"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="lIuqux1FTCyh" comment="        @rtype: string&#xa;" name="get_name">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="A0gtqyhINu5a" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
           </UML:Classifier.feature>
          </UML:Class>
          <UML:Class visibility="public" isSpecification="false" namespace="x0UpqNK9HAT9" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="IA07MlrCZIEg" comment="    RulePool object is a dictionary that stores all &#xa;    RuleContainer objects for one system.&#xa;    Key: reaction string.&#xa;    Value: RuleContainer.&#xa;" name="RulePool">
           <UML:GeneralizableElement.generalization>
            <UML:Generalization xmi.idref="WzNs2uKV7Nii"/>
           </UML:GeneralizableElement.generalization>
           <UML:Classifier.feature>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="f4EnPuTa7aZ0" name="__init__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="Sz6TOMpYUOHq" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="6ekqPUZ5Wnsv" name="__iter__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="hJTmu3mM0tpO" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
           </UML:Classifier.feature>
          </UML:Class>
         </UML:Namespace.ownedElement>
        </UML:Package>
        <UML:Package visibility="public" isSpecification="false" namespace="VAPHgV2I0yrv" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="niCPofCVftXu" name="rule_factory">
         <UML:Namespace.ownedElement>
          <UML:Class visibility="public" isSpecification="false" namespace="niCPofCVftXu" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="oaJ7aHOXGx8q" name="RuleFactory">
           <UML:Classifier.feature>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="ZNm8bPHmYaX3" name="__init__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="p37MbdPbrElk" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="2Ep9ud2hDMom" type="4ax0gnUhtyJt" value="" name="reaction_pool"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="bAHq6QgdlQlL" type="4ax0gnUhtyJt" value="" name="contingency_pool"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="qnR17DnjO5ZS" comment=" add source and product states and reqs change name. add specific reqs and cont." name="generate_rules">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="TD5EdoXQpfmR" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
           </UML:Classifier.feature>
          </UML:Class>
         </UML:Namespace.ownedElement>
        </UML:Package>
       </UML:Namespace.ownedElement>
      </UML:Package>
      <UML:Package visibility="public" isSpecification="false" namespace="Logical View" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="FxtPCYZvMH5D" name="bgnl">
       <UML:Namespace.ownedElement>
        <UML:Class visibility="public" isSpecification="false" namespace="FxtPCYZvMH5D" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="S00aqE6ob4zr" comment="    BnglTranslator clips functions for&#xa;    translating objects into strings.&#xa;    String order:&#xa;    - molecules are sorted alphabetically&#xa;    - localisation is first in domain-string&#xa;    - then modifcation sites are sorted alphabetically&#xa;    (regardles whether these are sites and actual modifications)&#xa;    - then binding domains are sorted automatically &#xa;    (regardles bound or not). &#xa;" name="BnglTranslator">
         <UML:Classifier.feature>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="X9PA3ZxBSydG" name="__init__">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="NSTl21TU1R5r" type="4ax0gnUhtyJt"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="g9eFEd7jnWtq" comment="        Produces complex string out of BiologicalComplex object.&#xa; for geting right domain from products with homodimers colects domain strings, order is important 1. Localisation domains 2. Covalent modification domains 3. Binding domains TODO: This (used_domains) prabobly should be done on the level of molecule:       To remove empty domains when state gets added:       e.g. when ! A_[x]--B and x A_[x]--C then             remove state A_[x]--C from empty domains.  " name="get_complex_str">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="DJYEkd3Onhez" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="4ozUkdl83Er6" type="4ax0gnUhtyJt" value="" name="compl"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Lji6FZwHMvm4" name="get_side">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="Kk2du6fgF3F2" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="WVCYh2euJC61" type="4ax0gnUhtyJt" value="" name="mol"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="o9QZp2W8lCEy" type="4ax0gnUhtyJt" value="" name="compl"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="lAE53yAaTK88" type="4ax0gnUhtyJt" value="" name="track_dict"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="3jAovMkhUykY" comment="        Returns binding domain.&#xa;" name="get_ipi_binding_domains">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="bmTppgrqQ0cL" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="us6NDCVXuV9o" type="4ax0gnUhtyJt" value="" name="binding"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="KM0pJlLDdRZo" comment="        Returns binding domain from state and molecule name.&#xa;        Returns single string - 1 domain&#xa;" name="get_binding_domain">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="51YGlUGCG610" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="d2KVYTJ9Dkw0" type="4ax0gnUhtyJt" value="" name="name"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="RmqrkSC4oBt5" type="4ax0gnUhtyJt" value="" name="binding"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="uEHVdqKEscjQ" type="4ax0gnUhtyJt" value="" name="mid"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="YC3KNuOF7fkk" comment="        Returns binding domain from state and molecule name.&#xa;        Returns a list.&#xa;        This funcion is used for genertion species and molecule strings.&#xa;" name="get_binding_domain_for_molecules">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="OhW1xTQgh0fy" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="V4xLggkjfIzP" type="4ax0gnUhtyJt" value="" name="name"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="kDZzJbxpn088" type="4ax0gnUhtyJt" value="" name="binding"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="vWN297mcAjxo" type="4ax0gnUhtyJt" value="" name="mid"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="ZcoKduQYOlaX" comment="        Returns molecule string.&#xa;        String contains: &#xa;        - all possible localisations&#xa;        - all all modification sites with both True and False modifiers&#xa;        - all binding domains as not bound.&#xa;        Modes: molecule, species&#xa; 1. Localisation domain 2. Covalent modification domains 3. Binding domains This part is different for molecules and complexes  binding is a State object" name="get_molecule_str">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="81kUmIzca6bc" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="qK7024nOkJPf" type="4ax0gnUhtyJt" value="" name="mol"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="moLTm0SJbEdE" type="4ax0gnUhtyJt" value="" name="mode"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="8OyqhMWTApxu" comment="        Returns molecule string.&#xa;        String contains:&#xa;        - all modification sites with False modifier&#xa;        - all binding domains as not bound.&#xa;        - there is no localisation information included ???&#xa;" name="get_species_str">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="b8BBEmmMAkBr" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="oNDPbobhpL9b" type="4ax0gnUhtyJt" value="" name="mol"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="6hLEUG8IbJfA" comment="###%s###\n' % ('#'*27, rule_container.rid, rule_container.name)  Contingencies: %s\n&quot; % str(cont)  Absolute requirements: %s\n&quot; % common_reqs Source states:  %s %s\n&quot; % (str(rule_container.sp_state), 'False') Product states: %s %s\n&quot; % (str(rule_container.sp_state), 'True')" name="get_reaction_header">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="R4ecopRtUk5z" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="7GruZyV86fKK" type="4ax0gnUhtyJt" value="" name="rule_container"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="yCFZVvjbBYVj" comment=">>>>>>>>> Rule: %s\n&quot; % rule.rid Optional requirements: %s\n&quot; % self.get_reqs_str(rule.specific_reqs)#%s\n&quot; % ', '.join([str(req) for req in additional_reqs])" name="get_rule_header">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="K5rppwmo61Nc" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="Wzrce9u5DXf0" type="4ax0gnUhtyJt" value="" name="rule"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="w5B6dgn8fckH" comment="sorted(range(len(aa)), key=lambda a: aa[a])" name="get_rule_str">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="j1fp32Px5a1j" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="mdLzAyxS3oHt" type="4ax0gnUhtyJt" value="" name="rule"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="FmpuPXABAV8I" name="get_reqs_str">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="3qy9PyqekfW9" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="T6lXu0Ob23R3" type="4ax0gnUhtyJt" value="" name="cont_list"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
          <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="CgIL9RddXM8P" comment="if states_set:    for state in states_set:        result += &quot;# WARNING: required state %s not produced in the reactions. \Add the coresponding reaction or the appropriate molecule types and seed species.\n&quot; % state WARNING: required state %s not produced in the reactions. \" name="get_warning_str">
           <UML:BehavioralFeature.parameter>
            <UML:Parameter kind="return" xmi.id="KXH3AoCNSVic" type="4ax0gnUhtyJt"/>
            <UML:Parameter visibility="private" isSpecification="false" xmi.id="LU1NXSOYGMhf" type="4ax0gnUhtyJt" value="" name="warnings"/>
           </UML:BehavioralFeature.parameter>
          </UML:Operation>
         </UML:Classifier.feature>
        </UML:Class>
        <UML:Package visibility="public" isSpecification="false" namespace="FxtPCYZvMH5D" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="h2h3HkFHiEVq" name="requirements">
         <UML:Namespace.ownedElement>
          <UML:Class visibility="public" isSpecification="false" namespace="h2h3HkFHiEVq" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="9CRiUlhB6UWu" comment="    RequirementNode object calculates &#xa;    requirements for itself based on list of contingency children.&#xa;" name="RequirementNode">
           <UML:Classifier.feature>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="IGmVULJLcQvQ" name="__init__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="XN61NSsUcIC6" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="3tF9Lj3b0p7S" comment="String with number of positive, negative and total requirements." name="__repr__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="8Onkmi9J3FKO" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="fCsHS2LVtafD" comment="        P = P1 + P2 + P3 ...&#xa;                &lt;MM>&#xa;             /       \&#xa;         OR A-{P}    OR B-{P}&#xa;        P1 = [[!A-{P}]]    &#xa;        P2 = [[!B-{P}]]    &#xa;        P  = [[!A-{P}] + [!B-{P}] = [[!A-{P}], [!B-{P}]] &#xa;" name="get_or_positive">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="DUKGjedNpVcH" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="KgoKWtkcFXN1" type="4ax0gnUhtyJt" value="" name="nodes"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="WynNYQaq6N8a" comment="        P = P1 * P2 * P3 ...&#xa;        where P is a list of lists of positive combinations,&#xa;        P1, P2, P3 - positive combinations from children.&#xa;        e.g.&#xa;                &lt;MM>&#xa;             /       \&#xa;        AND A-{P}    AND B-{P}&#xa;        P1 = [[!A-{P}]]&#xa;        P2 = [[!B-{P}]]&#xa;        P  = [!A-{P}] * [!B-{P}] = [[!A-{P}, !B-{P}]]&#xa;" name="get_and_positive">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="UU4HxhXRdIpB" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="GsDWPYXc0srj" type="4ax0gnUhtyJt" value="" name="nodes"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="gN0mk8L11WVO" comment="        Asignes requirements to contingencies &#xa;        with no children and which are not K+ and not K-.&#xa;" name="get_leaf">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="T7d6NSF3pFoY" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="22z2sojLGoaD" type="4ax0gnUhtyJt" value="" name="node"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
           </UML:Classifier.feature>
          </UML:Class>
         </UML:Namespace.ownedElement>
        </UML:Package>
       </UML:Namespace.ownedElement>
      </UML:Package>
      <UML:Package visibility="public" isSpecification="false" namespace="Logical View" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="RJolEn5tl5PG" name="parser">
       <UML:Namespace.ownedElement>
        <UML:Package visibility="public" isSpecification="false" namespace="RJolEn5tl5PG" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="M10EihxX0oiN" name="rxncon_parser">
         <UML:Namespace.ownedElement>
          <UML:Class visibility="public" isSpecification="false" namespace="M10EihxX0oiN" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="ldrlVHTRRF7b" name="parse_rxncon"/>
          <UML:Class visibility="public" isSpecification="false" namespace="M10EihxX0oiN" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="bhiJVxIVYH6t" comment="Simple OS Independent Class for Extracting Data from Excel Files&#xa;        the using xlrd module found at http://www.lexicon.net/sjmachin/xlrd.htm&#xa;        &#xa;        Versions of Excel supported: 2004, 2002, XP, 2000, 97, 95, 5, 4, 3&#xa;        xlrd version tested: 0.5.2&#xa;        &#xa;        Data is extracted by creating a iterator object which can be used to &#xa;        return data one row at a time. The default extraction method assumes &#xa;        that the worksheet is in tabular format with the first nonblank row&#xa;        containing variable names and all subsequent rows containing values.&#xa;        This method returns a dictionary which uses the variables names as keys&#xa;        for each piece of data in the row.  Data can also be extracted with &#xa;        each row represented by a list.&#xa;        &#xa;        Extracted data is represented fairly logically. By default dates are&#xa;        returned as strings in &quot;yyyy/mm/dd&quot; format or &quot;yyyy/mm/dd hh:mm:ss&quot;,&#xa;        as appropriate.  However, dates can be return as a tuple containing&#xa;        (Year, Month, Day, Hour, Min, Second) which is appropriate for usage&#xa;        with mxDateTime or DateTime.  Numbers are returned as either INT or &#xa;        FLOAT, whichever is needed to support the data.  Text, booleans, and&#xa;        error codes are also returned as appropriate representations.&#xa;        &#xa;        Quick Example:&#xa;        xl = readexcel('testdata.xls')&#xa;        sheetnames = xl.worksheets()&#xa;        for sheet in sheetnames:&#xa;            print sheet&#xa;            for row in xl.getiter(sheet):&#xa;                # Do Something here&#xa;" name="readexcel">
           <UML:GeneralizableElement.generalization>
            <UML:Generalization xmi.idref="uUvJARP5CIX6"/>
           </UML:GeneralizableElement.generalization>
           <UML:Classifier.feature>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="khmuxI0WQsl7" comment="Returns a readexcel object of the specified filename - this may&#xa;take a little while because the file must be parsed into memory Generate a listing of Unique Variable Names for Use as Dictionary Keys In Extraction. Duplicate Names will be replaced with &quot;F#&quot;" name="__init__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="vvqVB6Ctoznj" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="F5MH6vo3loZr" type="4ax0gnUhtyJt" value="" name="filename"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="HnFhezmr2988" comment="Return an generator object which yields the lines of a worksheet;&#xa;        Default returns a dictionary, specifing returnlist=True causes lists&#xa;        to be returned.  Calling returntupledate=True causes dates to returned&#xa;        as tuples of (Year, Month, Day, Hour, Min, Second) instead of as a&#xa;string" name="getiter">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="GzjI6pP9lZwU" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="2wAnijfecT7o" type="4ax0gnUhtyJt" value="" name="sheetname"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="aJhMGT5XEJDs" type="4ax0gnUhtyJt" value="" name="returnlist"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="GZ6t3DfdUMxl" comment="Returns a list of the Worksheets in the Excel File" name="worksheets">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="p2G4JTuZRcsX" type="4ax0gnUhtyJt"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="RFgBobf4AjvB" comment="Return the number of rows in a worksheet" name="nrows">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="pfdGHVmgkSrW" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="uaoOvl7imOk5" type="4ax0gnUhtyJt" value="" name="worksheet"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="1UaCDUN74AUz" comment="Return the number of columns in a worksheet" name="ncols">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="pp1XGs3HLbRY" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="tbifzSjn5M3K" type="4ax0gnUhtyJt" value="" name="worksheet"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="5ne8x87ojnUh" comment="Returns a list of Column Names in the file,&#xa;assuming a tabular format of course." name="variables">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="TsqoTGNX3zf0" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="EBUJXVcKLdrZ" type="4ax0gnUhtyJt" value="" name="worksheet"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="7mooYGTmPx3u" comment="Internal function used to clean up the incoming excel data#  Data Type Codes:#  EMPTY 0#  TEXT 1 a Unicode string #  NUMBER 2 float #  DATE 3 float #  BOOLEAN 4 int; 1 means TRUE, 0 means FALSE #  ERROR 5  time only no date component date only, no time full date" name="__formatrow__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="3fHzmnMAfIaV" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="RfEmG5Jkx9WP" type="4ax0gnUhtyJt" value="" name="types"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="PtwQqbQxLDmr" type="4ax0gnUhtyJt" value="" name="values"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="RFbrBflcI0MZ" type="4ax0gnUhtyJt" value="" name="wanttupledate"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" ownerScope="classifier" isRoot="false" xmi.id="rzTAAD0bQbQZ" comment="Function Used To create the List Iterator" name="__iterlist__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="WBCcWMVcrWQb" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="GC9XAV6B8LAt" type="4ax0gnUhtyJt" value="" name="excel"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="8W1nmZJbYkkg" type="4ax0gnUhtyJt" value="" name="sheetname"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="vkIJLitas270" type="4ax0gnUhtyJt" value="" name="tupledate"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
            <UML:Operation visibility="public" isSpecification="false" isQuery="false" isAbstract="false" isLeaf="false" ownerScope="classifier" isRoot="false" xmi.id="6hDcRxJKhZd0" comment="Function Used To create the Dictionary Iterator Pad a Short Row With Blanks if Needed" name="__iterdict__">
             <UML:BehavioralFeature.parameter>
              <UML:Parameter kind="return" xmi.id="7aRxs4GVDDzp" type="4ax0gnUhtyJt"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="FWa6Xf63qIfK" type="4ax0gnUhtyJt" value="" name="excel"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="d9xUdL5j2GKR" type="4ax0gnUhtyJt" value="" name="sheetname"/>
              <UML:Parameter visibility="private" isSpecification="false" xmi.id="BblsAMtNtRTO" type="4ax0gnUhtyJt" value="" name="tupledate"/>
             </UML:BehavioralFeature.parameter>
            </UML:Operation>
           </UML:Classifier.feature>
          </UML:Class>
         </UML:Namespace.ownedElement>
        </UML:Package>
       </UML:Namespace.ownedElement>
      </UML:Package>
      <UML:Association visibility="public" isSpecification="false" namespace="Logical View" xmi.id="21k4EStE8Whq" name="builder">
       <UML:Association.connection>
        <UML:AssociationEnd changeability="changeable" visibility="public" isNavigable="true" isSpecification="false" xmi.id="5SrKdADmjKyK" type="r6QHlw4Ral9t" name="" aggregation="composite"/>
        <UML:AssociationEnd changeability="changeable" visibility="public" isNavigable="true" isSpecification="false" xmi.id="7AIu7Fu7GeBV" type="qBvSsMQXzZTC" name="" aggregation="none"/>
       </UML:Association.connection>
      </UML:Association>
      <UML:Association visibility="public" isSpecification="false" namespace="Logical View" xmi.id="m7r1EIqtytVZ" name="">
       <UML:Association.connection>
        <UML:AssociationEnd changeability="changeable" visibility="public" isNavigable="true" isSpecification="false" xmi.id="jEpIDVYwmnYq" type="r6QHlw4Ral9t" name="" aggregation="aggregate"/>
        <UML:AssociationEnd changeability="changeable" visibility="public" isNavigable="true" isSpecification="false" xmi.id="2NizhZ9TgySt" type="5vg3rwsXWEIW" name="" aggregation="none"/>
       </UML:Association.connection>
      </UML:Association>
      <UML:Association visibility="public" isSpecification="false" namespace="Logical View" xmi.id="sZeXY4QlLAwU" name="">
       <UML:Association.connection>
        <UML:AssociationEnd changeability="changeable" visibility="public" isNavigable="true" isSpecification="false" xmi.id="NeLoASRA93wb" type="5vg3rwsXWEIW" name="" aggregation="composite"/>
        <UML:AssociationEnd changeability="changeable" visibility="public" isNavigable="true" isSpecification="false" xmi.id="AY4frUqi3TFZ" type="r6QHlw4Ral9t" name="" aggregation="none"/>
       </UML:Association.connection>
      </UML:Association>
      <UML:Association visibility="public" isSpecification="false" namespace="Logical View" xmi.id="VdKqlEJ8reu1" name="">
       <UML:Association.connection>
        <UML:AssociationEnd changeability="changeable" visibility="public" isNavigable="true" isSpecification="false" xmi.id="4MBDN7mXeqAT" type="5vg3rwsXWEIW" name="" aggregation="composite"/>
        <UML:AssociationEnd changeability="changeable" visibility="public" isNavigable="true" isSpecification="false" xmi.id="Kz9MQOvvzEmk" type="r6QHlw4Ral9t" name="" aggregation="none"/>
       </UML:Association.connection>
      </UML:Association>
      <UML:Association visibility="public" isSpecification="false" namespace="Logical View" xmi.id="S5qHhlJl5SwS" name="">
       <UML:Association.connection>
        <UML:AssociationEnd changeability="changeable" visibility="public" isNavigable="true" isSpecification="false" xmi.id="YixAZ8br7lDX" type="r6QHlw4Ral9t" name="" aggregation="composite"/>
        <UML:AssociationEnd changeability="changeable" visibility="public" isNavigable="true" isSpecification="false" xmi.id="97Q9LCtlFi3u" type="5vg3rwsXWEIW" name="" aggregation="none"/>
       </UML:Association.connection>
      </UML:Association>
      <UML:Association visibility="public" isSpecification="false" namespace="Logical View" xmi.id="99l89pQLkRlP" name="">
       <UML:Association.connection>
        <UML:AssociationEnd changeability="changeable" visibility="public" isNavigable="true" isSpecification="false" xmi.id="Y6Tw457bdbR4" type="qBvSsMQXzZTC" name="" aggregation="composite"/>
        <UML:AssociationEnd changeability="changeable" visibility="public" isNavigable="true" isSpecification="false" xmi.id="X3XVK5ITE1ZL" type="5vg3rwsXWEIW" name="" aggregation="none"/>
       </UML:Association.connection>
      </UML:Association>
      <UML:Association visibility="public" isSpecification="false" namespace="Logical View" xmi.id="qxgYPQvvUOrY" name="">
       <UML:Association.connection>
        <UML:AssociationEnd changeability="changeable" visibility="public" isNavigable="true" isSpecification="false" xmi.id="Tz94YY93agWs" type="qBvSsMQXzZTC" name="" aggregation="none"/>
        <UML:AssociationEnd changeability="changeable" visibility="public" isNavigable="true" isSpecification="false" xmi.id="joMvptGervCE" type="5vg3rwsXWEIW" name="" aggregation="none"/>
       </UML:Association.connection>
      </UML:Association>
      <UML:Association visibility="public" isSpecification="false" namespace="Logical View" xmi.id="fjEUcOgxUpkz" name="">
       <UML:Association.connection>
        <UML:AssociationEnd changeability="changeable" visibility="public" isNavigable="true" isSpecification="false" xmi.id="n3vjWvCX3h6r" type="5vg3rwsXWEIW" name="" aggregation="none"/>
        <UML:AssociationEnd changeability="changeable" visibility="public" isNavigable="true" isSpecification="false" xmi.id="hVOUHr6uZKMB" type="qBvSsMQXzZTC" name="" aggregation="none"/>
       </UML:Association.connection>
      </UML:Association>
      <UML:Association visibility="public" isSpecification="false" namespace="Logical View" xmi.id="g07BppAat3HP" name="">
       <UML:Association.connection>
        <UML:AssociationEnd changeability="changeable" visibility="public" isNavigable="true" isSpecification="false" xmi.id="yUuz9yqoTFIi" type="5vg3rwsXWEIW" name="" aggregation="none"/>
        <UML:AssociationEnd changeability="changeable" visibility="public" isNavigable="true" isSpecification="false" xmi.id="4OabgulLuqWh" type="qBvSsMQXzZTC" name="" aggregation="none"/>
       </UML:Association.connection>
      </UML:Association>
      <UML:Association visibility="public" isSpecification="false" namespace="Logical View" xmi.id="M3bFt7wXjC1Q" name="com">
       <UML:Association.connection>
        <UML:AssociationEnd changeability="changeable" visibility="public" isNavigable="true" isSpecification="false" xmi.id="kt2jedsO4pXl" type="5vg3rwsXWEIW" name="" aggregation="none"/>
        <UML:AssociationEnd changeability="changeable" visibility="public" isNavigable="true" isSpecification="false" xmi.id="2OSeqktBmUQd" type="qBvSsMQXzZTC" name="" aggregation="none"/>
       </UML:Association.connection>
      </UML:Association>
      <UML:Association visibility="public" isSpecification="false" namespace="Logical View" xmi.id="RUVyTfzN0KIL" name="">
       <UML:Association.connection>
        <UML:AssociationEnd changeability="changeable" visibility="public" isNavigable="true" isSpecification="false" xmi.id="0W3Me0LN0VSY" type="SB8tuHR4uOfU" name="" aggregation="none"/>
        <UML:AssociationEnd changeability="changeable" visibility="public" isNavigable="true" isSpecification="false" xmi.id="rte4QfHr8nnb" type="qBvSsMQXzZTC" name="" aggregation="none"/>
       </UML:Association.connection>
      </UML:Association>
      <UML:Association visibility="public" isSpecification="false" namespace="Logical View" xmi.id="SlzR3Fm3mnPO" name="">
       <UML:Association.connection>
        <UML:AssociationEnd changeability="changeable" visibility="public" isNavigable="true" isSpecification="false" xmi.id="nklnGBJ55x7T" type="SB8tuHR4uOfU" name="" aggregation="composite"/>
        <UML:AssociationEnd changeability="changeable" visibility="public" isNavigable="true" isSpecification="false" xmi.id="bOIj94KapJ1s" type="qBvSsMQXzZTC" name="" aggregation="none"/>
       </UML:Association.connection>
      </UML:Association>
      <UML:Association visibility="public" isSpecification="false" namespace="Logical View" xmi.id="XluHYHfL0R6E" name="">
       <UML:Association.connection>
        <UML:AssociationEnd changeability="changeable" visibility="public" isNavigable="true" isSpecification="false" xmi.id="aPHdKM6vkNes" type="SB8tuHR4uOfU" name="" aggregation="composite"/>
        <UML:AssociationEnd changeability="changeable" visibility="public" isNavigable="true" isSpecification="false" xmi.id="RxSEER4lCw2i" type="qBvSsMQXzZTC" name="" aggregation="none"/>
       </UML:Association.connection>
      </UML:Association>
      <UML:Association visibility="public" isSpecification="false" namespace="Logical View" xmi.id="Ei1C77OfUfJm" name="comp">
       <UML:Association.connection>
        <UML:AssociationEnd changeability="changeable" visibility="public" isNavigable="true" isSpecification="false" xmi.id="1NijkKZ9HzNW" type="qBvSsMQXzZTC" name="" aggregation="composite"/>
        <UML:AssociationEnd changeability="changeable" visibility="public" isNavigable="true" isSpecification="false" xmi.id="OQFaMGGYyHi3" type="SB8tuHR4uOfU" name="" aggregation="none"/>
       </UML:Association.connection>
      </UML:Association>
     </UML:Namespace.ownedElement>
     <XMI.extension xmi.extender="umbrello">
      <diagrams>
       <diagram showopsig="1" linecolor="#ff0000" snapx="25" showattribassocs="1" snapy="25" linewidth="0" showattsig="1" textcolor="#000000" isopen="1" showpackage="1" showpubliconly="0" showstereotype="1" name="Klassendiagramm" font="Sans Serif,9,-1,0,50,0,0,0,0,0" canvasheight="1178,925842285156" canvaswidth="2127,852416992188" localid="-1" snapcsgrid="0" showgrid="0" showops="1" griddotcolor="#d3d3d3" backgroundcolor="#ffffff" usefillcolor="1" fillcolor="#ffff00" zoom="56" xmi.id="6wqepDwnfztt" documentation="" showscope="1" snapgrid="0" showatts="1" type="1">
        <widgets>
         <classwidget linecolor="#ff0000" usesdiagramfillcolor="0" linewidth="0" showoperations="1" textcolor="#000000" usesdiagramusefillcolor="0" showpubliconly="0" showpackage="1" x="-2187,872488839286" showattsigs="601" showstereotype="1" y="-615,5342145647321" showattributes="1" font="Sans Serif,9,-1,0,75,0,0,0,0,0" localid="JMZeu63K6p1v" width="604,26025390625" isinstance="0" usefillcolor="1" fillcolor="#ffff00" xmi.id="qeeki9z1YCSm" showscope="1" height="168,6164398193359" showopsigs="601"/>
         <classwidget linecolor="#ff0000" usesdiagramfillcolor="0" linewidth="0" showoperations="1" textcolor="#000000" usesdiagramusefillcolor="0" showpubliconly="0" showpackage="1" x="-2295,94287109375" showattsigs="601" showstereotype="1" y="-244,6434631347656" showattributes="1" font="Sans Serif,9,-1,0,75,0,0,0,0,0" localid="ntgk0BpHYNvS" width="1000" isinstance="0" usefillcolor="1" fillcolor="#ffff00" xmi.id="r6QHlw4Ral9t" showscope="1" height="294" showopsigs="601"/>
         <classwidget linecolor="#ff0000" usesdiagramfillcolor="0" linewidth="0" showoperations="1" textcolor="#000000" usesdiagramusefillcolor="0" showpubliconly="0" showpackage="1" x="-1555,913940429688" showattsigs="601" showstereotype="1" y="-404,3010864257812" showattributes="1" font="Sans Serif,9,-1,0,75,0,0,0,0,0" localid="GybEqn4HMTMu" width="292" isinstance="0" usefillcolor="1" fillcolor="#ffff00" xmi.id="k1uemhq0sxmv" showscope="1" height="47" showopsigs="601"/>
         <classwidget linecolor="#ff0000" usesdiagramfillcolor="0" linewidth="0" showoperations="1" textcolor="#000000" usesdiagramusefillcolor="0" showpubliconly="0" showpackage="1" x="-1098,090454101562" showattsigs="601" showstereotype="1" y="-263,1442260742188" showattributes="1" font="Sans Serif,9,-1,5,75,0,0,0,0,0" localid="86YUXtOWroEM" width="930" isinstance="0" usefillcolor="1" fillcolor="#ffff00" xmi.id="qBvSsMQXzZTC" showscope="1" height="252" showopsigs="601"/>
         <classwidget linecolor="#ff0000" usesdiagramfillcolor="0" linewidth="0" showoperations="1" textcolor="#000000" usesdiagramusefillcolor="0" showpubliconly="0" showpackage="1" x="-1225,806396484375" showattsigs="601" showstereotype="1" y="-608,6021728515625" showattributes="1" font="Sans Serif,9,-1,0,75,0,0,0,0,0" localid="2OQbnprLr526" width="310" isinstance="0" usefillcolor="1" fillcolor="#ffff00" xmi.id="5LhW07ZnqG86" showscope="1" height="175" showopsigs="601"/>
         <classwidget linecolor="#ff0000" usesdiagramfillcolor="0" linewidth="0" showoperations="1" textcolor="#000000" usesdiagramusefillcolor="0" showpubliconly="0" showpackage="1" x="-1492,139404296875" showattsigs="601" showstereotype="1" y="309,6217956542969" showattributes="1" font="Sans Serif,9,-1,5,75,0,0,0,0,0" localid="wAldA1uYKnlT" width="640" isinstance="0" usefillcolor="1" fillcolor="#ffff00" xmi.id="5vg3rwsXWEIW" showscope="1" height="210" showopsigs="601"/>
         <classwidget linecolor="none" usesdiagramfillcolor="0" linewidth="0" showoperations="1" textcolor="#000000" usesdiagramusefillcolor="0" showpubliconly="0" showpackage="1" x="-705,1724243164062" showattsigs="601" showstereotype="1" y="131,0344848632812" showattributes="1" font="Sans Serif,9,-1,5,75,0,0,0,0,0" localid="i2C7YLR8FW1F" width="500" isinstance="0" usefillcolor="1" fillcolor="#ffff00" xmi.id="SB8tuHR4uOfU" showscope="1" height="427" showopsigs="601"/>
        </widgets>
        <messages/>
        <associations>
         <assocwidget linecolor="none" indexa="1" usesdiagramfillcolor="0" widgetbid="qeeki9z1YCSm" indexb="1" linewidth="none" seqnum="" textcolor="none" usesdiagramusefillcolor="0" totalcounta="2" totalcountb="2" widgetaid="r6QHlw4Ral9t" font="Sans Serif,9,-1,0,50,0,0,0,0,0" visibilityA="1" visibilityB="1" usefillcolor="1" fillcolor="#ffff00" changeabilityA="900" xmi.id="vfNmnI1i5Tla" changeabilityB="900" type="510">
          <linepath layout="Polyline">
           <startpoint startx="-1897,035888671875" starty="-244,6434631347656"/>
           <endpoint endx="-1897,035888671875" endy="-446,9177747453962"/>
          </linepath>
          <floatingtext linecolor="#ff0000" usesdiagramfillcolor="0" linewidth="0" textcolor="#000000" usesdiagramusefillcolor="0" x="-2002,21923828125" showstereotype="1" y="-447" text="contingency_factory" font="Sans Serif,9,-1,0,50,0,0,0,0,0" localid="Ymn38sbWF8EK" pretext="-" role="710" width="134" isinstance="0" posttext="" usefillcolor="1" fillcolor="#ffff00" xmi.id="tmDM5gY0Ltn6" height="18"/>
         </assocwidget>
         <assocwidget linecolor="none" indexa="1" usesdiagramfillcolor="0" widgetbid="k1uemhq0sxmv" indexb="1" linewidth="none" seqnum="" textcolor="none" usesdiagramusefillcolor="0" totalcounta="2" totalcountb="2" widgetaid="r6QHlw4Ral9t" font="Sans Serif,9,-1,0,50,0,0,0,0,0" visibilityA="1" visibilityB="1" usefillcolor="1" fillcolor="#ffff00" changeabilityA="900" xmi.id="VPapzHFJ9bqN" changeabilityB="900" type="510">
          <linepath layout="Polyline">
           <startpoint startx="-1432,59033203125" starty="-244,6434631347656"/>
           <endpoint endx="-1432,59033203125" endy="-357,3010864257812"/>
          </linepath>
          <floatingtext linecolor="#ff0000" usesdiagramfillcolor="0" linewidth="0" textcolor="#000000" usesdiagramusefillcolor="0" x="-1514,096801757812" showstereotype="1" y="-351,9139709472656" text="complex_pool" font="Sans Serif,9,-1,0,50,0,0,0,0,0" localid="yySiW1U1Q2pO" pretext="-" role="710" width="95" isinstance="0" posttext="" usefillcolor="1" fillcolor="#ffff00" xmi.id="J2hSdVorTN4H" height="18"/>
         </assocwidget>
         <assocwidget linecolor="none" indexa="1" usesdiagramfillcolor="0" widgetbid="5LhW07ZnqG86" indexb="1" linewidth="none" seqnum="" textcolor="none" usesdiagramusefillcolor="0" totalcounta="2" totalcountb="2" widgetaid="qBvSsMQXzZTC" font="Sans Serif,9,-1,0,50,0,0,0,0,0" visibilityA="1" visibilityB="1" usefillcolor="1" fillcolor="#ffff00" changeabilityA="900" xmi.id="iS7aRKz307Ig" changeabilityB="900" type="510">
          <linepath layout="Polyline">
           <startpoint startx="-994,6422119140625" starty="-263,1442260742188"/>
           <endpoint endx="-994,6422119140625" endy="-433,6021728515625"/>
          </linepath>
          <floatingtext linecolor="#ff0000" usesdiagramfillcolor="0" linewidth="0" textcolor="#000000" usesdiagramusefillcolor="0" x="-1180,806396484375" showstereotype="1" y="-431,6021423339844" text="required_complexes" font="Sans Serif,9,-1,0,50,0,0,0,0,0" localid="RlGKtaYwyxVl" pretext="-" role="710" width="134" isinstance="0" posttext="" usefillcolor="1" fillcolor="#ffff00" xmi.id="mM7bP9f7Zng0" height="18"/>
         </assocwidget>
         <assocwidget indexa="1" indexb="1" usesdiagramusefillcolor="0" widgetaid="r6QHlw4Ral9t" usesdiagramfillcolor="0" fillcolor="#ffff00" linecolor="#ff0000" seqnum="" totalcounta="2" xmi.id="21k4EStE8Whq" widgetbid="qBvSsMQXzZTC" totalcountb="2" type="510" textcolor="#000000" usefillcolor="1" linewidth="0" font="Sans Serif,9,-1,0,50,0,0,0,0,0">
          <linepath layout="Polyline">
           <startpoint startx="-1295,94287109375" starty="-144,1787109375"/>
           <endpoint endx="-1098,090454101562" endy="-144,1787109375"/>
          </linepath>
          <floatingtext linecolor="none" usesdiagramfillcolor="1" linewidth="none" textcolor="none" usesdiagramusefillcolor="1" x="-1197,016662597656" showstereotype="1" y="-144,1787109375" text="builder" font="Sans Serif,9,-1,5,50,0,0,0,0,0" localid="xOprfLTWqfOh" pretext="" role="703" width="50" isinstance="0" posttext="" usefillcolor="1" fillcolor="none" xmi.id="b86RB4lF0DuQ" height="18"/>
         </assocwidget>
         <assocwidget indexa="1" indexb="1" usesdiagramusefillcolor="1" widgetaid="r6QHlw4Ral9t" usesdiagramfillcolor="0" fillcolor="#ffff00" linecolor="none" seqnum="" totalcounta="2" xmi.id="S5qHhlJl5SwS" widgetbid="5vg3rwsXWEIW" totalcountb="2" type="510" textcolor="none" usefillcolor="1" linewidth="none" font="Sans Serif,9,-1,0,50,0,0,0,0,0">
          <linepath layout="Polyline">
           <startpoint startx="-1414,55322265625" starty="49,35653686523438"/>
           <endpoint endx="-1414,55322265625" endy="309,6217956542969"/>
          </linepath>
         </assocwidget>
         <assocwidget indexa="1" indexb="1" usesdiagramusefillcolor="0" widgetaid="5vg3rwsXWEIW" usesdiagramfillcolor="0" fillcolor="#ffff00" linecolor="none" seqnum="" totalcounta="2" xmi.id="g07BppAat3HP" widgetbid="qBvSsMQXzZTC" totalcountb="2" type="503" textcolor="none" usefillcolor="1" linewidth="none" font="Sans Serif,9,-1,0,50,0,0,0,0,0">
          <linepath layout="Polyline">
           <startpoint startx="-1098,090454101562" starty="309,6217956542969"/>
           <endpoint endx="-1098,090454101562" endy="-11,14422607421875"/>
          </linepath>
         </assocwidget>
         <assocwidget linecolor="none" indexa="1" usesdiagramfillcolor="0" widgetbid="qBvSsMQXzZTC" indexb="1" linewidth="none" seqnum="" textcolor="none" usesdiagramusefillcolor="1" totalcounta="2" totalcountb="2" widgetaid="5vg3rwsXWEIW" font="Sans Serif,9,-1,0,50,0,0,0,0,0" visibilityA="1" visibilityB="1" usefillcolor="1" fillcolor="#ffff00" changeabilityA="900" xmi.id="cOiaCiyAnwSD" changeabilityB="900" type="510">
          <linepath layout="Polyline">
           <startpoint startx="-1098,090454101562" starty="309,6217956542969"/>
           <endpoint endx="-1098,090454101562" endy="-11,14422607421875"/>
          </linepath>
          <floatingtext linecolor="#ff0000" usesdiagramfillcolor="0" linewidth="0" textcolor="#000000" usesdiagramusefillcolor="0" x="-1154,090454101562" showstereotype="1" y="-9,144234657287598" text="builder " font="Sans Serif,9,-1,0,50,0,0,0,0,0" localid="deIWhZtd1nd8" pretext="-" role="710" width="58" isinstance="0" posttext="" usefillcolor="1" fillcolor="#ffff00" xmi.id="jRxBgFrjcSIG" height="18"/>
         </assocwidget>
         <assocwidget indexa="1" indexb="1" usesdiagramusefillcolor="0" widgetaid="qBvSsMQXzZTC" usesdiagramfillcolor="0" fillcolor="#ffff00" linecolor="#ff0000" seqnum="" totalcounta="2" xmi.id="Ei1C77OfUfJm" widgetbid="SB8tuHR4uOfU" totalcountb="2" type="510" textcolor="#000000" usefillcolor="1" linewidth="0" font="Sans Serif,9,-1,0,50,0,0,0,0,0">
          <linepath layout="Polyline">
           <startpoint startx="-705,1724243164062" starty="-11,14422607421875"/>
           <endpoint endx="-705,1724243164062" endy="131,0344848632812"/>
          </linepath>
          <floatingtext linecolor="none" usesdiagramfillcolor="1" linewidth="none" textcolor="none" usesdiagramusefillcolor="1" x="-705,1724243164062" showstereotype="1" y="59,94512557983398" text="comp" font="Sans Serif,9,-1,5,50,0,0,0,0,0" localid="O6iqlzdkNJS5" pretext="" role="703" width="41" isinstance="0" posttext="" usefillcolor="1" fillcolor="none" xmi.id="dzFtzaPNycwJ" height="18"/>
         </assocwidget>
        </associations>
       </diagram>
      </diagrams>
     </XMI.extension>
    </UML:Model>
    <UML:Model stereotype="folder" visibility="public" isSpecification="false" namespace="m1" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Use Case View" name="Use Case View">
     <UML:Namespace.ownedElement/>
    </UML:Model>
    <UML:Model stereotype="folder" visibility="public" isSpecification="false" namespace="m1" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Component View" name="Component View">
     <UML:Namespace.ownedElement/>
    </UML:Model>
    <UML:Model stereotype="folder" visibility="public" isSpecification="false" namespace="m1" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Deployment View" name="Deployment View">
     <UML:Namespace.ownedElement/>
    </UML:Model>
    <UML:Model stereotype="folder" visibility="public" isSpecification="false" namespace="m1" isAbstract="false" isLeaf="false" isRoot="false" xmi.id="Entity Relationship Model" name="Entity Relationship Model">
     <UML:Namespace.ownedElement/>
    </UML:Model>
   </UML:Namespace.ownedElement>
  </UML:Model>
 </XMI.content>
 <XMI.extensions xmi.extender="umbrello">
  <docsettings viewid="6wqepDwnfztt" uniqueid="b86RB4lF0DuQ" documentation=""/>
  <listview>
   <listitem open="1" type="800" id="Views">
    <listitem open="1" type="802" id="Use Case View"/>
    <listitem open="1" type="836" id="Entity Relationship Model"/>
    <listitem open="1" type="821" id="Component View"/>
    <listitem open="1" type="801" id="Logical View">
     <listitem open="0" type="818" id="FxtPCYZvMH5D">
      <listitem open="0" type="813" id="S00aqE6ob4zr">
       <listitem open="0" type="815" id="X9PA3ZxBSydG"/>
       <listitem open="0" type="815" id="YC3KNuOF7fkk"/>
       <listitem open="0" type="815" id="KM0pJlLDdRZo"/>
       <listitem open="0" type="815" id="g9eFEd7jnWtq"/>
       <listitem open="0" type="815" id="3jAovMkhUykY"/>
       <listitem open="0" type="815" id="ZcoKduQYOlaX"/>
       <listitem open="0" type="815" id="6hLEUG8IbJfA"/>
       <listitem open="0" type="815" id="FmpuPXABAV8I"/>
       <listitem open="0" type="815" id="yCFZVvjbBYVj"/>
       <listitem open="0" type="815" id="w5B6dgn8fckH"/>
       <listitem open="0" type="815" id="Lji6FZwHMvm4"/>
       <listitem open="0" type="815" id="8OyqhMWTApxu"/>
       <listitem open="0" type="815" id="CgIL9RddXM8P"/>
      </listitem>
      <listitem open="1" type="818" id="h2h3HkFHiEVq">
       <listitem open="0" type="813" id="9CRiUlhB6UWu">
        <listitem open="0" type="815" id="IGmVULJLcQvQ"/>
        <listitem open="0" type="815" id="3tF9Lj3b0p7S"/>
        <listitem open="0" type="815" id="WynNYQaq6N8a"/>
        <listitem open="0" type="815" id="gN0mk8L11WVO"/>
        <listitem open="0" type="815" id="fCsHS2LVtafD"/>
       </listitem>
      </listitem>
     </listitem>
     <listitem open="1" type="818" id="wWKzyIPAlY8l">
      <listitem open="0" type="813" id="5LhW07ZnqG86">
       <listitem open="0" type="815" id="V7f0LblNb2y5"/>
       <listitem open="0" type="815" id="1pG0XBLt9CEi"/>
       <listitem open="0" type="815" id="EC9m3j679EBh"/>
       <listitem open="0" type="815" id="nmtF0QNJk32b"/>
       <listitem open="0" type="815" id="K5qmyQrlDk0D"/>
       <listitem open="0" type="815" id="4S86atdp04FI"/>
       <listitem open="0" type="815" id="H7RQJd6mWOK7"/>
       <listitem open="0" type="815" id="jefuOf5XzaPN"/>
       <listitem open="0" type="815" id="B0Y7JL30zivL"/>
       <listitem open="0" type="815" id="Bc5kd4naTWcq"/>
       <listitem open="0" type="815" id="561UesCpUFZ7"/>
      </listitem>
      <listitem open="0" type="813" id="SB8tuHR4uOfU">
       <listitem open="0" type="815" id="W5aDW2aClIMC"/>
       <listitem open="0" type="815" id="U63OQAgKPgne"/>
       <listitem open="0" type="815" id="wE0TFAuVFbHC"/>
       <listitem open="0" type="815" id="n8YT6kMENfSi"/>
       <listitem open="0" type="815" id="bQggPTkTiyEv"/>
       <listitem open="0" type="815" id="7qWX2UFHWEFn"/>
       <listitem open="0" type="815" id="AWEo44Np6qPL"/>
       <listitem open="0" type="815" id="QsXlXsWch37j"/>
       <listitem open="0" type="815" id="RZhPcYpCPU3I"/>
       <listitem open="0" type="815" id="WzIpg7KdaXGM"/>
       <listitem open="0" type="815" id="jDWMjXWSLUfj"/>
       <listitem open="0" type="815" id="LlU7oDjE5Gza"/>
       <listitem open="0" type="815" id="7JYwJWAu8djU"/>
       <listitem open="0" type="815" id="1EnQbu8msHIw"/>
       <listitem open="0" type="815" id="pVzqYT9wcqK6"/>
       <listitem open="0" type="815" id="A49Hi00Dzng7"/>
       <listitem open="0" type="815" id="FwI4TZeQ45N0"/>
       <listitem open="0" type="815" id="LRNaSUT6e4gz"/>
       <listitem open="0" type="815" id="iCXgkaO30lbS"/>
       <listitem open="0" type="815" id="n4TZFxRi3U6T"/>
       <listitem open="0" type="815" id="LxwUuGvIWsCG"/>
       <listitem open="0" type="815" id="6eiyOb7iZ3CR"/>
       <listitem open="0" type="815" id="XZsXKUzWXUMg"/>
       <listitem open="0" type="815" id="AIPHHb6nAwKT"/>
       <listitem open="0" type="815" id="pWwp8uNczyqV"/>
       <listitem open="0" type="815" id="kmBiNzGATCxb"/>
       <listitem open="0" type="815" id="Imku7RObRhQ5"/>
       <listitem open="0" type="815" id="zUeSec2jxEkE"/>
       <listitem open="0" type="815" id="liZuipOhH27t"/>
      </listitem>
      <listitem open="1" type="818" id="cWwYvJ809FfC">
       <listitem open="1" type="813" id="5vg3rwsXWEIW">
        <listitem open="0" type="815" id="HoDLDZBIizEp"/>
        <listitem open="0" type="815" id="uw6n9AXH4osD"/>
        <listitem open="0" type="815" id="d4yJquTihtkJ"/>
        <listitem open="0" type="815" id="juaCV5rHDqTo"/>
        <listitem open="0" type="815" id="qKhraoEC6nyP"/>
        <listitem open="0" type="814" id="cOiaCiyAnwSD"/>
        <listitem open="0" type="815" id="6JqUK7Gzip6d"/>
        <listitem open="0" type="815" id="Z2kHpouSxO3U"/>
        <listitem open="0" type="815" id="zykS2pEmhowC"/>
        <listitem open="0" type="815" id="dipBM0CDFcBJ"/>
        <listitem open="0" type="815" id="OLAT90gU1I9N"/>
        <listitem open="0" type="815" id="Cjl245sS2wgN"/>
        <listitem open="0" type="815" id="bl4dhiytN1Jm"/>
        <listitem open="0" type="815" id="DEAK16hGpMBn"/>
       </listitem>
      </listitem>
      <listitem open="1" type="818" id="iqiArkunGFkF">
       <listitem open="0" type="813" id="qBvSsMQXzZTC">
        <listitem open="0" type="815" id="seFYnMhtfNLw"/>
        <listitem open="0" type="815" id="6EL5ZlFi1pwj"/>
        <listitem open="0" type="815" id="tBxuBJH8Rq8H"/>
        <listitem open="0" type="815" id="4WSxyBwI5TYx"/>
        <listitem open="0" type="815" id="33nqYaNvCvxC"/>
        <listitem open="0" type="815" id="GrXkpiisrM7B"/>
        <listitem open="0" type="815" id="Ho7Sw3cWkib1"/>
        <listitem open="0" type="815" id="7CwJ5uUFOj2q"/>
        <listitem open="0" type="815" id="CFvwyXwYFMG3"/>
        <listitem open="0" type="815" id="HwIIyrfYpVoZ"/>
        <listitem open="0" type="814" id="kDbDadVjh1DC"/>
        <listitem open="0" type="815" id="ZaC5jsWv7Sq3"/>
        <listitem open="0" type="815" id="TknaR4gNuahf"/>
        <listitem open="0" type="815" id="lBLrbBuWvUiz"/>
        <listitem open="0" type="815" id="42S1atEQYTyL"/>
        <listitem open="0" type="814" id="iS7aRKz307Ig"/>
        <listitem open="0" type="814" id="qgLEi8cz8HRj"/>
       </listitem>
      </listitem>
      <listitem open="1" type="813" id="k1uemhq0sxmv">
       <listitem open="0" type="816" id="Oxl1I54j4Dip"/>
      </listitem>
     </listitem>
     <listitem open="0" type="818" id="VAPHgV2I0yrv">
      <listitem open="0" type="813" id="yResltQJ3Yq8">
       <listitem open="0" type="815" id="k5Nmk5qeUM4r"/>
       <listitem open="0" type="815" id="VKjyX4pEh0vC"/>
      </listitem>
      <listitem open="1" type="818" id="zxzGAjVersvX">
       <listitem open="0" type="813" id="uJDReJoznpKI">
        <listitem open="0" type="815" id="FiqW2Y9L3PME"/>
        <listitem open="0" type="815" id="YBAY5BHG4fi6"/>
        <listitem open="0" type="815" id="BR7JjMYeVzDT"/>
        <listitem open="0" type="815" id="BsPU4IiSX1Pf"/>
        <listitem open="0" type="815" id="QGJx8HpVAeez"/>
        <listitem open="0" type="815" id="alokOUubGPoS"/>
        <listitem open="0" type="815" id="Nvr8oFVzgaHN"/>
        <listitem open="0" type="815" id="x9RazyvrKry7"/>
        <listitem open="0" type="815" id="mHDUOA6yttiI"/>
        <listitem open="0" type="815" id="Y51SvmaeSDQK"/>
       </listitem>
      </listitem>
      <listitem open="1" type="818" id="LvqLsfF5c8So">
       <listitem open="0" type="813" id="doYA4b1SwpnT">
        <listitem open="0" type="815" id="Nfbh2k0LRZ2k"/>
        <listitem open="0" type="815" id="K0zlZzVAYMAy"/>
        <listitem open="0" type="815" id="z1bbbbFwbEfB"/>
       </listitem>
       <listitem open="0" type="813" id="M9ZNd4jf4ihv">
        <listitem open="0" type="815" id="WOGmCoydwZjH"/>
        <listitem open="0" type="815" id="vUNp35720QpA"/>
        <listitem open="0" type="815" id="sqe6kKJh6ZgH"/>
        <listitem open="0" type="815" id="JpDqwjasEwfF"/>
        <listitem open="0" type="815" id="QLoNZYu8LM8L"/>
        <listitem open="0" type="815" id="ynW2LAHxwEkX"/>
       </listitem>
       <listitem open="0" type="813" id="j3ngBQNek4cF">
        <listitem open="0" type="815" id="hLnLppmsDDZp"/>
       </listitem>
      </listitem>
      <listitem open="1" type="818" id="x0UpqNK9HAT9">
       <listitem open="0" type="813" id="QUvOOEf7XZyP">
        <listitem open="0" type="815" id="Uxcx7bdHZH8P"/>
        <listitem open="0" type="815" id="Mjvvy3JBrwmX"/>
        <listitem open="0" type="815" id="rLy5O012G6BH"/>
        <listitem open="0" type="815" id="dF6B3CrPtkJr"/>
       </listitem>
       <listitem open="0" type="813" id="Dduf1BV7qFwD">
        <listitem open="0" type="815" id="QmhqIMCroqN5"/>
        <listitem open="0" type="815" id="9STwJq1d7b3B"/>
        <listitem open="0" type="815" id="lIuqux1FTCyh"/>
       </listitem>
       <listitem open="0" type="813" id="IA07MlrCZIEg">
        <listitem open="0" type="815" id="f4EnPuTa7aZ0"/>
        <listitem open="0" type="815" id="6ekqPUZ5Wnsv"/>
       </listitem>
      </listitem>
      <listitem open="1" type="818" id="niCPofCVftXu">
       <listitem open="0" type="813" id="oaJ7aHOXGx8q">
        <listitem open="0" type="815" id="ZNm8bPHmYaX3"/>
        <listitem open="0" type="815" id="qnR17DnjO5ZS"/>
       </listitem>
      </listitem>
     </listitem>
     <listitem open="0" type="813" id="Y3Wbru5IapPn">
      <listitem open="0" type="815" id="ajx2oyRrDjbb"/>
      <listitem open="0" type="815" id="nPu16TaxShWo"/>
     </listitem>
     <listitem open="0" type="813" id="p5fxNTiBTZpy">
      <listitem open="0" type="815" id="ojPEYeFjg252"/>
      <listitem open="0" type="815" id="qYQXkPZyPpH3"/>
      <listitem open="0" type="815" id="NpCREKBOcYpj"/>
      <listitem open="0" type="815" id="E0FKgOllDNKZ"/>
      <listitem open="0" type="815" id="m3WR4aTBbeFp"/>
     </listitem>
     <listitem open="1" type="803" id="OPXj5lavULUC">
      <listitem open="0" type="813" id="ehDEredXVdYT">
       <listitem open="0" type="815" id="czA2QxDIWmNv"/>
       <listitem open="0" type="815" id="Oj0uVOnoJkx2"/>
       <listitem open="0" type="815" id="K2TknPpOGpyU"/>
       <listitem open="0" type="815" id="sbb7OYZ2soiW"/>
       <listitem open="0" type="815" id="3b3Iu58QeMUz"/>
       <listitem open="0" type="815" id="2ljcs107bzts"/>
       <listitem open="0" type="815" id="9YhXjeoGrZ4V"/>
       <listitem open="0" type="815" id="7Pl91KFzHK2q"/>
       <listitem open="0" type="815" id="rIOgrR9j2cb8"/>
       <listitem open="0" type="815" id="WFnqgJY22XuV"/>
       <listitem open="0" type="815" id="ZiAB4c8ka8KQ"/>
      </listitem>
      <listitem open="1" type="818" id="tosP0U9k70Vc">
       <listitem open="0" type="813" id="qeeki9z1YCSm">
        <listitem open="0" type="815" id="QyAjBWrUKkgM"/>
        <listitem open="0" type="815" id="yyF1Q2ELjub8"/>
        <listitem open="0" type="815" id="9C6lqVSeQ6hS"/>
        <listitem open="0" type="815" id="ZPH1fKfdPgrC"/>
        <listitem open="0" type="815" id="8G0XurhrceQj"/>
        <listitem open="0" type="815" id="2ISltTsTUH5e"/>
        <listitem open="0" type="815" id="xhfFPLbqKnaD"/>
        <listitem open="0" type="815" id="TwtJmJGCla37"/>
       </listitem>
       <listitem open="0" type="813" id="qZ07QNQqiLbk">
        <listitem open="0" type="815" id="V1lBQp3K9PPP"/>
        <listitem open="0" type="815" id="YBXNKG3nHozf"/>
        <listitem open="0" type="815" id="LRFREnFlaE5D"/>
        <listitem open="0" type="815" id="hrtZhjFDprBP"/>
        <listitem open="0" type="815" id="Wn1KeAjKq4YH"/>
        <listitem open="0" type="815" id="Y6cxbsX0YmV8"/>
        <listitem open="0" type="815" id="AiGLBvPh6x2P"/>
        <listitem open="0" type="815" id="TEyxoiGwRVGa"/>
       </listitem>
      </listitem>
      <listitem open="0" type="813" id="nE9Vw6BoS7rq">
       <listitem open="0" type="815" id="7tqNx2cF0HNl"/>
       <listitem open="0" type="815" id="34exG8cafETS"/>
       <listitem open="0" type="815" id="ZoE5PzsWQ7Xp"/>
       <listitem open="0" type="815" id="2rbqfP7OtHaS"/>
       <listitem open="0" type="815" id="aA1cZenXG56S"/>
       <listitem open="0" type="815" id="1s77ewvaD1b8"/>
       <listitem open="0" type="815" id="z29zJWiTtx7J"/>
       <listitem open="0" type="815" id="nm2f2hGjMEzm"/>
       <listitem open="0" type="815" id="VRMwxjTDIojL"/>
       <listitem open="0" type="815" id="OEV0pbNJf4Mv"/>
       <listitem open="0" type="815" id="IRZ8q4QEQwvP"/>
      </listitem>
     </listitem>
     <listitem open="0" type="813" id="BP45bBkZ1pSH">
      <listitem open="0" type="815" id="N8XmvtmdBNbU"/>
      <listitem open="0" type="815" id="qkBHUVHNXrFO"/>
      <listitem open="0" type="815" id="SNwl3FAxi9i2"/>
      <listitem open="0" type="815" id="wVzkJ4h7pqOH"/>
     </listitem>
     <listitem open="0" type="830" id="Datatypes">
      <listitem open="1" type="829" id="5hPq9PUPSyWX"/>
      <listitem open="1" type="829" id="87Hl5Afww7fn"/>
      <listitem open="1" type="829" id="2T8bSm8YgxBV"/>
      <listitem open="1" type="829" id="dLTWHlOKSlBa"/>
      <listitem open="1" type="829" id="zy1dvC72IOnN"/>
      <listitem open="1" type="829" id="UikbCZ7E3DqV"/>
      <listitem open="1" type="829" id="roUjrN5x9VrV"/>
      <listitem open="1" type="829" id="Vh2Yss1qo3Ti"/>
      <listitem open="1" type="829" id="AdxaaT7UkswX"/>
      <listitem open="1" type="829" id="PqOVgDGJWjnn"/>
      <listitem open="1" type="829" id="WQHSYvD0bwcn"/>
      <listitem open="1" type="829" id="4ax0gnUhtyJt"/>
      <listitem open="1" type="829" id="wInSpWwr6rrm"/>
      <listitem open="0" type="829" id="BEpRW5sphWn8"/>
      <listitem open="1" type="829" id="DakVyXqSy6sW"/>
      <listitem open="1" type="829" id="I3U64xoIYWlU"/>
      <listitem open="1" type="829" id="16Uc26QVnS2e"/>
     </listitem>
     <listitem open="0" type="818" id="S0uaHtUc4SyQ">
      <listitem open="0" type="813" id="NDXzAOrelJEV">
       <listitem open="0" type="815" id="6Gf3nlb7Tk1c"/>
       <listitem open="0" type="815" id="o1teVo2G3P7k"/>
       <listitem open="0" type="815" id="pxqWgbHxHE6X"/>
       <listitem open="0" type="815" id="Jgy8IDid2RPa"/>
       <listitem open="0" type="815" id="YumLnf9ady6J"/>
       <listitem open="0" type="815" id="LpjoYiOc3SCC"/>
       <listitem open="0" type="815" id="LeRwcWFAqUxQ"/>
      </listitem>
     </listitem>
     <listitem open="0" type="813" id="xtnAwXedV2b0"/>
     <listitem open="0" type="807" id="6wqepDwnfztt" label="Klassendiagramm"/>
     <listitem open="0" type="813" id="EnUCJkRim0MZ"/>
     <listitem open="0" type="818" id="DVAy06QCwPNb">
      <listitem open="1" type="818" id="6s9h3TBVT34k">
       <listitem open="0" type="813" id="savREAGHryH0">
        <listitem open="0" type="815" id="21oRCtfukVsh"/>
        <listitem open="0" type="815" id="uyvFEQSSalnu"/>
        <listitem open="0" type="815" id="aJpSI2I2jFBL"/>
        <listitem open="0" type="815" id="RM5YnIrKjSk8"/>
        <listitem open="0" type="815" id="nzfT7RxVoEfA"/>
        <listitem open="0" type="815" id="ZTaQPpQQqDr0"/>
        <listitem open="0" type="815" id="CVW8WV3c6klu"/>
        <listitem open="0" type="815" id="mJGT7foWw11w"/>
       </listitem>
      </listitem>
      <listitem open="0" type="813" id="5UB3DpAmKja3">
       <listitem open="0" type="815" id="pzaa7ayJJUwl"/>
       <listitem open="0" type="815" id="FadCf4jASjxz"/>
       <listitem open="0" type="815" id="ClYcSWbES5x6"/>
       <listitem open="0" type="815" id="m9V9cSwTJB2D"/>
       <listitem open="0" type="815" id="VN0pZ20W0iTa"/>
       <listitem open="0" type="815" id="hkEpM3Bm6ul5"/>
       <listitem open="0" type="815" id="DaEWRhJAX1Tv"/>
       <listitem open="0" type="815" id="KHuGOenXsIVP"/>
       <listitem open="0" type="815" id="hNxvlin5SrKG"/>
       <listitem open="0" type="815" id="9wWEBRhGnxeZ"/>
       <listitem open="0" type="815" id="h6iJQJ4Lq4Ws"/>
       <listitem open="0" type="815" id="c6YvpD8O2RsH"/>
       <listitem open="0" type="815" id="j6CIHB1gLkfC"/>
       <listitem open="0" type="815" id="lunvwuflql0m"/>
       <listitem open="0" type="815" id="pw8FySufWbww"/>
       <listitem open="0" type="815" id="lGADDICyahAB"/>
       <listitem open="0" type="815" id="VX92YdvrUx71"/>
       <listitem open="0" type="815" id="VcDiYw6sKsVp"/>
       <listitem open="0" type="815" id="CSzuilXnDwjQ"/>
       <listitem open="0" type="815" id="diNr9pStjFof"/>
       <listitem open="0" type="815" id="uZ2D3wz2SuQ2"/>
       <listitem open="0" type="815" id="4LIQofA2XuOv"/>
       <listitem open="0" type="815" id="k0rajXty13mu"/>
       <listitem open="0" type="815" id="U5pF2TodFOlu"/>
       <listitem open="0" type="815" id="kitAXBQrw9lZ"/>
       <listitem open="0" type="815" id="rgFWokHXYqrl"/>
      </listitem>
      <listitem open="0" type="813" id="gPRSmOkbKfX2">
       <listitem open="0" type="815" id="jLtVQQxSi1WN"/>
       <listitem open="0" type="815" id="bVapk3bUOSxp"/>
      </listitem>
      <listitem open="0" type="818" id="ck9Iye8tcbiS">
       <listitem open="0" type="813" id="bgkRyFqXREYP">
        <listitem open="0" type="815" id="rEZbAba6dVpF"/>
        <listitem open="0" type="815" id="hbmK5bZHraJ3"/>
        <listitem open="0" type="815" id="TQoa8kgevRgG"/>
        <listitem open="0" type="815" id="y4vldiSnqzxi"/>
        <listitem open="0" type="815" id="n4FxE30hIlcp"/>
        <listitem open="0" type="815" id="3WwSkUrBvdm1"/>
        <listitem open="0" type="815" id="BmxfYd3Z9z1u"/>
        <listitem open="0" type="815" id="vBuMMZt8mekY"/>
        <listitem open="0" type="815" id="6Ocz0LaxCAo2"/>
        <listitem open="0" type="815" id="YUbsv3Dg5QcJ"/>
        <listitem open="0" type="815" id="FYvmfuSMTDfW"/>
        <listitem open="0" type="815" id="hlXvwcKrzldE"/>
        <listitem open="0" type="815" id="iAr0E44wnZpj"/>
        <listitem open="0" type="815" id="lcdbClI2uufC"/>
        <listitem open="0" type="815" id="MGRdldaWEB7Q"/>
        <listitem open="0" type="815" id="rTRaExQTunIv"/>
        <listitem open="0" type="815" id="koJVjymYSD6e"/>
        <listitem open="0" type="815" id="0eBQrI5xn9x5"/>
        <listitem open="0" type="815" id="ofMnhEQhsc8h"/>
        <listitem open="0" type="815" id="dpzN8WTXa4Ed"/>
        <listitem open="0" type="815" id="ux94XwoAjlWs"/>
        <listitem open="0" type="815" id="ZkajjZbBNeWp"/>
        <listitem open="0" type="815" id="cW75Sp52ZdjH"/>
        <listitem open="0" type="815" id="kjMIN5ZYLz6H"/>
        <listitem open="0" type="815" id="kdOdY3zHkLZ5"/>
       </listitem>
       <listitem open="0" type="813" id="FCBwpo3MIcEB">
        <listitem open="0" type="815" id="fPqkqS2I212N"/>
        <listitem open="0" type="815" id="LezbGEkubYeP"/>
        <listitem open="0" type="815" id="rtnTdBKdH4Bv"/>
        <listitem open="0" type="815" id="3AwThJV6Mddm"/>
        <listitem open="0" type="815" id="Fs6wWTFK9BQu"/>
        <listitem open="0" type="815" id="sQvhN5DeinGz"/>
       </listitem>
      </listitem>
     </listitem>
     <listitem open="0" type="818" id="RJolEn5tl5PG">
      <listitem open="0" type="818" id="M10EihxX0oiN">
       <listitem open="0" type="813" id="ldrlVHTRRF7b"/>
       <listitem open="0" type="813" id="bhiJVxIVYH6t">
        <listitem open="0" type="815" id="7mooYGTmPx3u"/>
        <listitem open="0" type="815" id="khmuxI0WQsl7"/>
        <listitem open="0" type="815" id="6hDcRxJKhZd0"/>
        <listitem open="0" type="815" id="rzTAAD0bQbQZ"/>
        <listitem open="0" type="815" id="HnFhezmr2988"/>
        <listitem open="0" type="815" id="1UaCDUN74AUz"/>
        <listitem open="0" type="815" id="RFgBobf4AjvB"/>
        <listitem open="0" type="815" id="5ne8x87ojnUh"/>
        <listitem open="0" type="815" id="GZ6t3DfdUMxl"/>
       </listitem>
      </listitem>
     </listitem>
     <listitem open="0" type="818" id="rKsDP6CIv2ht">
      <listitem open="0" type="813" id="lNO4J8bKjrXv">
       <listitem open="0" type="815" id="lVnor4eGBvVO"/>
       <listitem open="0" type="815" id="L8nF1RtlueZl"/>
      </listitem>
      <listitem open="0" type="818" id="Uqbbo6B51FmD">
       <listitem open="0" type="813" id="Y3YYHqxTRgLZ">
        <listitem open="0" type="815" id="2CxteQHl0ggt"/>
        <listitem open="0" type="815" id="RywRedINXdKd"/>
        <listitem open="0" type="815" id="3cTgigLS5PtY"/>
        <listitem open="0" type="815" id="BWRWwzi0b9eH"/>
        <listitem open="0" type="815" id="mP6RVwkD5QSp"/>
        <listitem open="0" type="815" id="P12y2iCTg8sJ"/>
        <listitem open="0" type="815" id="4TjbwpTyP3E7"/>
        <listitem open="0" type="815" id="OIhnzVX80wcw"/>
       </listitem>
      </listitem>
      <listitem open="0" type="813" id="8Wq9i8yrhK77">
       <listitem open="0" type="815" id="Kg4hurUhPNER"/>
       <listitem open="0" type="815" id="7GYoaftuJwaE"/>
       <listitem open="0" type="815" id="l3TkZRepAuxu"/>
       <listitem open="0" type="815" id="oAke0krwIwrv"/>
       <listitem open="0" type="815" id="C23oiEyn3u3m"/>
       <listitem open="0" type="815" id="IkI8kS5WaoAa"/>
       <listitem open="0" type="815" id="0Tna5xU1jZXi"/>
       <listitem open="0" type="815" id="dlbm8PIYYdc7"/>
       <listitem open="0" type="815" id="yo7Vz7JcqsNz"/>
       <listitem open="0" type="815" id="7rxHltA6sZyf"/>
       <listitem open="0" type="815" id="Ha6CAvnMvoAb"/>
       <listitem open="0" type="815" id="E4eAqplqw8tv"/>
       <listitem open="0" type="815" id="bPEaOWJTnpFL"/>
       <listitem open="0" type="815" id="vCZpISkn9PqV"/>
       <listitem open="0" type="815" id="1dHFE1kCUVmX"/>
       <listitem open="0" type="815" id="ya6vdLwEi9p4"/>
      </listitem>
      <listitem open="1" type="818" id="CrzCfhXYaALW">
       <listitem open="0" type="813" id="mHcr9bv39eOH">
        <listitem open="0" type="815" id="Glu29sYgB5vx"/>
        <listitem open="0" type="815" id="KOjjDBsTumU2"/>
        <listitem open="0" type="815" id="3h5D8KJQg0Au"/>
        <listitem open="0" type="815" id="rLIXbS4Cigej"/>
        <listitem open="0" type="815" id="mJvvD04YN6gL"/>
        <listitem open="0" type="815" id="PKKQsrOeAJYN"/>
        <listitem open="0" type="815" id="bIcU1biOu0om"/>
        <listitem open="0" type="815" id="2KJ2NVZdjm2N"/>
        <listitem open="0" type="815" id="MP48yMS0fm22"/>
        <listitem open="0" type="815" id="GGDRgyMtkbyJ"/>
        <listitem open="0" type="815" id="UY3AXD4gBQkv"/>
       </listitem>
       <listitem open="0" type="813" id="CXFhncrex7CY">
        <listitem open="0" type="815" id="k8cODtIA3L8W"/>
        <listitem open="0" type="815" id="Ddmm4vEn1oBD"/>
        <listitem open="0" type="815" id="OECVsyDXYqlr"/>
        <listitem open="0" type="815" id="k21Gtm7VWY46"/>
        <listitem open="0" type="815" id="eadGLo1byt34"/>
        <listitem open="0" type="815" id="lL2PCuKPX6Ba"/>
        <listitem open="0" type="815" id="IArU80ffaa6d"/>
        <listitem open="0" type="815" id="ZaxS35VQW0K2"/>
        <listitem open="0" type="815" id="yi120aSltU85"/>
       </listitem>
      </listitem>
      <listitem open="1" type="818" id="uvdnvKhQ8Gzw">
       <listitem open="0" type="813" id="vG7ZXBfwD7DN"/>
       <listitem open="0" type="813" id="R1SJCAJ0OFAU"/>
       <listitem open="0" type="813" id="lEa8AfhON7wu">
        <listitem open="0" type="815" id="eDm9NYbPw5QV"/>
        <listitem open="0" type="815" id="2qXztxS32EHp"/>
       </listitem>
       <listitem open="0" type="813" id="LLpqtswtYU6b">
        <listitem open="0" type="815" id="tjoElcVC46GH"/>
        <listitem open="0" type="815" id="5uJM1W1a5Ouu"/>
        <listitem open="0" type="815" id="dEqZFVFKYD0C"/>
        <listitem open="0" type="815" id="Yg85t8H1xA2u"/>
        <listitem open="0" type="815" id="eVFgcTv9I9Df"/>
       </listitem>
       <listitem open="0" type="813" id="RZxPjxJnnprr">
        <listitem open="0" type="815" id="fHWSkwUZZOwF"/>
        <listitem open="0" type="815" id="CDtCaALmEDPs"/>
        <listitem open="0" type="815" id="px4oCD7qXg1d"/>
        <listitem open="0" type="815" id="96ZekaGLA81D"/>
        <listitem open="0" type="815" id="w5bAuQpSzOH9"/>
        <listitem open="0" type="815" id="cvABJ7O5Eprh"/>
        <listitem open="0" type="815" id="ju2t217WPw7a"/>
       </listitem>
      </listitem>
      <listitem open="0" type="813" id="cxUNVy2crBHu">
       <listitem open="0" type="815" id="sKvgIdFvJZ25"/>
       <listitem open="0" type="815" id="f7jvFvA6D3mV"/>
      </listitem>
      <listitem open="0" type="813" id="q4764XrJtgrn">
       <listitem open="0" type="815" id="HcGCPDc8Pgms"/>
       <listitem open="0" type="815" id="7t8g5oEKOUVm"/>
      </listitem>
     </listitem>
     <listitem open="1" type="813" id="r6QHlw4Ral9t">
      <listitem open="0" type="815" id="wgkgLjmXdoxM"/>
      <listitem open="0" type="815" id="r1GUoBoabemN"/>
      <listitem open="0" type="815" id="8dcdFcQfqzdU"/>
      <listitem open="0" type="815" id="OJWEJ7gNwK6c"/>
      <listitem open="0" type="815" id="mxosMyLCE9nW"/>
      <listitem open="0" type="814" id="VPapzHFJ9bqN"/>
      <listitem open="0" type="814" id="vfNmnI1i5Tla"/>
      <listitem open="0" type="815" id="wMvKTB3KCKmy"/>
      <listitem open="0" type="814" id="RaWxvRPMM9s6"/>
      <listitem open="0" type="815" id="AxIqJuxQ6RAV"/>
      <listitem open="0" type="815" id="QGb0e6DDfsq6"/>
      <listitem open="0" type="815" id="7EWmOR7Ln2fE"/>
      <listitem open="0" type="814" id="QGymOqsF6he0"/>
      <listitem open="0" type="815" id="IN7t90kXIEjZ"/>
      <listitem open="0" type="815" id="qdd4lOaK1X10"/>
      <listitem open="0" type="815" id="ZbheSz4GcfKN"/>
      <listitem open="0" type="814" id="RwmXklSiWdHT"/>
      <listitem open="0" type="814" id="tIoPu5qJ9blQ"/>
     </listitem>
     <listitem open="0" type="813" id="aHDU9NKnS1ih"/>
     <listitem open="0" type="813" id="zebiQhZW6A7Z">
      <listitem open="0" type="815" id="WNwhOSpxcXzl"/>
      <listitem open="0" type="815" id="wmu2wzZRKW6i"/>
      <listitem open="0" type="815" id="Tgm8EmMAS53P"/>
     </listitem>
     <listitem open="0" type="813" id="6vEMLbAVCgfc">
      <listitem open="0" type="815" id="47i2mRimI0VB"/>
      <listitem open="0" type="815" id="wIOwP9ASFtUz"/>
      <listitem open="0" type="815" id="OwnLMsSI8qEY"/>
     </listitem>
     <listitem open="1" type="813" id="w9mgAPbqJCmi"/>
    </listitem>
    <listitem open="1" type="827" id="Deployment View"/>
   </listitem>
  </listview>
  <codegeneration>
   <codegenerator language="Python">
    <sourcecode value="self.__name=None&#xa;" id="47i2mRimI0VB"/>
    <sourcecode value="return self.__name&#xa;" id="wIOwP9ASFtUz"/>
    <sourcecode value="self.__name=name&#xa;" id="OwnLMsSI8qEY"/>
    <sourcecode value="self.contingency=contingency&#xa;self.mode=mode&#xa;" id="N8XmvtmdBNbU"/>
    <sourcecode value="return'%s %s'%(self.mode,self.contingency)&#xa;" id="qkBHUVHNXrFO"/>
    <sourcecode value="if self.mode=='positive':&#xa;  if self.contingency.ctype in['!','k+','and','or']:&#xa;    return'!'&#xa;&#xa;  elif self.contingency.ctype in['x','k-']:&#xa;    return'x'&#xa;&#xa;&#xa;elif self.mode=='negative':&#xa;  if self.contingency.ctype in['!','k+','and','or']:&#xa;    return'x'&#xa;&#xa;  elif self.contingency.ctype in['x','k-']:&#xa;    return'!'&#xa;&#xa;&#xa;" id="wVzkJ4h7pqOH"/>
    <sourcecode value="new_type=self.get_ctype()&#xa;return self.contingency.clone(new_type)&#xa;" id="SNwl3FAxi9i2"/>
    <sourcecode value="self.name=name.strip()&#xa;self.domain=domain&#xa;if self.domain:&#xa;  self.domain=self.domain.strip()&#xa;&#xa;self.cid=cid&#xa;self.second_domain=None&#xa;" id="NpCREKBOcYpj"/>
    <sourcecode value="if self.second_domain:&#xa;  return'%s_[%s]_[%s]'%(self.name,self.domain,self.second_domain)&#xa;&#xa;elif self.domain:&#xa;  return'%s_[%s]'%(self.name,self.domain)&#xa;&#xa;return self.name&#xa;" id="E0FKgOllDNKZ"/>
    <sourcecode value="if not self.name==other.name:&#xa;  return False&#xa;&#xa;if self.cid and other.cid and self.cid!=other.cid:&#xa;  return False&#xa;&#xa;return True&#xa;" id="qYQXkPZyPpH3"/>
    <sourcecode value="if self.name&lt;other.name:&#xa;  return-1&#xa;&#xa;elif self.name>other.name:&#xa;  return 1&#xa;&#xa;elif self.name==other.name and self.cid and other.cid:&#xa;  if self.cid&lt;other.cid:&#xa;    return-1&#xa;&#xa;  elif self.cid>other.cid:&#xa;    return 1&#xa;&#xa;&#xa;else:return 0&#xa;" id="ojPEYeFjg252"/>
    <sourcecode value="if not self==other:&#xa;  return False&#xa;&#xa;if self.domain!=other.domain:&#xa;return False if self.second_domain!=other.second_domain:&#xa;  return False&#xa;&#xa;return True" id="m3WR4aTBbeFp"/>
    <sourcecode value="self.not_in_products=[]&#xa;self.produced_in_more=:&#xa;&#xa;&#xa;self.not_applied_contingencies=[]&#xa;" id="WNwhOSpxcXzl"/>
    <sourcecode value="destroyed_states=reaction_pool.get_destroyed_states()&#xa;contingency_states=contingency_pool.get_required_states()&#xa;product_states=reaction_pool.get_product_states()&#xa;required_states=contingency_states.union(destroyed_states)&#xa;self.not_in_products=required_states-product_states&#xa;return self.not_in_products&#xa;" id="wmu2wzZRKW6i"/>
    <sourcecode value="result=[str(react)for react in self.not_applied_contingencies]&#xa;return set(result)" id="Tgm8EmMAS53P"/>
    <sourcecode value="self.xls_tables=parse_rxncon(input_data)&#xa;" id="ajx2oyRrDjbb"/>
    <sourcecode value="output_file=open(output_path,'w')&#xa;output_file.write(bngl_src)" id="nPu16TaxShWo"/>
    <sourcecode value="self.war=RxnconWarnings()&#xa;self.df=DomainFactory()&#xa;self.xls_tables=parse_rxncon(xls_tables)&#xa;reaction_factory=ReactionFactory(self.xls_tables)&#xa;self.molecule_pool=reaction_factory.molecule_pool&#xa;self.reaction_pool=reaction_factory.reaction_pool&#xa;contingency_factory=ContingencyFactory(self.xls_tables)&#xa;self.contingency_pool=contingency_factory.parse_contingencies()&#xa;self.complex_pool=ComplexPool()&#xa;self.create_complexes()&#xa;self.update_contingencies()&#xa;" id="wgkgLjmXdoxM"/>
    <sourcecode value="result=''&#xa;react_keys=[(self.reaction_pool[reaction].rid,reaction)for reaction in self.reaction_pool.keys()]&#xa;for reaction in sorted(react_keys):&#xa;  result+=reaction[1]&#xa;  if self.contingency_pool.has_key(reaction[1]):&#xa;    cont_root=self.contingency_pool[reaction[1]]&#xa;    all_cont=cont_root.get_children()&#xa;    for cont in all_cont:&#xa;      later=[]&#xa;      if cont.ctype in['or','and']or'--'in cont.ctype:&#xa;        later.append(cont)&#xa;&#xa;      else:&#xa;        result+='; %s'%str(cont)&#xa;&#xa;      for cont in later:&#xa;        result+='\n%s; %s %s'%(cont.target_reaction,cont.ctype,str(cont.state))&#xa;&#xa;&#xa;&#xa;  result=result.strip()+'\n'&#xa;&#xa;return result&#xa;" id="r1GUoBoabemN"/>
    <sourcecode value="bools=self.contingency_pool.get_top_booleans()&#xa;for bool_cont in bools:&#xa;  builder=ComplexBuilder()&#xa;  alter_comp=builder.build_positive_complexes_from_boolean(bool_cont)&#xa;  self.complex_pool[str(bool_cont.state)]=alter_comp&#xa;&#xa;" id="wMvKTB3KCKmy"/>
    <sourcecode value="req_dict=:&#xa;&#xa;&#xa;for rname in self.reaction_pool.keys():&#xa;  req_dict[rname]=[]&#xa;  for reaction in self.reaction_pool[rname]:&#xa;    req_dict[rname].append(reaction.get_contingencies())&#xa;&#xa;&#xa;return req_dict&#xa;" id="7EWmOR7Ln2fE"/>
    <sourcecode value="if not self.contingency_pool.has_key(reaction_name):&#xa;  return[]&#xa;&#xa;cont_root=self.contingency_pool[reaction_name]&#xa;for cont in cont_root.children:&#xa;  if cont.state.type=='Boolean':&#xa;    if self.complex_pool.has_key(str(cont.state)):&#xa;      return self.complex_pool[str(cont.state)]&#xa;&#xa;&#xa;&#xa;" id="AxIqJuxQ6RAV"/>
    <sourcecode value="contingencies=[]&#xa;if self.contingency_pool.has_key(container.name):&#xa;  for cont in self.contingency_pool[container.name].children:&#xa;    if cont.children==[]:&#xa;      contingencies.append(cont)&#xa;&#xa;&#xa;&#xa;cap=ContingencyApplicator(self.war)&#xa;for cont in contingencies:&#xa;cap.apply_on_container(container,cont)" id="mxosMyLCE9nW"/>
    <sourcecode value="modifications=self.contingency_pool.get_modification_contingencies()&#xa;if modifications:&#xa;  for cont in modifications:&#xa;    if cont.state.has_bd_domain():&#xa;      available=self.reaction_pool.find_modification_product(cont.state)&#xa;      available=sorted(available,key=lambda state:state.components[0].name)&#xa;      default_domain_present=False&#xa;      for state in available:&#xa;        if state.has_bd_domain():&#xa;          default_domain_present=True&#xa;&#xa;&#xa;      if not default_domain_present:&#xa;        if len(available)>1:&#xa;        self.war.produced_in_more[cont]=available cont.state=available[0]elif len(available)==1:&#xa;          cont.state=state&#xa;&#xa;        else:&#xa;          self.war.not_in_products.append(cont)&#xa;&#xa;&#xa;&#xa;&#xa;&#xa;relocalisations=self.contingency_pool.get_relocalisation_contingencies()&#xa;for cont in relocalisations:&#xa;  if not cont.state.not_modifier:&#xa;    available=self.reaction_pool.find_relocalisation_product(cont.state)&#xa;    if available:&#xa;      if available[0].modifier==cont.state.modifier:&#xa;        cont.state.not_modifier=available[0].not_modifier&#xa;&#xa;      else:&#xa;        cont.state.not_modifier=available[0].modifier&#xa;&#xa;&#xa;&#xa;&#xa;" id="qdd4lOaK1X10"/>
    <sourcecode value="pass&#xa;" id="ZbheSz4GcfKN"/>
    <sourcecode value="pass&#xa;" id="QGb0e6DDfsq6"/>
    <sourcecode value="reaction_factory=ReactionFactory(states_list)&#xa;missing_molecule_pool=reaction_factory.molecule_pool&#xa;missing_reaction_pool=reaction_factory.reaction_pool&#xa;self.reaction_pool.update_pool(missing_reaction_pool)&#xa;self.molecule_pool+=missing_molecule_pool&#xa;self.war.not_in_products=[]&#xa;" id="8dcdFcQfqzdU"/>
    <sourcecode value="pass&#xa;" id="OJWEJ7gNwK6c"/>
    <sourcecode value="self.war.calculate_missing_states(self.reaction_pool,self.contingency_pool)&#xa;if add_missing_reactions:&#xa;  self.add_missing_reactions(list(self.war.not_in_products))&#xa;&#xa;if add_translation:&#xa;  self.add_translation()&#xa;&#xa;for react_container in self.reaction_pool:&#xa;  complexes=[]&#xa;  if add_complexes:&#xa;    complexes=self.get_complexes(react_container.name)&#xa;&#xa;  ComplexApplicator(react_container,complexes).apply_complexes()&#xa;  if add_contingencies:&#xa;    self.apply_contingencies(react_container)&#xa;&#xa;  self.update_reactions()&#xa;  for reaction in react_container:&#xa;    reaction.run_reaction()" id="IN7t90kXIEjZ"/>
    <sourcecode value="self.war=war&#xa;" id="7tqNx2cF0HNl"/>
    <sourcecode value="if(cont.state.type=='Association'or cont.state.type==&quot;Intraprotein&quot;)and cont.ctype=='x':&#xa;  mol.add_binding_site(cont.state,side)&#xa;&#xa;elif cont.state.type=='Covalent Modification'and cont.ctype=='!':&#xa;  mol.add_modification(cont.state)&#xa;&#xa;elif cont.state.type=='Covalent Modification'and cont.ctype=='x':&#xa;  mol.add_modification_site(cont.state)&#xa;&#xa;elif cont.state.type=='Relocalisation':&#xa;  mol.localisation=cont.state&#xa;  if cont.ctype=='!':&#xa;    cont.state.loc=True&#xa;&#xa;&#xa;" id="z29zJWiTtx7J"/>
    <sourcecode value="add_partner=True&#xa;for state in mols[0].binding_sites:&#xa;  if state==cont.state:&#xa;    dom_cont=cont.state.get_component(mols[0].name).domain&#xa;    dom_side=state.get_component(mols[0].name).domain&#xa;    if dom_side==dom_cont:&#xa;    add_partner=False&#xa;&#xa;for comp_cont in cont.state.components:&#xa;  for comp_tochange in reaction.to_change.components:&#xa;    if comp_cont.exact_compare(comp_tochange):&#xa;    add_partner=False&#xa;&#xa;new_mols=[]&#xa;for mol in mols:&#xa;  occupied_doms=mol.get_domains('binding',True)&#xa;  if component.domain not in occupied_doms:&#xa;    new_mols.append(mol)&#xa;&#xa;&#xa;mols=new_mols&#xa;if not mols:&#xa;  add_partner=False&#xa;  if self.war:&#xa;    self.war.not_applied_contingencies.append(reaction)&#xa;&#xa;&#xa;if add_partner:&#xa;  mols[0].binding_partners.append(cont.state)&#xa;  mol_ob=Molecule(component.name)&#xa;  mol_ob.binding_partners.append(cont.state)&#xa;  compl.molecules.append(mol_ob)&#xa;&#xa;" id="ZoE5PzsWQ7Xp"/>
    <sourcecode value="component=cont.state.components[0]&#xa;left=reaction.get_substrate_complex('L')&#xa;right=reaction.get_substrate_complex('R')&#xa;left_right=reaction.get_substrate_complex('LR')&#xa;if right.has_molecule(component.name)and not cont.state==reaction.to_change:&#xa;  side=right.side&#xa;  mol=right.get_molecules(component.name,component.cid)&#xa;  new_mols=[]&#xa;  occupied_doms=mol[0].get_domains('binding',True)&#xa;  if component.domain not in occupied_doms:&#xa;    new_mols.append(mol)&#xa;&#xa;  if new_mols:&#xa;    mol[0].binding_partners.append(cont.state)&#xa;&#xa;&#xa;" id="OEV0pbNJf4Mv"/>
    <sourcecode value="component1=cont.state.components[0]&#xa;component2=cont.state.components[1]&#xa;left=reaction.get_substrate_complex('L')&#xa;right=reaction.get_substrate_complex('R')&#xa;left_right=reaction.get_substrate_complex('LR')&#xa;if left_right:&#xa;  mols1=left_right.get_molecules(component1.name,component1.cid)&#xa;  mols2=left_right.get_molecules(component2.name,component2.cid)&#xa;  if mols1 and mols2:&#xa;    pass&#xa;&#xa;  if mols1:&#xa;    self.add_molecule_to_complex(mols1,cont,component2,left_right,reaction)&#xa;&#xa;  elif mols2:&#xa;    self.add_molecule_to_complex(mols2,cont,component1,left_right,reaction)&#xa;&#xa;&#xa;elif left and right:&#xa;  if((left.has_molecule(component1.name)and right.has_molecule(component2.name))\&#xa;  or(left.has_molecule(component2.name)and right.has_molecule(component1.name)))\and not cont.state==reaction.to_change:if component1.name in[reaction.left_reactant.name,reaction.right_reactant.name]\and component2.name in[reaction.left_reactant.name,reaction.right_reactant.name]:&#xa;    reaction.join_substrate_complexes(cont.state)&#xa;&#xa;  else:&#xa;    if component1.name==reaction.left_reactant.name\&#xa;    or component2.name==reaction.left_reactant.name:&#xa;      self._add_components_to_complex(left,component1,component2,cont,reaction)&#xa;&#xa;    else:&#xa;    self._add_components_to_complex(right,component1,component2,cont,reaction)&#xa;  else:&#xa;    for compl in reaction.substrat_complexes:&#xa;      self._add_components_to_complex(compl,component1,component2,cont,reaction)&#xa;&#xa;&#xa;&#xa;" id="VRMwxjTDIojL"/>
    <sourcecode value="mols1=compl.get_molecules(component1.name,component1.cid)&#xa;mols2=compl.get_molecules(component2.name,component2.cid)&#xa;if mols1 and mols2:&#xa;  pass&#xa;&#xa;if mols1:&#xa;  self.add_molecule_to_complex(mols1,cont,component2,compl,reaction)&#xa;&#xa;elif mols2:&#xa;  self.add_molecule_to_complex(mols2,cont,component1,compl,reaction)&#xa;&#xa;" id="34exG8cafETS"/>
    <sourcecode value="if cont.state.type=='Association':&#xa;  side=compl.side&#xa;  for component in cont.state.components:&#xa;    mols=compl.get_molecules(component.name,component.cid)&#xa;    if mols:&#xa;      self.apply_on_molecule(mols[0],cont,side)&#xa;&#xa;&#xa;&#xa;else:&#xa;  component=cont.state.components[0]&#xa;  mols=compl.get_molecules(component.name,component.cid)&#xa;  if mols:&#xa;    self.apply_on_molecule(mols[0],cont)&#xa;&#xa;&#xa;" id="aA1cZenXG56S"/>
    <sourcecode value="for compl in reaction.substrat_complexes:&#xa;  self.apply_on_complex(compl,cont)&#xa;&#xa;" id="nm2f2hGjMEzm"/>
    <sourcecode value="highest_subrate=container.highest_subrate&#xa;if highest_subrate==0:&#xa;  num1='%s_1'%container.rid&#xa;  num2='%s_2'%container.rid&#xa;&#xa;else:&#xa;  num1='%s_%s'%(container.rid,str(highest_subrate+1))&#xa;  num2='%s_%s'%(container.rid,str(highest_subrate+2))&#xa;&#xa;if cont.ctype in['x','!']:&#xa;  for reaction in container:&#xa;    if reaction.definition['Reversibility']=='reversible':&#xa;      reaction.rate.update_function(cont,False,num1,num2)&#xa;&#xa;    else:&#xa;      rate_id=reaction.rate.get_ids()[0]&#xa;      reaction.rate.update_function(cont,False,rate_id,None)&#xa;&#xa;&#xa;&#xa;elif'k'in cont.ctype:&#xa;  for reaction in container:&#xa;    reaction.rate.update_function(cont,True,num1,num2)&#xa;&#xa;&#xa;" id="2rbqfP7OtHaS"/>
    <sourcecode value="single_id=lambda container,old_id,subrate:'%s_%s'%(container.rid,str(int(old_id.split('_')[1])+subrate))&#xa;if keep_old:&#xa;  if subrate==0:&#xa;    return['%s_1'%container.rid,None]&#xa;&#xa;  else:&#xa;    old_ids=reaction.rate.get_ids()&#xa;    if len(old_ids)==1:&#xa;      return[old_ids[0],None]&#xa;&#xa;    else:&#xa;      return old_ids&#xa;&#xa;&#xa;&#xa;else:&#xa;  if subrate==0:&#xa;    return['%s_2'%container.rid,None]&#xa;&#xa;  else:&#xa;    old_ids=reaction.rate.get_ids()&#xa;    if len(old_ids)==1:&#xa;      return[single_id(container,old_ids[0],subrate),None]&#xa;&#xa;    else:&#xa;      return[single_id(container,old_ids[0],subrate),single_id(container,old_ids[1],subrate)]&#xa;&#xa;&#xa;&#xa;" id="IRZ8q4QEQwvP"/>
    <sourcecode value="if cont.state.type=='Input':&#xa;  self.apply_input_on_container(container,cont)&#xa;&#xa;elif cont.ctype in['x','!']:&#xa;  for reaction in container:&#xa;    if cont.state.type=='Association'and cont.ctype=='!':&#xa;      self.apply_positive_association(reaction,cont)&#xa;&#xa;    elif cont.state.type==&quot;Intraprotein&quot;and cont.ctype=='!':&#xa;      self.apply_positive_intraprotein(reaction,cont)&#xa;&#xa;    else:&#xa;      self.apply_on_reaction(reaction,cont)&#xa;&#xa;&#xa;&#xa;elif'k'in cont.ctype:&#xa;  temp=[]&#xa;  pos_cont=ContingencyWrapper(cont,'positive').get_contingency()&#xa;  neg_cont=ContingencyWrapper(cont,'negative').get_contingency()&#xa;  subrate=container.highest_subrate&#xa;  for reaction in container:&#xa;  temp.append(reaction.clone())temp2=[]&#xa;  for reaction in container:&#xa;    reaction=reaction.clone()&#xa;    if cont.state.type=='Association':&#xa;      self.apply_positive_association(reaction,pos_cont)&#xa;&#xa;    else:&#xa;      self.apply_on_reaction(reaction,pos_cont)&#xa;&#xa;    new_rate_ids=self.get_rate_ids(reaction,container,subrate,True)&#xa;    reaction.rate.update_name(new_rate_ids[0],new_rate_ids[1])&#xa;    temp2.append(reaction)&#xa;&#xa;  container.empty()&#xa;  for reaction in temp2:&#xa;    container.add_reaction(reaction)&#xa;&#xa;  for reaction in temp:&#xa;  self.apply_on_reaction(reaction,neg_cont)container.add_reaction(reaction)new_rate_ids=self.get_rate_ids(reaction,container,subrate,False)reaction.rate.update_name(new_rate_ids[0],new_rate_ids[1]" id="1s77ewvaD1b8"/>
    <sourcecode value="dict.__init__(self)&#xa;self.xls_tables=xls_tables&#xa;self.pool=ContingencyPool()&#xa;" id="QyAjBWrUKkgM"/>
    <sourcecode value="parse_later=[]&#xa;complexes=[]&#xa;for row in self.xls_tables['contingency_list']:&#xa;result=self.parse_contingency(row)if result and result[0]=='no parent':&#xa;  parse_later.append(result[1])&#xa;&#xa;elif result and result[0]=='complex':&#xa;  complexes.append(result[1])&#xa;&#xa;for row in parse_later:&#xa;  self.parse_contingency(row)&#xa;&#xa;return self.pool&#xa;" id="xhfFPLbqKnaD"/>
    <sourcecode value="for child in children:&#xa;  if child.ctype==cont.ctype and str(child.state)==str(cont.state):&#xa;    return True&#xa;&#xa;&#xa;return False&#xa;" id="yyF1Q2ELjub8"/>
    <sourcecode value="reaction=row['Target']&#xa;ctype=row['Contingency']&#xa;if'--'in ctype:&#xa;  sid=ctype&#xa;&#xa;else:&#xa;  sid=None&#xa;&#xa;state=get_state(row['Modifier'],sid)&#xa;cont=self.create_contingency(reaction,ctype,state)&#xa;if not reaction.startswith('&lt;'):&#xa;  self.pool.setdefault(reaction,Contingency(reaction))&#xa;  self.pool[reaction].add_child(cont)&#xa;&#xa;elif reaction.startswith('&lt;'):&#xa;  parents=self.find_parent(cont)&#xa;  if not parents:&#xa;    return'no parent',row&#xa;&#xa;  for parent in parents:&#xa;    if not self.check_cont_in_children(cont,parent.children):&#xa;      parent.add_child(cont)&#xa;&#xa;&#xa;&#xa;" id="TwtJmJGCla37"/>
    <sourcecode value="react=reaction_string.split('_')&#xa;component1=Component(react[0])&#xa;if react[1].startswith('['):&#xa;  component2=Component(react[3])&#xa;&#xa;else:&#xa;  component2=Component(react[2])&#xa;&#xa;return component1,component2&#xa;" id="2ISltTsTUH5e"/>
    <sourcecode value="bools=[]&#xa;for reaction in self.pool:&#xa;  bools+=self.get_booleans(self.pool[reaction].children)&#xa;&#xa;parents=[]&#xa;for cont in bools:&#xa;  if cont.is_parent(contingency):&#xa;    parents.append(cont)&#xa;&#xa;&#xa;if parents:&#xa;  return parents&#xa;&#xa;return None&#xa;" id="ZPH1fKfdPgrC"/>
    <sourcecode value="bools=[]&#xa;for cont in cont_list:&#xa;  if cont.state.type=='Boolean':&#xa;    bools.append(cont)&#xa;    if cont.children:&#xa;      bools+=self.get_booleans(cont.children)&#xa;&#xa;&#xa;&#xa;return bools&#xa;" id="8G0XurhrceQj"/>
    <sourcecode value="if str(state).startswith('['):&#xa;  state.state_str.replace('[','xXx').replace(']','xXx')&#xa;&#xa;else:&#xa;  state.state_str.replace('[','').replace(']','')&#xa;&#xa;return Contingency(target_reaction,ctype,state)" id="9C6lqVSeQ6hS"/>
    <sourcecode value="dict.__init__(self)&#xa;pass&#xa;" id="V1lBQp3K9PPP"/>
    <sourcecode value="result=[]&#xa;for root in self.values():&#xa;  leafs=root.get_children()&#xa;  for leaf in leafs:&#xa;    if leaf.state.type=='Boolean':&#xa;      result.append(leaf)&#xa;&#xa;&#xa;&#xa;return result&#xa;" id="YBXNKG3nHozf"/>
    <sourcecode value="result=[]&#xa;for root in self.values():&#xa;  for leaf in root.children:&#xa;    if leaf.state.type=='Boolean':&#xa;      result.append(leaf)&#xa;&#xa;&#xa;&#xa;return result&#xa;" id="AiGLBvPh6x2P"/>
    <sourcecode value="for root in self.values():&#xa;  for child in root.children:&#xa;    if cont==child:&#xa;      root.children.remove(cont)&#xa;&#xa;&#xa;&#xa;" id="TEyxoiGwRVGa"/>
    <sourcecode value="result=[]&#xa;for root in self.values():&#xa;  children=root.get_leafs()&#xa;  for cont in children:&#xa;    if cont.ctype in['!','k+','k-','x']or cont.inherited_ctype in['!','k+','k-','x']:&#xa;      if cont.state.type in['Association','Covalent Modification','Relocalisation','Intraprotein']:&#xa;        result.append(cont.state)&#xa;&#xa;&#xa;&#xa;&#xa;return set(result)&#xa;" id="Y6cxbsX0YmV8"/>
    <sourcecode value="result=[]&#xa;for root in self.values():&#xa;  children=root.get_leafs()&#xa;  for cont in children:&#xa;    if cont.ctype in['!','k+','k-']or cont.inherited_ctype in['!','k+','k-']:&#xa;      if cont.state.type in[kind]:&#xa;        result.append(cont)&#xa;&#xa;&#xa;&#xa;&#xa;return set(result)&#xa;" id="hrtZhjFDprBP"/>
    <sourcecode value="return self.get_kind_contingencies(&quot;Covalent Modification&quot;)&#xa;" id="Wn1KeAjKq4YH"/>
    <sourcecode value="def get_relocalisation_contingencies(self):&#xa;  return self.get_kind_contingencies(&quot;Relocalisation&quot;)&#xa;&#xa;" id="LRFREnFlaE5D"/>
    <sourcecode value="self.target_reaction=target_reaction&#xa;self.ctype=str(ctype).lower()if ctype else None&#xa;self.state=state&#xa;self.children=[]&#xa;self.inherited_ctype=None&#xa;" id="K2TknPpOGpyU"/>
    <sourcecode value="return&quot;%s %s&quot;%(self.ctype,self.state)&#xa;" id="sbb7OYZ2soiW"/>
    <sourcecode value="if self.target_reaction==other.target_reaction:&#xa;  if self.ctype==other.ctype:&#xa;    if self.state==other.state:&#xa;    return True&#xa;&#xa;return False&#xa;" id="czA2QxDIWmNv"/>
    <sourcecode value="return str(self).__hash__()&#xa;" id="Oj0uVOnoJkx2"/>
    <sourcecode value="if len(self.children)==0:&#xa;  return False&#xa;&#xa;return True&#xa;" id="WFnqgJY22XuV"/>
    <sourcecode value="if not node:&#xa;  node=self&#xa;&#xa;result=0&#xa;if not node.has_children:&#xa;  return 0&#xa;&#xa;for child in node.children:&#xa;  if not child.has_children:&#xa;    result+=1&#xa;&#xa;  else:&#xa;  result+=self.count_leafs(child)&#xa;return result&#xa;" id="9YhXjeoGrZ4V"/>
    <sourcecode value="if not node:&#xa;  node=self&#xa;&#xa;result=[]&#xa;if not node.has_children:&#xa;  return[]&#xa;&#xa;for child in node.children:&#xa;  if not child.has_children:&#xa;    result+=[child]&#xa;&#xa;  else:&#xa;  result+=self.get_leafs(child)&#xa;return result&#xa;" id="rIOgrR9j2cb8"/>
    <sourcecode value="result=[]&#xa;if not node:&#xa;  node=self&#xa;&#xa;for child in node.children:&#xa;  result+=[child]&#xa;  result+=self.get_children(child)&#xa;&#xa;return result&#xa;" id="7Pl91KFzHK2q"/>
    <sourcecode value="if self.inherited_ctype and self.inherited_ctype!='none':&#xa;  contingency.inherited_ctype=self.inherited_ctype&#xa;&#xa;else:&#xa;  contingency.inherited_ctype=self.ctype&#xa;&#xa;self.children.append(contingency)&#xa;" id="3b3Iu58QeMUz"/>
    <sourcecode value="if str(self.state)==contingency.target_reaction:&#xa;  return True&#xa;&#xa;else:&#xa;  return False&#xa;&#xa;" id="ZiAB4c8ka8KQ"/>
    <sourcecode value="if ctype:&#xa;  new_type=ctype&#xa;&#xa;else:&#xa;  new_type=copy.deepcopy(self.ctype)&#xa;&#xa;new_cont=Contingency(\&#xa;copy.deepcopy(self.target_reaction),\new_type,copy.deepcopy(self.state))new_cont.inherited_ctype=copy.deepcopy(self.inherited_ctype)&#xa;for child in self.children:&#xa;  new_cont.add_child(copy.deepcopy(child))&#xa;&#xa;return new_cont" id="2ljcs107bzts"/>
    <sourcecode value="self.name=None&#xa;self.rid=None&#xa;self.rtype=None&#xa;self.definition=None&#xa;self.left_reactant=None&#xa;self.right_reactant=None&#xa;self.substrat_complexes=[]&#xa;self.product_complexes=[]&#xa;self.conditions=None&#xa;self.to_change=None&#xa;self.to_change_pt=None&#xa;self.rate=None&#xa;" id="Kg4hurUhPNER"/>
    <sourcecode value="return self.name&#xa;" id="7GYoaftuJwaE"/>
    <sourcecode value="print&quot;;print'Substrates:'&#xa;for subs in self.substrat_complexes:&#xa;  subs.inspect()&#xa;&#xa;" id="bPEaOWJTnpFL"/>
    <sourcecode value="pass&#xa;" id="ya6vdLwEi9p4"/>
    <sourcecode value="new=self.__class__()&#xa;new.name=copy.deepcopy(self.name)&#xa;new.rid=copy.deepcopy(self.rid)&#xa;new.rtype=self.rtype&#xa;new.definition=self.definition&#xa;new.left_reactant=self.left_reactant&#xa;new.right_reactant=self.right_reactant&#xa;new.substrat_complexes=copy.deepcopy(self.substrat_complexes)&#xa;new.product_complexes=copy.deepcopy(self.product_complexes)&#xa;new.conditions=copy.deepcopy(self.conditions)&#xa;new.to_change=copy.deepcopy(self.to_change)&#xa;new.rate=copy.deepcopy(self.rate)&#xa;return new&#xa;" id="oAke0krwIwrv"/>
    <sourcecode value="pass&#xa;" id="IkI8kS5WaoAa"/>
    <sourcecode value="pass&#xa;" id="l3TkZRepAuxu"/>
    <sourcecode value="return self.to_change&#xa;" id="7rxHltA6sZyf"/>
    <sourcecode value="result=[]&#xa;for compl in self.substrat_complexes:&#xa;  result+=compl.get_contingencies()&#xa;&#xa;scont=Contingency(None,'x',self.get_sp_state())&#xa;result=set(result)&#xa;result=result-set([scont])&#xa;for cont in result:&#xa;  cont.target_reaction=self.name&#xa;&#xa;return list(result)&#xa;" id="C23oiEyn3u3m"/>
    <sourcecode value="all_cont=set(self.get_contingencies())&#xa;return list(all_cont-set(common_cont))&#xa;" id="Ha6CAvnMvoAb"/>
    <sourcecode value="for compl in self.substrat_complexes:&#xa;  if compl.side==side:&#xa;    return compl&#xa;&#xa;&#xa;" id="E4eAqplqw8tv"/>
    <sourcecode value="if state.type!='Association':print'WARNING',state.type&#xa;left=self.get_substrate_complex('L')&#xa;right=self.get_substrate_complex('R')&#xa;if not left and right:print'WARNING'&#xa;state_comp=state.components&#xa;if len(state_comp):&#xa;  if state_comp[0].name==state_comp[1].name:&#xa;    state_comp=[state.components[0]]&#xa;&#xa;&#xa;for compl in[left,right]:&#xa;  for compon in state_comp:&#xa;    mols=compl.get_molecules(compon.name,compon.cid)&#xa;    if mols:&#xa;      mols[0].binding_partners.append(state)&#xa;&#xa;&#xa;&#xa;new_comp=left.complex_addition(right)&#xa;new_comp.side='LR'&#xa;self.substrat_complexes=[new_comp]&#xa;" id="vCZpISkn9PqV"/>
    <sourcecode value="return Contingency(self.name,'!',self.to_change)&#xa;" id="dlbm8PIYYdc7"/>
    <sourcecode value="return Contingency(self.name,'x',self.to_change)&#xa;" id="yo7Vz7JcqsNz"/>
    <sourcecode value="return[]&#xa;" id="0Tna5xU1jZXi"/>
    <sourcecode value="return str(self.rid).split('_')[0]&#xa;" id="1dHFE1kCUVmX"/>
    <sourcecode value="self.rate=None&#xa;self.frate=None&#xa;self.rrate=None&#xa;self._rate_names=[]&#xa;self._special_rate_names=[]&#xa;if reaction:&#xa;  self.set_basic_rates(reaction)&#xa;&#xa;" id="2CxteQHl0ggt"/>
    <sourcecode value="return str(self.get_rates_for_reaction())&#xa;" id="RywRedINXdKd"/>
    <sourcecode value="if reaction.definition['Reversibility']=='irreversible':&#xa;  self.rate='k%s'%reaction.rid&#xa;  self._rate_names=[self.rate]&#xa;&#xa;else:&#xa;  self.frate='kf%s'%reaction.rid&#xa;  self.rrate='kr%s'%reaction.rid&#xa;  self._rate_names=[self.frate,self.rrate]&#xa;&#xa;" id="P12y2iCTg8sJ"/>
    <sourcecode value="if self.rate:&#xa;  return[self.rate]&#xa;&#xa;else:&#xa;  return[self.frate,self.rrate]&#xa;&#xa;" id="mP6RVwkD5QSp"/>
    <sourcecode value="rates=[]&#xa;for rate in self._rate_names:&#xa;  new_id=re.sub('kr|kf|k','',rate)&#xa;  if new_id not in rates:&#xa;    rates.append(new_id)&#xa;&#xa;&#xa;return rates&#xa;" id="3cTgigLS5PtY"/>
    <sourcecode value="rates_dict=:&#xa;&#xa;&#xa;for rate in self._rate_names:&#xa;  rates_dict[rate]=1&#xa;&#xa;for rate in self._special_rate_names:&#xa;  rates_dict[rate]=0&#xa;&#xa;return rates_dict&#xa;" id="BWRWwzi0b9eH"/>
    <sourcecode value="if self.rate:&#xa;  new_rate='k%s'%new_num&#xa;  self.rate=self.rate.replace(self._rate_names[0],new_rate)&#xa;  self._rate_names[0]=new_rate&#xa;  if new_num2 and len(self._rate_names)>1:&#xa;    new_rate='k%s'%new_num2&#xa;    self.rate=self.rate.replace(self._rate_names[1],new_rate)&#xa;    self._rate_names[1]=new_rate&#xa;&#xa;&#xa;else:&#xa;  new_frate='kf%s'%new_num&#xa;  new_rrate='kr%s'%new_num&#xa;  self.frate=self.frate.replace(self._rate_names[0],new_frate)&#xa;  self.rrate=self.rrate.replace(self._rate_names[1],new_rrate)&#xa;  self._rate_names[0]=new_frate&#xa;  self._rate_names[1]=new_rrate&#xa;  if new_num2 and len(self._rate_names)>2:&#xa;    new_frate='kf%s'%new_num2&#xa;    new_rrate='kr%s'%new_num2&#xa;    if len(self._rate_names)==3:&#xa;      self.rrate=self.rrate.replace(self._rate_names[2],new_rrate)&#xa;      self._rate_names[2]=new_rrate&#xa;&#xa;    elif len(self._rate_names)==4:&#xa;      self.frate=self.frate.replace(self._rate_names[2],new_frate)&#xa;      self.rrate=self.rrate.replace(self._rate_names[3],new_rrate)&#xa;      self._rate_names[2]=new_frate&#xa;      self._rate_names[3]=new_rrate&#xa;&#xa;&#xa;&#xa;" id="OIhnzVX80wcw"/>
    <sourcecode value="special='k_%s'%contingency.state.components[0].name&#xa;self._special_rate_names=[special]&#xa;if is_switch:&#xa;  if self.rate:&#xa;    self.rate='k%s*(1-%s)+k%s*%s'%(num2,special,num1,special)&#xa;    self._rate_names=['k%s'%num1,'k%s'%num2]&#xa;&#xa;  else:&#xa;    self.frate='kf%s*(1-%s)+kf%s*%s'%(num2,special,num1,special)&#xa;    self.rrate='kr%s*(1-%s)+kr%s*%s'%(num2,special,num1,special)&#xa;    self._rate_names=['kf%s'%num1,'kr%s'%num1,'kf%s'%num2,'kr%s'%num2]&#xa;&#xa;&#xa;else:&#xa;  if self.rate:&#xa;  if contingency.ctype=='x':&#xa;    self.rate='k%s*(1-%s)'%(num1,special)&#xa;&#xa;  elif contingency.ctype=='!':&#xa;    self.rate='k%s*%s'%(num1,special)&#xa;&#xa;  self._rate_names=['k%s'%num1]&#xa;  else:&#xa;    if contingency.ctype=='x':&#xa;      self.frate='kf%s*(1-%s)'%(num2,special)&#xa;      self.rrate='kr%s*(1-%s)+kr%s*%s'%(num2,special,num1,special)&#xa;      self._rate_names=['kf%s'%num1,'kr%s'%num1,'kr%s'%num2]&#xa;&#xa;    elif contingency.ctype=='!':&#xa;      self.frate='kf%s*%s'%(num1,special)&#xa;      self.rrate='kr%s*(1-%s)+kr%s*%s'%(num2,special,num1,special)&#xa;&#xa;    self._rate_names=['kf%s'%num1,'kr%s'%num1,'kr%s'%num2]" id="4TjbwpTyP3E7"/>
    <sourcecode value="self.parse_reactions(imp)&#xa;" id="eDm9NYbPw5QV"/>
    <sourcecode value="if type(imp)==dict:&#xa;  rf=ReactionFactoryFromDict(imp)&#xa;&#xa;elif type(imp)==list:&#xa;  rf=ReactionFactoryFromList(imp)&#xa;&#xa;self.definitions=rf.definitions&#xa;self.reaction_pool=rf.reaction_pool&#xa;self.molecule_pool=rf.molecule_pool" id="2qXztxS32EHp"/>
    <sourcecode value="self.definitions=ReactionDefinitions(xls_tables)&#xa;self.reaction_pool=ReactionPool()&#xa;self.molecule_pool=MoleculePool()&#xa;self.parse_reactions(xls_tables)&#xa;" id="tjoElcVC46GH"/>
    <sourcecode value="for row_id,row in enumerate(xls_tables['reaction_list']):&#xa;  container=ReactionContainer()&#xa;  container.name=row['Reaction[Full]']&#xa;  container.rid=row_id+1&#xa;  container.rtype=row['ReactionType']&#xa;  reaction=self.get_reaction_object(row)&#xa;  reaction.rid=row_id+1&#xa;  reaction.rate=Rate(reaction)&#xa;  container.add_reaction(reaction)&#xa;  self.reaction_pool[container.name]=container&#xa;  self.molecule_pool.append(reaction.left_reactant)&#xa;  self.molecule_pool.append(reaction.right_reactant)&#xa;&#xa;" id="eVFgcTv9I9Df"/>
    <sourcecode value="if reaction.rtype=='ipi':&#xa;  mol=Molecule(row['ComponentA[Name]'])&#xa;  mol.is_reactant=True&#xa;  reaction.left_reactant=mol&#xa;  reaction.right_reactant=mol&#xa;&#xa;else:&#xa;  reaction.left_reactant=Molecule(row['ComponentA[Name]'])&#xa;  reaction.left_reactant.is_reactant=True&#xa;  reaction.right_reactant=Molecule(row['ComponentB[Name]'])&#xa;  reaction.right_reactant.is_reactant=True&#xa;&#xa;" id="5uJM1W1a5Ouu"/>
    <sourcecode value="r_type=row['ReactionType'].lower()&#xa;categories_dict=self.definitions.categories_dict&#xa;if r_type in categories_dict['Covalent Modification']:&#xa;  reaction=Modification()&#xa;&#xa;elif r_type in categories_dict['Association']:&#xa;  reaction=Interaction()&#xa;&#xa;elif r_type in categories_dict['Synthesis/Degradation']:&#xa;  reaction=SyntDeg()&#xa;&#xa;elif r_type in categories_dict['Relocalisation']:&#xa;  reaction=Relocalisation()&#xa;&#xa;reaction.rtype=r_type&#xa;reaction.name=row['Reaction[Full]']&#xa;if self.definitions.has_key(r_type):&#xa;  reaction.definition=self.definitions[r_type]&#xa;&#xa;else:&#xa;raise TypeError('No reactio type %s.')%r_type self.add_reactants(reaction,row)&#xa;return reaction&#xa;" id="dEqZFVFKYD0C"/>
    <sourcecode value="r_type=row['ReactionType'].lower()&#xa;categories_dict=self.definitions.categories_dict&#xa;reaction=self.get_preliminary_reaction(row)&#xa;if r_type in categories_dict['Covalent Modification']:&#xa;  state=get_state(row,reaction,'Covalent Modification')&#xa;  if r_type=='pt':&#xa;    state_pt=get_state(row,reaction,'PT')&#xa;    reaction.right_reactant.add_modification_site(state)&#xa;    reaction.left_reactant.add_modification(state_pt)&#xa;    reaction.to_change_pt=state_pt&#xa;&#xa;  elif'-'in r_type or r_type in['gap']:&#xa;    reaction.right_reactant.add_modification(state)&#xa;&#xa;  else:&#xa;    reaction.right_reactant.add_modification_site(state)&#xa;&#xa;  reaction.to_change=state&#xa;&#xa;elif r_type in categories_dict['Association']:&#xa;  if r_type=='ipi':&#xa;    state=get_state(row,reaction,'Intraprotein')&#xa;    reaction.left_reactant.add_binding_site(state)&#xa;    reaction.to_change=state&#xa;&#xa;  else:&#xa;    state=get_state(row,reaction,'Association')&#xa;    reaction.left_reactant.add_binding_site(state)&#xa;    reaction.right_reactant.add_binding_site(state)&#xa;    reaction.to_change=state&#xa;&#xa;&#xa;elif r_type in categories_dict['Synthesis/Degradation']:&#xa;  pass&#xa;&#xa;elif r_type in categories_dict['Relocalisation']:&#xa;  state=get_state(row,reaction,'Relocalisation')&#xa;  reaction.to_change=state&#xa;  reaction.right_reactant.localisation=state&#xa;&#xa;else:&#xa;  reaction=Reaction()&#xa;&#xa;reaction.definition=self.definitions[r_type]&#xa;return reaction&#xa;" id="Yg85t8H1xA2u"/>
    <sourcecode value="self.definitions=ReactionDefinitions(:&#xa;  'reaction_definition':DEFAULT_DEFINITION&#xa;)&#xa;self.reaction_pool=ReactionPool()&#xa;self.molecule_pool=MoleculePool()&#xa;self.parse_reactions(states_list)&#xa;" id="fHWSkwUZZOwF"/>
    <sourcecode value="if state.type=='Association':&#xa;  return'ppi'&#xa;&#xa;elif state.type=='Intraprotein':&#xa;  return'ipi'&#xa;&#xa;elif state.type=='Covalent Modification':&#xa;  if state.modifier=='Ub':&#xa;    return'ub+'&#xa;&#xa;  elif state.modifier=='Truncated':&#xa;    return'cut'&#xa;&#xa;  else:&#xa;    return'p+'&#xa;&#xa;&#xa;elif state.type=='Relocalisation':&#xa;  return'mimp'&#xa;&#xa;" id="cvABJ7O5Eprh"/>
    <sourcecode value="rtype=self.get_reaction_type(state)&#xa;if state.type=='Association':&#xa;  return'%s_%s_%s'%(str(state.components[0]),rtype,str(state.components[1]))&#xa;&#xa;elif state.type=='Intraprotein':&#xa;  return'%s_%s_[%s]'%(str(state.components[0]),rtype,state.components[0].second_domain)&#xa;&#xa;elif state.type=='Covalent Modification':&#xa;  return'%s_%s_%s'%(ENZYME,rtype,str(state.components[0]))&#xa;&#xa;elif state.type=='Relocalisation':&#xa;  return'%s_%s_%s'%(TRANSPORTER,rtype,str(state.components[0]))&#xa;&#xa;" id="w5bAuQpSzOH9"/>
    <sourcecode value="if state.type=='Association':&#xa;  reaction.left_reactant=Molecule(state.components[0].name)&#xa;  reaction.left_reactant.is_reactant=True&#xa;  reaction.right_reactant=Molecule(state.components[1].name)&#xa;  reaction.right_reactant.is_reactant=True&#xa;&#xa;elif state.type=='Intraprotein':&#xa;  mol=Molecule(state.components[0].name)&#xa;  mol.is_reactant=True&#xa;  reaction.left_reactant=mol&#xa;  reaction.right_reactant=mol&#xa;&#xa;elif state.type=='Covalent Modification':&#xa;  reaction.left_reactant=Molecule(ENZYME)&#xa;  reaction.left_reactant.is_reactant=True&#xa;  reaction.right_reactant=Molecule(state.components[0].name)&#xa;  reaction.right_reactant.is_reactant=True&#xa;&#xa;elif state.type=='Relocalisation':&#xa;  reaction.left_reactant=Molecule(TRANSPORTER)&#xa;  reaction.left_reactant.is_reactant=True&#xa;  reaction.right_reactant=Molecule(state.components[0].name)&#xa;  reaction.right_reactant.is_reactant=True&#xa;&#xa;" id="CDtCaALmEDPs"/>
    <sourcecode value="if state.type=='Association':&#xa;  reaction=Interaction()&#xa;&#xa;elif state.type=='Intraprotein':&#xa;  reaction=Interaction()&#xa;&#xa;elif state.type=='Covalent Modification':&#xa;  reaction=Modification()&#xa;&#xa;elif state.type=='Relocalisation':&#xa;  reaction=Relocalisation()&#xa;&#xa;reaction.rtype=self.get_reaction_type(state)&#xa;reaction.name=self.get_reaction_str(state)&#xa;if self.definitions.has_key(reaction.rtype):&#xa;  reaction.definition=self.definitions[reaction.rtype]&#xa;&#xa;else:&#xa;raise TypeError('No reactio type %s.')%reaction.rtype self.add_reactants(reaction,state)&#xa;return reaction&#xa;" id="px4oCD7qXg1d"/>
    <sourcecode value="r_type=self.get_reaction_type(state).lower()&#xa;reaction=self.get_preliminary_reaction(state)&#xa;if state.type=='Association':&#xa;  reaction.left_reactant.add_binding_site(state)&#xa;  reaction.right_reactant.add_binding_site(state)&#xa;&#xa;elif state.type=='Intraprotein':&#xa;  reaction.left_reactant.add_binding_site(state)&#xa;&#xa;elif state.type=='Covalent Modification':&#xa;  reaction.right_reactant.add_modification_site(state)&#xa;&#xa;elif state.type=='Relocalisation':&#xa;  reaction.right_reactant.localisation=state&#xa;&#xa;reaction.to_change=state&#xa;reaction.definition=self.definitions[r_type]&#xa;return reaction&#xa;" id="96ZekaGLA81D"/>
    <sourcecode value="for state_id,state in enumerate(states_list):&#xa;  container=ReactionContainer()&#xa;  container.name=self.get_reaction_str(state)&#xa;  container.rid=state_id+1&#xa;  container.rtype=self.get_reaction_type(state)&#xa;  reaction=self.get_reaction_object(state)&#xa;  reaction.rid=state_id+1&#xa;  reaction.rate=Rate(reaction)&#xa;  container.add_reaction(reaction)&#xa;  self.reaction_pool[container.name]=container&#xa;  self.molecule_pool.append(reaction.left_reactant)&#xa;  self.molecule_pool.append(reaction.right_reactant)&#xa;&#xa;" id="ju2t217WPw7a"/>
    <sourcecode value="comp=self.substrat_complexes[0].clone()&#xa;mol=comp.get_molecules(self.left_reactant.name,self.left_reactant.mid)[0]&#xa;mol.add_bond(self.to_change)&#xa;self.product_complexes.append(comp)&#xa;" id="lVnor4eGBvVO"/>
    <sourcecode value="if self.rtype=='ipi':&#xa;  self.run_ipi_reaction()&#xa;&#xa;else:&#xa;  new=BiologicalComplex()&#xa;  new.side='LR'&#xa;  for compl in self.substrat_complexes:&#xa;    if compl.is_modifier:&#xa;      self.product_complexes.append(compl)&#xa;&#xa;    else:&#xa;      for mol in compl.molecules:&#xa;        if mol.is_reactant:&#xa;          mol=mol.clone()&#xa;          mol.add_bond(self.to_change)&#xa;&#xa;        else:&#xa;          mol=mol.clone()&#xa;&#xa;        new.molecules.append(mol)&#xa;&#xa;&#xa;&#xa;  self.product_complexes.append(new)&#xa;&#xa;" id="L8nF1RtlueZl"/>
    <sourcecode value="lcompl=self.get_substrate_complex('L')&#xa;if lcompl:&#xa;  return[lcompl]&#xa;&#xa;return[]&#xa;" id="sKvgIdFvJZ25"/>
    <sourcecode value="rmol=self.right_reactant&#xa;lmol=self.left_reactant&#xa;srcomp=self.get_substrate_complex('LR')or self.get_substrate_complex('R')&#xa;prcomp=srcomp.clone()&#xa;prmol=prcomp.get_molecules(rmol.name,rmol.mid)[0]&#xa;prmol.localisation.loc=True&#xa;self.product_complexes.append(prcomp)&#xa;if len(self.substrat_complexes)>1:&#xa;  self.product_complexes.append(self.get_substrate_complex('L'))" id="f7jvFvA6D3mV"/>
    <sourcecode value="if self.rtype in['trsc','deg']:&#xa;  lcompl=self.get_substrate_complex('L')&#xa;  if lcompl:&#xa;    return[lcompl]&#xa;&#xa;&#xa;elif self.rtype=='trsl':&#xa;  return self.substrat_complexes&#xa;&#xa;return[]&#xa;" id="HcGCPDc8Pgms"/>
    <sourcecode value="if self.rtype=='trsc':&#xa;  rcomp=self.get_substrate_complex('R')&#xa;  self.substrat_complexes.remove(rcomp)&#xa;  rcomp.molecules[0].name+='mRNA'&#xa;  rcomp.side='Z'&#xa;  self.product_complexes+=self.substrat_complexes&#xa;  self.product_complexes.append(rcomp)&#xa;&#xa;elif self.rtype=='trsl':&#xa;  self.product_complexes+=self.substrat_complexes&#xa;  rcomp=self.get_substrate_complex('R')&#xa;  self.substrat_complexes.remove(rcomp)&#xa;  new_comp=rcomp.clone()&#xa;  new_comp.molecules[0].name+='mRNA'&#xa;  rcomp.side='Z'&#xa;  self.substrat_complexes.append(new_comp)&#xa;  self.product_complexes.append(new_comp)&#xa;&#xa;elif self.rtype=='deg':&#xa;  lcomp=self.get_substrate_complex('L')&#xa;  self.product_complexes.append(lcomp)&#xa;  rcomp=self.get_substrate_complex('R').clone()&#xa;  rcomp.remove_molecule(self.right_reactant)&#xa;  if rcomp.molecules:&#xa;    self.product_complexes.append(rcomp)&#xa;&#xa;&#xa;elif self.rtype=='produce':&#xa;  rcomp=self.get_substrate_complex('R')&#xa;  self.substrat_complexes.remove(rcomp)&#xa;  self.product_complexes+=self.substrat_complexes&#xa;  self.product_complexes.append(rcomp)&#xa;&#xa;elif self.rtype=='consume':&#xa;  lcomp=self.get_substrate_complex('L')&#xa;  self.product_complexes.append(lcomp)&#xa;&#xa;" id="7t8g5oEKOUVm"/>
    <sourcecode value="list.__init__(self)&#xa;self.name=None&#xa;self.rid=None&#xa;self.rtype=None&#xa;" id="Glu29sYgB5vx"/>
    <sourcecode value="return&quot;ReacionConteiner for %s: %i reactions present&quot;%(self.name,len(self))&#xa;" id="KOjjDBsTumU2"/>
    <sourcecode value="if len(self)!=0:&#xa;  temp_rid=str(self[-1].rid).split('_')&#xa;  main_rid=temp_rid[0]&#xa;  if len(temp_rid)==1:&#xa;    self[-1].rid='%s_%s'%(main_rid,'1')&#xa;    sup_rid=2&#xa;&#xa;  else:&#xa;    sup_rid=int(temp_rid[1])+1&#xa;&#xa;  reaction.rid=&quot;%s_%s&quot;%(main_rid,str(sup_rid))&#xa;&#xa;else:&#xa;  reaction.rid=self.rid&#xa;&#xa;self.append(reaction)&#xa;" id="3h5D8KJQg0Au"/>
    <sourcecode value="self.rid=str(new_id)&#xa;for reaction in self:&#xa;  splited=str(reaction.rid).split('_')&#xa;  splited[0]=str(new_id)&#xa;  reaction.rid='_'.join(splited)&#xa;  reaction.rate.update_name(reaction.rid)&#xa;&#xa;" id="UY3AXD4gBQkv"/>
    <sourcecode value="if len(self)>0:&#xa;  return self[0].get_sp_state()&#xa;&#xa;else:&#xa;  return None&#xa;&#xa;" id="GGDRgyMtkbyJ"/>
    <sourcecode value="if len(self)>0:&#xa;  return self[0].get_product_contingency()&#xa;&#xa;else:&#xa;  return None&#xa;&#xa;" id="2KJ2NVZdjm2N"/>
    <sourcecode value="if len(self)>0:&#xa;  return self[0].get_source_contingency()&#xa;&#xa;else:&#xa;  return None&#xa;&#xa;" id="MP48yMS0fm22"/>
    <sourcecode value="all_cont=[]&#xa;for reaction in self:&#xa;  all_cont.append(set(reaction.get_contingencies()))&#xa;&#xa;if len(all_cont)>0:&#xa;  return list(all_cont[0].intersection(*all_cont))&#xa;&#xa;else:&#xa;  return[]&#xa;&#xa;" id="mJvvD04YN6gL"/>
    <sourcecode value="if len(self)>0:&#xa;  return self[0].get_modifier()&#xa;&#xa;" id="PKKQsrOeAJYN"/>
    <sourcecode value="all_subrates=[]&#xa;for reaction in self:&#xa;  if'_'not in reaction.rate._rate_names[0]:&#xa;    return 0&#xa;&#xa;  else:&#xa;    all_subrates+=[int(rate.split('_')[1])for rate in reaction.rate._rate_names]&#xa;&#xa;&#xa;return max(all_subrates)&#xa;" id="bIcU1biOu0om"/>
    <sourcecode value="while self:&#xa;  self.pop()&#xa;&#xa;" id="rLIXbS4Cigej"/>
    <sourcecode value="dict.__init__(self)&#xa;" id="k8cODtIA3L8W"/>
    <sourcecode value="all_reactions=sorted(self.values(),key=lambda r:r.rid)&#xa;return iter(all_reactions)&#xa;" id="Ddmm4vEn1oBD"/>
    <sourcecode value="ids=[]&#xa;for cont in self:&#xa;  ids.append(int(cont.rid))&#xa;&#xa;return max(ids)&#xa;" id="lL2PCuKPX6Ba"/>
    <sourcecode value="counter=self.get_highest_id()&#xa;for container in second_pool.values():&#xa;  counter+=1&#xa;  container.update_rid(counter)&#xa;&#xa;self.update(second_pool)&#xa;" id="yi120aSltU85"/>
    <sourcecode value="result=[]&#xa;for react_cont in self.values():&#xa;  product_cont=react_cont.product_contingency&#xa;  if product_cont and product_cont.ctype=='!':&#xa;    result.append(product_cont.state)&#xa;&#xa;&#xa;return set(result)&#xa;" id="ZaxS35VQW0K2"/>
    <sourcecode value="result=[]&#xa;for react_cont in self.values():&#xa;  product_cont=react_cont.product_contingency&#xa;  if product_cont:&#xa;    result.append(product_cont)&#xa;&#xa;&#xa;return set(result)&#xa;" id="IArU80ffaa6d"/>
    <sourcecode value="result=[]&#xa;for react_cont in self.values():&#xa;  product_cont=react_cont.product_contingency&#xa;  if product_cont and product_cont.ctype=='x':&#xa;    result.append(product_cont.state)&#xa;&#xa;&#xa;return set(result)&#xa;" id="eadGLo1byt34"/>
    <sourcecode value="result=[]&#xa;products=self.get_product_contingencies()&#xa;for cont in products:&#xa;  if cont.ctype=='!'and cont.state and cont.state.type=='Covalent Modification':&#xa;    if cont.state.components[0].name==state.components[0].name:&#xa;      if cont.state.modifier==state.modifier:&#xa;        result.append(cont.state)&#xa;&#xa;&#xa;&#xa;&#xa;return result&#xa;" id="OECVsyDXYqlr"/>
    <sourcecode value="result=[]&#xa;for container in self:&#xa;  product=container.sp_state&#xa;  if product.type=='Relocalisation':&#xa;    if product.components[0]==state.components[0]:&#xa;      result.append(product)&#xa;&#xa;&#xa;&#xa;return result" id="k21Gtm7VWY46"/>
    <sourcecode value="dict.__init__(self)&#xa;self.xls_tables=xls_tables&#xa;self.get_reaction_definitions_dict()&#xa;" id="6Gf3nlb7Tk1c"/>
    <sourcecode value="for rrow in self.xls_tables['reaction_definition']:&#xa;  self[rrow['Reaction'].lower()]=rrow&#xa;&#xa;" id="LpjoYiOc3SCC"/>
    <sourcecode value="localization_modifications=:&#xa;&#xa;&#xa;for row in self.xls_tables['reaction_definition']:&#xa;  if row['CategoryType']and(int(row['CategoryType'])==4):&#xa;    mod_list=row['SourceState[Modification]'].split(',')&#xa;    mod_list+=row['ProductState[Modification]'].split(',')&#xa;    mod_list=[x.strip()for x in mod_list]&#xa;    for loc_mod in mod_list:&#xa;      state=re.match(STATE_DOMAIN_PATTERN,loc_mod).group(2)&#xa;      localization_modifications[state]=state&#xa;&#xa;&#xa;&#xa;return localization_modifications&#xa;" id="Jgy8IDid2RPa"/>
    <sourcecode value="result=:&#xa;&#xa;&#xa;for row in self.xls_tables['reaction_definition']:&#xa;  if row['Reaction']:&#xa;    assert type(row['Reaction'])in(type(u&quot;a&quot;),type(&quot;a&quot;))&#xa;    reaction_id=re.sub('\+','_plus',row['Reaction']).lower()&#xa;    result[reaction_id]=row['Directionality']&#xa;&#xa;&#xa;return result&#xa;" id="pxqWgbHxHE6X"/>
    <sourcecode value="return self[rtype]['Category']&#xa;" id="YumLnf9ady6J"/>
    <sourcecode value="pass&#xa;" id="LeRwcWFAqUxQ"/>
    <sourcecode value="cat_dict=:&#xa;&#xa;&#xa;for definition in self:&#xa;  cat=self[definition]['Category']&#xa;  cat_dict.setdefault(cat,[])&#xa;  cat_dict[cat].append(self[definition]['Reaction'].lower())&#xa;&#xa;if cat_dict.has_key(''):&#xa;del(cat_dict[''])return cat_dict" id="o1teVo2G3P7k"/>
    <sourcecode value="pass&#xa;" id="21oRCtfukVsh"/>
    <sourcecode value="return'loc'&#xa;" id="ZTaQPpQQqDr0"/>
    <sourcecode value="cmpnt='Component%s%%s'%ab&#xa;if not with_delimiters:&#xa;  if row.has_key(cmpnt%'[DSR]'):&#xa;    return re.sub('[/\(\)]','',row[cmpnt%'[DSR]'])if row[cmpnt%'[DSR]']else None&#xa;&#xa;  dsr=&quot;%s%s%s&quot;%(&#xa;  &quot;%s&quot;%row[cmpnt%'[Domain]']if row[cmpnt%'[Domain]']else'',&quot;%s&quot;%row[cmpnt%'[Subdomain]']if row[cmpnt%'[Subdomain]']else'',&quot;%s&quot;%row[cmpnt%'[Residue]']if row[cmpnt%'[Residue]']else'',)if not dsr:&#xa;    dsr=None&#xa;&#xa;  if dsr:&#xa;    dsr=re.sub('\W','',dsr)&#xa;&#xa;&#xa;elif row.has_key(cmpnt%'[DSR]'):&#xa;  return row[cmpnt%'[DSR]']&#xa;&#xa;else:&#xa;  dsr=&quot;%s%s%s&quot;%(&#xa;  &quot;%s&quot;%row[cmpnt%'[Domain]']if row[cmpnt%'[Domain]']else'',&quot;/%s&quot;%row[cmpnt%'[Subdomain]']if row[cmpnt%'[Subdomain]']else'',&quot;(%s)&quot;%row[cmpnt%'[Residue]']if row[cmpnt%'[Residue]']else'',)&#xa;return dsr&#xa;" id="RM5YnIrKjSk8"/>
    <sourcecode value="comp=state_str.split('--')&#xa;if side=='A':&#xa;  if'_'in comp[0]:&#xa;    return re.sub('[\(\)\]\[:/]','',comp[0].split('_')[1])&#xa;&#xa;  else:&#xa;    partner_name=re.sub('[\(\)\]\[:/]','',comp[1].split('_')[0])&#xa;    return'%s%s'%(ASSOCIATION_PRE,partner_name)&#xa;&#xa;&#xa;elif side=='B':&#xa;  if'_'in comp[1]:&#xa;    return re.sub('[\(\)\]\[:/]','',comp[1].split('_')[1])&#xa;&#xa;  else:&#xa;    partner_name=re.sub('[\(\)\]\[:/]','',comp[0].split('_')[0])&#xa;    return'%s%s'%(ASSOCIATION_PRE,partner_name)&#xa;&#xa;&#xa;" id="aJpSI2I2jFBL"/>
    <sourcecode value="if side=='A':&#xa;  if row.has_key('ComponentA[DSR]'):&#xa;    a_dsr=row['ComponentA[DSR]']&#xa;&#xa;  else:&#xa;    a_dsr=self.get_dsr(row,'A')&#xa;&#xa;  return a_dsr or('%s%s'%(ASSOCIATION_PRE,row['ComponentB[Name]']))&#xa;&#xa;elif side=='B':&#xa;  if row.has_key('ComponentB[DSR]'):&#xa;    b_dsr=row['ComponentB[DSR]']&#xa;&#xa;  else:&#xa;    b_dsr=self.get_dsr(row,'B')&#xa;&#xa;  return b_dsr or('%s%s'%(ASSOCIATION_PRE,row['ComponentA[Name]']))&#xa;&#xa;" id="uyvFEQSSalnu"/>
    <sourcecode value="if side=='A':&#xa;  if row.has_key('ComponentA[DSR]'):&#xa;    a_dsr=row['ComponentA[DSR]']&#xa;&#xa;  else:&#xa;    a_dsr=self.get_dsr(row,'A')&#xa;&#xa;  return a_dsr or('%s%s%i'%(ASSOCIATION_PRE,row['ComponentB[Name]'],1))&#xa;&#xa;elif side=='B':&#xa;  if row.has_key('ComponentB[DSR]'):&#xa;    b_dsr=row['ComponentB[DSR]']&#xa;&#xa;  else:&#xa;    b_dsr=self.get_dsr(row,'B')&#xa;&#xa;  return b_dsr or('%s%s%i'%(ASSOCIATION_PRE,row['ComponentA[Name]'],2))&#xa;&#xa;" id="nzfT7RxVoEfA"/>
    <sourcecode value="comp_name_dom=state_str.split('-{')[0].split('_')&#xa;if len(comp_name_dom)==1:&#xa;  return'bd'&#xa;&#xa;else:&#xa;  return re.sub('\(|\)|\[|\]','',comp_name_dom[1])&#xa;&#xa;" id="mJGT7foWw11w"/>
    <sourcecode value="if component=='B':&#xa;  if row.has_key('ComponentB[DSR]'):&#xa;    b_dsr=row['ComponentB[DSR]']&#xa;&#xa;  else:&#xa;    b_dsr=self.get_dsr(row,'B')&#xa;&#xa;  if b_dsr:&#xa;    return re.sub('\(|\)|\[|\]','',b_dsr)&#xa;&#xa;  domain=row['ComponentA[Name]']&#xa;  return re.sub('\(|\)|\[|\]','',domain)&#xa;&#xa;elif component=='A':&#xa;  if row.has_key('ComponentA[DSR]'):&#xa;    b_dsr=row['ComponentA[DSR]']&#xa;&#xa;  else:&#xa;    b_dsr=self.get_dsr(row,'A')&#xa;&#xa;  if b_dsr:&#xa;    return re.sub('\(|\)|\[|\]','',b_dsr)&#xa;&#xa;  domain=row['ComponentB[Name]']&#xa;  return re.sub('\(|\)|\[|\]','',domain)" id="CVW8WV3c6klu"/>
    <sourcecode value="self.name=name&#xa;self._id=get_id.next()&#xa;self.binding_partners=[]&#xa;self.binding_sites=[]&#xa;self.modifications=[]&#xa;self.modification_sites=[]&#xa;self.localisation=None&#xa;self.mid=None&#xa;self.alternative_localisations=[]&#xa;self.is_reactant=False&#xa;" id="m9V9cSwTJB2D"/>
    <sourcecode value="return self.name&#xa;" id="VN0pZ20W0iTa"/>
    <sourcecode value="if not self.name==other.name:&#xa;  return False&#xa;&#xa;if self.mid and other.mid and self.mid!=other.mid:&#xa;  return False&#xa;&#xa;return True&#xa;" id="FadCf4jASjxz"/>
    <sourcecode value="return(self.name+str(self._id)).__hash__()&#xa;" id="ClYcSWbES5x6"/>
    <sourcecode value="for mod in other.modifications:&#xa;  if mod not in self.modifications:&#xa;    self.modifications.append(mod)&#xa;&#xa;&#xa;for site in other.modification_sites:&#xa;  if site not in self.modification_sites:&#xa;    self.modification_sites.append(site)&#xa;&#xa;&#xa;for partner in other.binding_partners:&#xa;  if partner not in self.binding_partners:&#xa;    self.binding_partners.append(partner)&#xa;&#xa;&#xa;for site in other.binding_sites:&#xa;  if site not in self.binding_sites:&#xa;    self.binding_sites.append(site)&#xa;&#xa;&#xa;if self.localisation!=other.localisation:&#xa;  self.alternative_localisations.append(other.localisation)&#xa;&#xa;" id="pzaa7ayJJUwl"/>
    <sourcecode value="print&quot;;print&quot;Binding sites:      %s&quot;%str(self.binding_sites)&#xa;print&quot;Binding partners:   %s&quot;%str(self.binding_partners)&#xa;print&quot;Modifications:      %s&quot;%str(self.modifications)&#xa;print&quot;Modification sites: %s&quot;%str(self.modification_sites)&#xa;" id="uZ2D3wz2SuQ2"/>
    <sourcecode value="name=copy.deepcopy(self.name)&#xa;new=Molecule(name)&#xa;new.binding_partners=copy.deepcopy(self.binding_partners)&#xa;new.binding_sites=copy.deepcopy(self.binding_sites)&#xa;new.modifications=copy.deepcopy(self.modifications)&#xa;new.modification_sites=copy.deepcopy(self.modification_sites)&#xa;new.localisation=copy.deepcopy(self.localisation)&#xa;new.mid=copy.deepcopy(self.mid)&#xa;new.alternative_localisations=copy.deepcopy(self.alternative_localisations)&#xa;new.is_reactant=copy.deepcopy(self.is_reactant)&#xa;return new&#xa;" id="h6iJQJ4Lq4Ws"/>
    <sourcecode value="result=[]&#xa;for site in self.binding_sites:&#xa;  result.append(Contingency(None,'x',site))&#xa;&#xa;for partner in self.binding_partners:&#xa;  result.append(Contingency(None,'!',partner))&#xa;&#xa;for site in self.modification_sites:&#xa;result.append(Contingency(None,'x',site))for modif in self.modifications:&#xa;result.append(Contingency(None,'!',modif))if self.localisation:&#xa;  result.append(Contingency(None,'!',self.localisation))&#xa;&#xa;return result&#xa;" id="pw8FySufWbww"/>
    <sourcecode value="return Component(self.name,None,self.mid)&#xa;" id="lunvwuflql0m"/>
    <sourcecode value="if state in self.binding_partners:&#xa;  return True&#xa;&#xa;if state in self.binding_sites:&#xa;  return True&#xa;&#xa;if state in self.modifications:&#xa;  return True&#xa;&#xa;if state in self.modification_sites:&#xa;  return True&#xa;&#xa;if self.localisation and state==self.localisation:&#xa;  return True&#xa;&#xa;return False&#xa;" id="diNr9pStjFof"/>
    <sourcecode value="if state in self.binding_partners:&#xa;  return True&#xa;&#xa;return False&#xa;" id="CSzuilXnDwjQ"/>
    <sourcecode value="if state in self.binding_sites:&#xa;  return True&#xa;&#xa;return False&#xa;" id="VcDiYw6sKsVp"/>
    <sourcecode value="self.binding_partners.append(state)&#xa;if state in self.binding_sites:&#xa;  self.binding_sites.remove(state)&#xa;&#xa;empty_domains=self.get_empty_binding_domains_states_dict()&#xa;comp=state.get_component(self.name)&#xa;if comp.domain in empty_domains.keys():&#xa;  self.binding_sites.remove(empty_domains[comp.domain])&#xa;&#xa;" id="DaEWRhJAX1Tv"/>
    <sourcecode value="result=:&#xa;&#xa;&#xa;for state in self.binding_sites:&#xa;  result[state.get_component(self.name,side).domain]=state&#xa;&#xa;return result&#xa;" id="VX92YdvrUx71"/>
    <sourcecode value="if mode=='binding'and occupied:&#xa;  to_search=self.binding_partners&#xa;&#xa;elif mode=='binding'and not occupied:&#xa;  to_search=self.binding_sites&#xa;&#xa;elif mode=='modification'and occupied:&#xa;  to_search=self.modifications&#xa;&#xa;elif mode=='modification'and not occupied:&#xa;  to_search=self.modification_sites&#xa;&#xa;else:&#xa;  raise'Wrong domain search mode'&#xa;&#xa;result=[]&#xa;for state in to_search:&#xa;  component=state.get_component(self.name,side)&#xa;  if component:&#xa;    result.append(component.domain)&#xa;    if state.type==&quot;Intraprotein&quot;:&#xa;      result.append(component.second_domain)&#xa;&#xa;&#xa;&#xa;return result&#xa;" id="lGADDICyahAB"/>
    <sourcecode value="doms=self.get_domains('binding',True,side)&#xa;doms+=self.get_domains('binding',False,side)&#xa;doms+=self.get_domains('modification',True,side)&#xa;doms+=self.get_domains('modification',False,side)&#xa;return list(set(doms))&#xa;" id="j6CIHB1gLkfC"/>
    <sourcecode value="return True&#xa;" id="c6YvpD8O2RsH"/>
    <sourcecode value="if state.type==&quot;Covalent Modification&quot;:&#xa;  if state not in self.modification_sites:&#xa;    self.add_modification_site(state)&#xa;&#xa;&#xa;elif state.type==&quot;Association&quot;:&#xa;  if state not in self.binding_sites:&#xa;    self.add_binding_site(state,side)&#xa;&#xa;&#xa;" id="rgFWokHXYqrl"/>
    <sourcecode value="dom=state.get_component(self.name).domain&#xa;if not self.domain_is_present(dom,side):&#xa;  state_comp=state.get_component(self.name)&#xa;  if not state_comp:&#xa;    self.binding_sites.append(state)&#xa;&#xa;  elif state_comp:&#xa;    self.binding_sites.append(state)&#xa;&#xa;&#xa;" id="hkEpM3Bm6ul5"/>
    <sourcecode value="if self.has_bond(state):&#xa;  self.binding_partners.remove(state)&#xa;  if empty_domain:&#xa;    self.binding_sites.append(state)&#xa;&#xa;&#xa;" id="k0rajXty13mu"/>
    <sourcecode value="if self.has_binding_site(state):&#xa;  self.binding_sites.remove(state)&#xa;&#xa;" id="4LIQofA2XuOv"/>
    <sourcecode value="self.modifications.append(mod)&#xa;to_remove=None&#xa;for mod_site in self.modification_sites:&#xa;  if mod_site==mod and\&#xa;  mod_site.components[0].domain==mod.components[0].domain:&#xa;    to_remove=mod_site&#xa;&#xa;&#xa;if to_remove:&#xa;  temp=[]&#xa;  for x in self.modification_sites:&#xa;    if x==to_remove:&#xa;      if x.components[0].domain==to_remove.components[0].domain:&#xa;        pass&#xa;&#xa;      else:&#xa;        temp.append(x)&#xa;&#xa;&#xa;    else:&#xa;      temp.append(x)&#xa;&#xa;&#xa;  self.modification_sites=temp&#xa;&#xa;" id="9wWEBRhGnxeZ"/>
    <sourcecode value="self.modifications_site.remove(mod)&#xa;" id="U5pF2TodFOlu"/>
    <sourcecode value="self.modification_sites.append(mod)&#xa;" id="hNxvlin5SrKG"/>
    <sourcecode value="self.modifications.remove(mod)&#xa;self.modification_sites.append(mod)&#xa;" id="kitAXBQrw9lZ"/>
    <sourcecode value="if cont.ctype=='x'and cont.state.type in['Association','Intraprotein']:&#xa;  self.add_binding_site(cont.state)&#xa;&#xa;elif cont.ctype=='!'and cont.state.type in['Association','Intraprotein']:&#xa;  self.add_bond(cont.state)&#xa;&#xa;elif cont.ctype=='x'and cont.state.type=='Covalent Modification':&#xa;  self.add_modification_site(cont.state)&#xa;&#xa;elif cont.ctype=='!'and cont.state.type=='Covalent Modification':&#xa;  self.add_modification(cont.state)&#xa;&#xa;elif cont.ctype=='!'and cont.state.type=='Relocalisation':&#xa;  self.localisation=cont.state&#xa;&#xa;elif cont.ctype=='x'and cont.state.type=='Relocalisation':&#xa;  self.alternative_localisations.append(cont.state)" id="KHuGOenXsIVP"/>
    <sourcecode value="list.__init__(self)&#xa;" id="jLtVQQxSi1WN"/>
    <sourcecode value="temp=:&#xa;&#xa;&#xa;for mol in self:&#xa;  conts=mol.get_contingencies()&#xa;  if mol.name in temp.keys():&#xa;    conts_in=temp[mol.name]&#xa;    for cont in conts:&#xa;      if str(cont)not in[str(x)for x in conts_in]:&#xa;        temp[mol.name].append(cont)&#xa;&#xa;&#xa;&#xa;  else:&#xa;    temp[mol.name]=mol.get_contingencies()&#xa;&#xa;&#xa;result=:&#xa;&#xa;&#xa;for mol in temp.keys():&#xa;  mol_ob=Molecule(mol)&#xa;  for cont in temp[mol]:&#xa;    mol_ob.add_contingency(cont)&#xa;&#xa;  result[mol]=mol_ob&#xa;&#xa;return result&#xa;" id="bVapk3bUOSxp"/>
    <sourcecode value="self.__components=[]&#xa;self.__state_str=''&#xa;self.__type=None&#xa;self.__sid=None&#xa;self.__modifier=None&#xa;self.__not_modifier=None&#xa;self.__loc=False&#xa;self.__homodimer=False&#xa;" id="TQoa8kgevRgG"/>
    <sourcecode value="return self.__components&#xa;" id="3WwSkUrBvdm1"/>
    <sourcecode value="assert isinstance(components,list)&#xa;self.__components=components&#xa;" id="BmxfYd3Z9z1u"/>
    <sourcecode value="return self.__state_str&#xa;" id="ZkajjZbBNeWp"/>
    <sourcecode value="assert isinstance(state_str,str)&#xa;self.__state_str=state_str&#xa;" id="cW75Sp52ZdjH"/>
    <sourcecode value="return self.__type&#xa;" id="kjMIN5ZYLz6H"/>
    <sourcecode value="self.__type=type&#xa;" id="kdOdY3zHkLZ5"/>
    <sourcecode value="return self.__sid&#xa;" id="dpzN8WTXa4Ed"/>
    <sourcecode value="self.__sid=sid&#xa;" id="ux94XwoAjlWs"/>
    <sourcecode value="return self.__modifier&#xa;" id="rTRaExQTunIv"/>
    <sourcecode value="self.__modifier=modifier&#xa;" id="koJVjymYSD6e"/>
    <sourcecode value="return self.__not_modifier&#xa;" id="0eBQrI5xn9x5"/>
    <sourcecode value="self.__not_modifier=not_modifier&#xa;" id="ofMnhEQhsc8h"/>
    <sourcecode value="return self.__loc&#xa;" id="lcdbClI2uufC"/>
    <sourcecode value="assert isinstance(loc,bool)&#xa;self.__loc=loc&#xa;" id="MGRdldaWEB7Q"/>
    <sourcecode value="return self.__homodimer&#xa;" id="hlXvwcKrzldE"/>
    <sourcecode value="assert isinstance(homodimer,bool)&#xa;self.__homodimer=homodimer&#xa;" id="iAr0E44wnZpj"/>
    <sourcecode value="if self.type=='Intraprotein':&#xa;  return'%s_[%s]--[%s]'%(self.components[0].name,\&#xa;  self.components[0].domain,self.components[0].second_domain)&#xa;if self.type=='Association':&#xa;  return'%s--%s'%(str(self.components[0]),str(self.components[1]))&#xa;&#xa;if self.type in['Covalent Modification','Relocalisation']:&#xa;  return'%s-{%s}'%(str(self.components[0]),self.modifier)&#xa;&#xa;return self.state_str&#xa;" id="y4vldiSnqzxi"/>
    <sourcecode value="if self.components:&#xa;  if sorted(self.components,key=lambda comp:comp.name)==sorted(other.components,key=lambda comp:comp.name):&#xa;    return True&#xa;&#xa;  else:&#xa;    return False&#xa;&#xa;&#xa;else:&#xa;  if self.state_str==other.state_str:&#xa;    return True&#xa;&#xa;  else:&#xa;    return False&#xa;&#xa;&#xa;" id="rEZbAba6dVpF"/>
    <sourcecode value="return(str(self)).__hash__()&#xa;" id="hbmK5bZHraJ3"/>
    <sourcecode value="if component in self.components:&#xa;  return True&#xa;&#xa;return False&#xa;" id="FYvmfuSMTDfW"/>
    <sourcecode value="if self.homodimer:&#xa;  if side=='L':&#xa;    return self.components[0]&#xa;&#xa;  elif side=='R':&#xa;    return self.components[1]&#xa;&#xa;&#xa;for comp in self.components:&#xa;  if comp.name==name:&#xa;    return comp&#xa;&#xa;&#xa;" id="vBuMMZt8mekY"/>
    <sourcecode value="if not self.type=='Association':&#xa;  return None&#xa;&#xa;if component==self.components[0]:&#xa;  return self.components[1]&#xa;&#xa;elif component==self.components[1]:&#xa;  return self.components[0]&#xa;&#xa;else:&#xa;return None" id="6Ocz0LaxCAo2"/>
    <sourcecode value="new=State()&#xa;new.components=copy.deepcopy(self.components)&#xa;new.state_str=self.state_str&#xa;new.type=self.type&#xa;new.sid=copy.deepcopy(self.sid)&#xa;new.modifier=self.modifier&#xa;new.not_modifier=self.not_modifier&#xa;return new&#xa;" id="n4FxE30hIlcp"/>
    <sourcecode value="for component in self.components:&#xa;  if component.domain=='bd':&#xa;    return True&#xa;&#xa;&#xa;return False&#xa;" id="YUbsv3Dg5QcJ"/>
    <sourcecode value="self.loc=['Cytoplasm','Nucleus',\&#xa;'Vacuole','Mitochondria','Endosome','Extracellular']&#xa;self.df=DomainFactory()&#xa;" id="fPqkqS2I212N"/>
    <sourcecode value="comp=state_str.split('--')&#xa;compA_name=comp[0].split('_')[0]&#xa;compA_domain=self.df.get_association_domain_from_str(state_str,'A')&#xa;compB_name=comp[1].split('_')[0]&#xa;compB_domain=self.df.get_association_domain_from_str(state_str,'B')&#xa;if compB_name.startswith('['):&#xa;  state.type='Intraprotein'&#xa;  comp_object=Component(compA_name,compA_domain)&#xa;  comp_object.second_domain=re.sub('[\[\]]','',compB_name)&#xa;  state.components=[comp_object]&#xa;&#xa;else:&#xa;  state.type='Association'&#xa;  if state_id:&#xa;    idA=state_id.split('--')[0]&#xa;    idB=state_id.split('--')[1]&#xa;&#xa;  else:&#xa;    idA=None&#xa;    idB=None&#xa;&#xa;  compA_object=Component(compA_name,compA_domain,idA)&#xa;  compB_object=Component(compB_name,compB_domain,idB)&#xa;  state.components=[compA_object,compB_object]&#xa;  if compA_name==compB_name:&#xa;    state.homodimer=True&#xa;&#xa;&#xa;return state&#xa;" id="LezbGEkubYeP"/>
    <sourcecode value="comp_name_dom=state_str.split('-{')[0].split('_')&#xa;comp_dom=self.df.get_modification_domain_from_str(state_str)&#xa;comp=Component(comp_name_dom[0],comp_dom)&#xa;state.components.append(comp)&#xa;modifier=state_str.split('-{')[1].replace('}','')&#xa;compartments=[compartment.lower()for compartment in self.loc]&#xa;if modifier.lower()in compartments:&#xa;  state.type='Relocalisation'&#xa;  state.components[0].domain=self.df.get_localisation_domain()&#xa;  state.modifier=modifier&#xa;  state.not_modifier=loc_not_modifier&#xa;&#xa;else:&#xa;  state.type='Covalent Modification'&#xa;  state.modifier=state_str.split('-{')[1].replace('}','')&#xa;  state.not_modifier='U'&#xa;&#xa;return state&#xa;" id="rtnTdBKdH4Bv"/>
    <sourcecode value="if type(state_str)!=str and type(state_str)!=unicode:&#xa;  raise TypeError('get_states argument must be a string.')&#xa;&#xa;state=State()&#xa;state.state_str=state_str&#xa;state.sid=state_id&#xa;if state_str=='':&#xa;  state.type='Null'&#xa;&#xa;elif state_str.startswith('&lt;'):&#xa;  state.type='Boolean'&#xa;&#xa;elif'--'in state_str:&#xa;  state=self.get_dash_dash_state_from_string(state,state_str,state_id,loc_not_modifier)&#xa;&#xa;elif'-'in state_str:&#xa;  state=self.get_dash_state_from_string(state,state_str,state_id,loc_not_modifier)&#xa;&#xa;elif'*'in state_str:&#xa;  state.components=[Component(state_str.split('*')[0])]&#xa;  state.type='Polymer'&#xa;&#xa;elif state_str.startswith('['):&#xa;  state.type='Input'&#xa;  state.components=[Component(state_str.replace('[','').replace(']',''))]&#xa;&#xa;else:&#xa;  state.components=[Component(state_str)]&#xa;  state.type='Component'&#xa;&#xa;return state&#xa;" id="Fs6wWTFK9BQu"/>
    <sourcecode value="state=State()&#xa;state.type=category&#xa;if category=='Covalent Modification':&#xa;  state.modifier=reaction.definition['Modifier or Boundary']&#xa;  state.not_modifier='U'&#xa;  comp_name=row['ComponentB[Name]'].split('_')[0]&#xa;  comp_dom=self.df.get_modification_domain_from_dict(row,reaction)&#xa;  comp=Component(comp_name,comp_dom)&#xa;  state.components.append(comp)&#xa;  state.state_str='%s_[%s]-{%s}'%(comp_name,comp_dom,state.modifier)&#xa;&#xa;elif category=='PT':&#xa;  state.modifier=reaction.definition['Modifier or Boundary']&#xa;  state.not_modifier='U'&#xa;  comp_name=row['ComponentA[Name]'].split('_')[0]&#xa;  comp_dom=self.df.get_modification_domain_from_dict(row,reaction,'A')&#xa;  comp=Component(comp_name,comp_dom)&#xa;  state.components.append(comp)&#xa;  state.state_str='%s_[%s]-{%s}'%(comp_name,comp_dom,state.modifier)&#xa;&#xa;elif category=='Intraprotein':&#xa;l_dsr=self.df.get_intraprotein_domain_from_dict(row,'A')r_dsr=self.df.get_intraprotein_domain_from_dict(row,'B')state_str='%s_[%s]--[%s]'%(row['ComponentA[Name]'],\l_dsr,r_dsr)state=self.get_state_from_string(state_str)elif category=='Association':&#xa;l_dsr=self.df.get_association_domain_from_dict(row,'A')r_dsr=self.df.get_association_domain_from_dict(row,'B')state_str='%s_[%s]--%s_[%s]'%(row['ComponentA[Name]'],\l_dsr,row['ComponentB[Name]'],r_dsr)state=self.get_state_from_string(state_str)elif category=='Relocalisation':&#xa;  comp_name=row['ComponentB[Name]'].split('_')[0]&#xa;  dom=self.df.get_localisation_domain()&#xa;  state.components.append(Component(comp_name,dom))&#xa;  if row.has_key('ProductState[Modification]'):&#xa;  state.modifier=re.sub('[-{}]','',row['ProductState[Modification]'])state.not_modifier=re.sub('[-{}]','',row['SourceState[Modification]'])elif row.has_key('ProductState'):&#xa;    state.modifier=row['ProductState'].split('-{')[-1].replace('}','')&#xa;    state.not_modifier=row['SourceState'].split('-{')[-1].replace('}','')&#xa;&#xa;  state.state_str='%s_[%s]-{%s}'%(comp_name,dom,state.modifier)&#xa;&#xa;return state&#xa;" id="3AwThJV6Mddm"/>
    <sourcecode value="if type(first_arg)==dict:&#xa;  return self.get_state_from_reaction(first_arg,sec_arg,third_arg)&#xa;&#xa;elif type(first_arg)in[str,unicode]:&#xa;  return self.get_state_from_string(first_arg,sec_arg,third_arg)&#xa;&#xa;" id="sQvhN5DeinGz"/>
    <sourcecode value="self.__molecules=[]&#xa;self.__side=None&#xa;self.__input_conditions=[]&#xa;self.__is_positive=True&#xa;self.__is_modifier=False&#xa;" id="W5aDW2aClIMC"/>
    <sourcecode value="return self.__molecules&#xa;" id="pWwp8uNczyqV"/>
    <sourcecode value="assert isinstance(molecules,list)&#xa;self.__molecules=molecules&#xa;" id="kmBiNzGATCxb"/>
    <sourcecode value="return self.__side&#xa;" id="zUeSec2jxEkE"/>
    <sourcecode value="self.__side=side&#xa;" id="liZuipOhH27t"/>
    <sourcecode value="return self.__input_conditions&#xa;" id="LRNaSUT6e4gz"/>
    <sourcecode value="assert isinstance(input_conditions,list)&#xa;self.__input_conditions=input_conditions&#xa;" id="iCXgkaO30lbS"/>
    <sourcecode value="return self.__is_positive&#xa;" id="XZsXKUzWXUMg"/>
    <sourcecode value="assert isinstance(is_positive,bool)&#xa;self.__is_positive=is_positive&#xa;" id="AIPHHb6nAwKT"/>
    <sourcecode value="return self.__is_modifier&#xa;" id="LxwUuGvIWsCG"/>
    <sourcecode value="assert isinstance(is_modifier,bool)&#xa;self.__is_modifier=is_modifier&#xa;" id="6eiyOb7iZ3CR"/>
    <sourcecode value="mols=', '.join(sorted([mol.name for mol in self.molecules]))&#xa;return'Complex: '+mols&#xa;" id="wE0TFAuVFbHC"/>
    <sourcecode value="return len(self.molecules)&#xa;" id="U63OQAgKPgne"/>
    <sourcecode value="print';for mol in self.molecules:&#xa;  mol.inspect()&#xa;&#xa;" id="n4TZFxRi3U6T"/>
    <sourcecode value="new=self.clone()&#xa;for mol in other.molecules:&#xa;  if mol not in new.molecules:&#xa;    new.molecules.append(mol)&#xa;&#xa;  elif not root:&#xa;    new.molecules.append(mol)&#xa;&#xa;  elif root:&#xa;    path=self.get_shortest_path(root,mol)&#xa;    path_other=other.get_shortest_path(root,mol)&#xa;    if str(path)==str(path_other)or mol==root:&#xa;      dup_mol=new.get_molecules(mol.name,mol.mid)[0]&#xa;      dup_mol=dup_mol+mol&#xa;&#xa;    else:&#xa;      new.molecules.append(mol)&#xa;&#xa;&#xa;&#xa;return new&#xa;" id="AWEo44Np6qPL"/>
    <sourcecode value="result=[]&#xa;mol=self.get_molecules(mol_name,mid)[0]&#xa;component=mol.get_component()&#xa;for state in mol.binding_partners:&#xa;partner=state.get_partner(component)result+=self.get_molecules(partner.name,partner.cid)return result&#xa;" id="7JYwJWAu8djU"/>
    <sourcecode value="result=[]&#xa;stack=[]&#xa;for mol in self.get_partners(mol_name,mid):&#xa;  stack.append([mol])&#xa;&#xa;while stack:&#xa;  branch=stack.pop()&#xa;  mols=self.get_partners(branch[-1].name,branch[-1].mid)&#xa;  if len(mols)==1:&#xa;    result.append(branch)&#xa;&#xa;  else:&#xa;    for mol in mols:&#xa;      if len(branch)==1 and mol.name!=mol_name:&#xa;        stack.append(branch+[mol])&#xa;&#xa;      elif len(branch)>1 and branch[-2].name!=mol.name:&#xa;        stack.append(branch+[mol])&#xa;&#xa;&#xa;&#xa;&#xa;return result&#xa;" id="RZhPcYpCPU3I"/>
    <sourcecode value="result=:&#xa;&#xa;&#xa;stack=[]&#xa;for mol in self.get_partners(mol_name,mid):&#xa;  result[(mol.name,mol.mid)]=[mol]&#xa;  stack.append([mol])&#xa;&#xa;while stack:&#xa;  branch=stack.pop()&#xa;  mols=self.get_partners(branch[-1].name,branch[-1].mid)&#xa;  if len(mols)>1:&#xa;    for mol in mols:&#xa;      if len(branch)==1 and mol.name!=mol_name:&#xa;        stack.append(branch+[mol])&#xa;        result[(branch[0].name,branch[0].mid)].append(mol)&#xa;&#xa;      elif len(branch)>1 and branch[-2].name!=mol.name:&#xa;        stack.append(branch+[mol])&#xa;        result[(branch[0].name,branch[0].mid)].append(mol)&#xa;&#xa;&#xa;&#xa;&#xa;return result.values()&#xa;" id="A49Hi00Dzng7"/>
    <sourcecode value="if mol1 not in self.molecules or mol2 not in self.molecules:&#xa;  return None&#xa;&#xa;result=[]&#xa;stack=[]&#xa;for mol in self.get_partners(mol1.name,mol1.mid):&#xa;  if mol==mol2:&#xa;    result.append([mol])&#xa;&#xa;  else:&#xa;    stack.append([mol])&#xa;&#xa;&#xa;while stack:&#xa;  branch=stack.pop()&#xa;  mols=self.get_partners(branch[-1].name,branch[-1].mid)&#xa;  if len(mols)==1:&#xa;    pass&#xa;&#xa;  else:&#xa;    for mol in mols:&#xa;      if len(branch)==1 and mol.name!=mol1.name:&#xa;        if mol==mol2:&#xa;          result.append(branch+[mol])&#xa;&#xa;        else:&#xa;        stack.append(branch+[mol])&#xa;      elif len(branch)>1 and branch[-2].name!=mol.name:&#xa;        if mol==mol2:&#xa;          result.append(branch+[mol])&#xa;&#xa;        else:&#xa;        stack.append(branch+[mol])&#xa;&#xa;&#xa;&#xa;result=[[mol1]+li for li in result]&#xa;result=sorted(result,key=lambda x:len(x))&#xa;return result&#xa;" id="1EnQbu8msHIw"/>
    <sourcecode value="all_paths=self.get_paths(mol1,mol2)&#xa;if not all_paths:&#xa;  return[]&#xa;&#xa;length=len(all_paths[0])&#xa;result=[path for path in all_paths if len(path)==length]&#xa;result=sorted(result,key=lambda x:str(x))&#xa;return result[0]&#xa;" id="pVzqYT9wcqK6"/>
    <sourcecode value="new=BiologicalComplex()&#xa;temp=[]&#xa;for mol in self.molecules:&#xa;  temp.append(mol.clone())&#xa;&#xa;new.molecules=temp&#xa;new.side=copy.deepcopy(self.side)&#xa;new.input_condition=copy.deepcopy(self.input_conditions)&#xa;return new&#xa;" id="7qWX2UFHWEFn"/>
    <sourcecode value="mol_state=[]&#xa;mols=sorted(self.molecules,key=lambda mol:mol.name)&#xa;for mol in mols:&#xa;  for state in mol.binding_partners:&#xa;    mol_state.append((mol,state))&#xa;&#xa;&#xa;pairs=[]&#xa;while mol_state:&#xa;  ms=mol_state.pop()&#xa;  done=False&#xa;  for p in pairs:&#xa;    if len(p)==1:&#xa;      if p[0][1]==ms[1]:&#xa;        if not done and(ms[1].homodimer or p[0][0].name!=ms[0].name):&#xa;          p.append(ms)&#xa;          done=True&#xa;&#xa;&#xa;&#xa;&#xa;  if not done:&#xa;    pairs.append([ms])&#xa;&#xa;&#xa;bonds=:&#xa;&#xa;&#xa;counter=1&#xa;for p in pairs:&#xa;  if len(p)==2:&#xa;    bonds[p[0]]=counter&#xa;    bonds[p[1]]=counter&#xa;    counter+=1&#xa;&#xa;  elif len(p)==1 and p[0][1].type=='Intraprotein':&#xa;    bonds[p[0]]=counter&#xa;    counter+=1&#xa;&#xa;  else:&#xa;    print'Adding bond - sth strange',self&#xa;&#xa;&#xa;return bonds&#xa;" id="QsXlXsWch37j"/>
    <sourcecode value="result=[]&#xa;for mol in self.molecules:&#xa;  if mol.name==name:&#xa;    if not mid or not mol.mid or(mid and mid==mol.mid):&#xa;      if not _id or(_id and _id==mol._id):&#xa;        result.append(mol)&#xa;&#xa;&#xa;&#xa;&#xa;return result&#xa;" id="LlU7oDjE5Gza"/>
    <sourcecode value="result=[]&#xa;mols=self.get_molecules(name,mid,_id)&#xa;for mol in mols:&#xa;  if mol.has_state(state):&#xa;    result.append(mol)&#xa;&#xa;&#xa;return result&#xa;" id="jDWMjXWSLUfj"/>
    <sourcecode value="all_mols=[(mol.name,mol.mid)for mol in self.molecules]&#xa;if(name,mid)in all_mols:&#xa;return True return False&#xa;" id="FwI4TZeQ45N0"/>
    <sourcecode value="if state.state.type=='Input':&#xa;  self.input_conditions=Contingency('','!',state)&#xa;&#xa;elif state.state.type=='Association':&#xa;  mol1=Molecule(state.state.components[0].name)&#xa;  mol1.mid=state.state.components[0].cid&#xa;  mol2=Molecule(state.state.components[1].name)&#xa;  mol2.mid=state.state.components[1].cid&#xa;  if state.ctype in[&quot;ornot&quot;,&quot;andnot&quot;]:&#xa;    mol1.set_site(state.state)&#xa;    mol2.set_site(state.state)&#xa;&#xa;  else:&#xa;    mol1.binding_partners.append(state.state)&#xa;    mol2.binding_partners.append(state.state)&#xa;&#xa;  partners=self.get_molecules(mol1.name,mol1.mid)&#xa;  if not partners:&#xa;    self.molecules.append(mol1)&#xa;&#xa;  else:&#xa;    if state.state not in partners[0].binding_partners:&#xa;      partners[0].add_bond(state.state)&#xa;&#xa;&#xa;  partners=self.get_molecules(mol2.name,mol2.mid)&#xa;  if not partners or mol1==mol2:&#xa;    self.molecules.append(mol2)&#xa;&#xa;  else:&#xa;    if state.state not in partners[0].binding_partners:&#xa;      partners[0].add_bond(state.state)&#xa;&#xa;&#xa;&#xa;" id="bQggPTkTiyEv"/>
    <sourcecode value="print&quot;Its covalent&quot;&#xa;mol1=Molecule(state.state.components[0].name)&#xa;mol1.mid=state.state.components[0].cid&#xa;if state.ctype in[&quot;and&quot;,&quot;or&quot;]:&#xa;  mol1.add_modification(state.state)&#xa;&#xa;elif state.ctype in[&quot;notand&quot;,&quot;notor&quot;]:&#xa;  mol1.set_site(state.state)&#xa;&#xa;else:&#xa;  assert&quot;not known bool state&quot;&#xa;&#xa;found=False&#xa;if complexes and state.ctype in[&quot;and&quot;,&quot;notand&quot;]:&#xa;  for comp in complexes:&#xa;    molecules=comp.get_molecules(state.state.components[0].name)&#xa;    if molecules:&#xa;      for mol in molecules:&#xa;        if state.state not in mol.modifications and state.ctype==&quot;and&quot;:&#xa;          if state.state in mol.modification_site:&#xa;            mol.remove_modification_site(state.state)&#xa;            mol.add_modification(state.state)&#xa;            found=True&#xa;&#xa;          else:&#xa;            found=True&#xa;            mol.add_modification(state.state)&#xa;&#xa;&#xa;        elif state.state not in mol.modifications and state.ctype==&quot;notand&quot;:&#xa;          mol.set_site(state.state)&#xa;&#xa;&#xa;&#xa;&#xa;  if found:&#xa;    return&#xa;&#xa;&#xa;partners=self.get_molecules(mol1.name,mol1.mid)&#xa;if not partners:&#xa;  self.molecules.append(mol1)&#xa;&#xa;else:&#xa;  if state.ctype in[&quot;and&quot;,&quot;or&quot;]:&#xa;    partners[0].add_modification(state.state)&#xa;&#xa;  else:&#xa;    partners[0].set_site(state.state)&#xa;&#xa;&#xa;" id="n8YT6kMENfSi"/>
    <sourcecode value="result=[]&#xa;for molecule in self.molecules:&#xa;  result+=molecule.get_contingencies()&#xa;&#xa;return list(set(result))&#xa;" id="WzIpg7KdaXGM"/>
    <sourcecode value="if mol in self.molecules:&#xa;  cmol=self.get_molecules(mol.name,mol.mid)[0]&#xa;  for m in self.molecules:&#xa;    if m!=cmol:&#xa;      for bond1 in m.binding_partners:&#xa;        for bond2 in cmol.binding_partners:&#xa;          if bond1==bond2:&#xa;            m.remove_bond(bond1)&#xa;&#xa;&#xa;&#xa;&#xa;&#xa;  self.molecules.remove(cmol)&#xa;&#xa;" id="Imku7RObRhQ5"/>
    <sourcecode value="list.__init__(self)&#xa;self.__name=name&#xa;self.__ctype=None&#xa;self.__input_condition=None&#xa;" id="V7f0LblNb2y5"/>
    <sourcecode value="return self.__name&#xa;" id="Bc5kd4naTWcq"/>
    <sourcecode value="self.__name=name&#xa;" id="561UesCpUFZ7"/>
    <sourcecode value="return self.__ctype&#xa;" id="nmtF0QNJk32b"/>
    <sourcecode value="self.__ctype=ctype&#xa;" id="K5qmyQrlDk0D"/>
    <sourcecode value="return self.__input_condition&#xa;" id="jefuOf5XzaPN"/>
    <sourcecode value="self.__input_condition=input_condition&#xa;" id="B0Y7JL30zivL"/>
    <sourcecode value="self.append(comp)&#xa;" id="1pG0XBLt9CEi"/>
    <sourcecode value="for comp in self:&#xa;  if comp.molecules:&#xa;    return comp&#xa;&#xa;&#xa;" id="H7RQJd6mWOK7"/>
    <sourcecode value="while self:&#xa;  self.pop()&#xa;&#xa;" id="4S86atdp04FI"/>
    <sourcecode value="new=AlternativeComplexes(self.name)&#xa;for compl in self:&#xa;  new_compl=compl.clone()&#xa;  new.add_complex(new_compl)&#xa;&#xa;new.ctype=self.ctype&#xa;new.input_condition=self.input_condition&#xa;return new&#xa;" id="EC9m3j679EBh"/>
    <sourcecode value="self.reaction_container=reaction_container&#xa;self.builder=ComplexBuilder()&#xa;if not complexes:&#xa;  self.complexes=[]&#xa;&#xa;else:&#xa;  self.complexes=[]&#xa;  self.final_separated_states=complexes[0]&#xa;  self.complexes.append(self.prepare_complexes_to_apply(complexes[1]))&#xa;&#xa;" id="HoDLDZBIizEp"/>
    <sourcecode value="to_remove=[comp for comp in alter_complex if(comp.molecules==[]and not comp.input_conditions)]&#xa;for comp in to_remove:&#xa;  alter_complex.remove(comp)&#xa;&#xa;possible_roots=[self.reaction_container[0].left_reactant,self.reaction_container[0].right_reactant]&#xa;for root in possible_roots:&#xa;  alter_complex_of_root=AlternativeComplexes(alter_complex.name)&#xa;  alter_complex_of_root.ctype=alter_complex.ctype&#xa;  alter_complex_of_root.input_condition=alter_complex.input_condition&#xa;  for comp in alter_complex:&#xa;    if comp.has_molecule(root.name):&#xa;      alter_complex_of_root.append(comp)&#xa;&#xa;&#xa;  if alter_complex_of_root:&#xa;    com=self.builder.build_required_complexes(alter_complex_of_root,root)&#xa;&#xa;&#xa;return com&#xa;" id="uw6n9AXH4osD"/>
    <sourcecode value="if'AlternativeComplexes'in str(input_complexes.__class__):&#xa;  input_complexes=input_complexes.clone()&#xa;  return self._prepare_alter_complex(input_complexes)&#xa;&#xa;else:&#xa;  alter=[]&#xa;  for alter_complex in input_complexes:&#xa;    if'AlternativeComplexes'in str(alter_complex.__class__):&#xa;      alter_complex=alter_complex.clone()&#xa;&#xa;    elif type(alter_complex)==list:&#xa;      alter_complex=[x.clone()for x in alter_complex]&#xa;&#xa;    alter.append(self._prepare_alter_complex(alter_complex))&#xa;    return list(product(alter))&#xa;&#xa;&#xa;" id="OLAT90gU1I9N"/>
    <sourcecode value="pos=False&#xa;neg=False&#xa;for reaction,compl in zip(self.reaction_container,com):&#xa;  if reaction.definition['Reversibility']=='reversible'and compl.input_conditions:&#xa;    return True&#xa;&#xa;  elif compl.is_positive=='both':&#xa;    return True&#xa;&#xa;  elif compl.is_positive:&#xa;    pos=True&#xa;&#xa;  elif not compl.is_positive:&#xa;    neg=True&#xa;&#xa;&#xa;if pos and neg:&#xa;return True return False&#xa;" id="qKhraoEC6nyP"/>
    <sourcecode value="if both_types:&#xa;  if compl.is_positive:&#xa;    reaction.rate.update_name('%s_1'%reaction.main_id)&#xa;&#xa;  else:&#xa;    reaction.rate.update_name('%s_2'%reaction.main_id)&#xa;&#xa;&#xa;if compl.input_conditions:&#xa;  is_switch=False&#xa;  if compl.is_positive=='both':&#xa;    is_switch=True&#xa;&#xa;  reaction.rate.update_function(compl.input_conditions[0],is_switch,\&#xa;  '%s_1'%reaction.main_id,'%s_2'%reaction.main_id)&#xa;" id="DEAK16hGpMBn"/>
    <sourcecode value="if reaction.left_reactant._id==reaction.right_reactant._id:&#xa;  self.molecule2complex(reaction.left_reactant,reaction,'LR')&#xa;&#xa;else:&#xa;  if reaction.left_reactant:&#xa;    self.molecule2complex(reaction.left_reactant,reaction,'L')&#xa;&#xa;  if reaction.right_reactant:&#xa;    self.molecule2complex(reaction.right_reactant,reaction,'R')&#xa;&#xa;&#xa;" id="Cjl245sS2wgN"/>
    <sourcecode value="if len(self.reaction_container)>1:&#xa;reaction.rid=&quot;%i_%i&quot;%(self.reaction_container.rid,self.counter)self.counter+=1 return reaction&#xa;" id="bl4dhiytN1Jm"/>
    <sourcecode value="for stackes in self.final_separated_states:&#xa;  for stack in stackes:&#xa;    for ele in stack:&#xa;      mol1=Molecule(ele.state.components[0].name)&#xa;      if mol1==reactant:&#xa;        reactant.set_site(ele.state)&#xa;&#xa;      elif len(ele.state.components)>1:&#xa;        mol2=Molecule(ele.state.components[1].name)&#xa;        if mol2==reactant:&#xa;          reactant.set_site(ele.state)&#xa;&#xa;&#xa;&#xa;&#xa;&#xa;" id="6JqUK7Gzip6d"/>
    <sourcecode value="reaction_left_reactant=reaction.left_reactant&#xa;reaction_right_reactant=reaction.right_reactant&#xa;if not comp.has_molecule(reaction_left_reactant.name):&#xa;  self.change_non_complex_molecule(reaction_left_reactant)&#xa;&#xa;elif not comp.has_molecule(reaction_right_reactant.name):&#xa;  self.change_non_complex_molecule(reaction_right_reactant)&#xa;&#xa;" id="Z2kHpouSxO3U"/>
    <sourcecode value="com_number=0&#xa;reaction_container_clone=self.reaction_container[0].clone()&#xa;self.counter=1&#xa;second_reactant=False&#xa;print&quot;self.complexes: &quot;,self.complexes&#xa;for com in self.complexes:&#xa;  reaction_container_tmp=[]&#xa;  while com and len(self.reaction_container[com_number:])!=len(com)and len(com)>0:&#xa;    new_reaction=copy.deepcopy(reaction_container_clone)&#xa;    self.reaction_container.add_reaction(new_reaction)&#xa;&#xa;  pos_and_neg_compl=self.both_complex_types_present(com)&#xa;  for reaction,compl in zip(self.reaction_container[com_number:],com):&#xa;    reaction=self.set_reaction_id(reaction)&#xa;    self.add_substrate_complexes(reaction,compl)&#xa;    if second_reactant:&#xa;      self.get_or_conditions_of_other_reactant(reaction,compl)&#xa;&#xa;    self.update_reaction_rate(reaction,compl,pos_and_neg_compl)&#xa;&#xa;  com_number=len(com)&#xa;  second_reactant=True&#xa;&#xa;if self.complexes==[]:&#xa;  reaction=self.reaction_container[0]&#xa;  self.set_basic_substrate_complex(reaction)&#xa;&#xa;" id="juaCV5rHDqTo"/>
    <sourcecode value="root=[]&#xa;lmol=self.reaction_container[0].left_reactant&#xa;rmol=self.reaction_container[0].right_reactant&#xa;root+=compl.get_molecules(lmol.name,lmol.mid)&#xa;root+=compl.get_molecules(rmol.name,rmol.mid)&#xa;return root&#xa;" id="zykS2pEmhowC"/>
    <sourcecode value="if type(complexes)!=list:&#xa;  complexes=[complexes]&#xa;&#xa;if len(complexes)>2:&#xa;  raise TypeError('Cannot apply more than two complexes on a reaction.')&#xa;&#xa;lmol=reaction.left_reactant&#xa;rmol=reaction.right_reactant&#xa;lmol_is_complex=False&#xa;rmol_is_complex=False&#xa;for compl in complexes:&#xa;  clmol=compl.get_molecules(lmol.name,lmol.mid)&#xa;  crmol=compl.get_molecules(rmol.name,rmol.mid)&#xa;  if clmol:&#xa;    clmol[0].is_reactant=True&#xa;&#xa;  if crmol:&#xa;    crmol[0].is_reactant=True&#xa;&#xa;  if clmol and crmol:&#xa;    if lmol_is_complex or rmol_is_complex:&#xa;      raise TypeError('Reactant is already a complex cannot add another complex.')&#xa;&#xa;    crmol[0]=crmol[0]+rmol&#xa;    clmol[0]=clmol[0]+lmol&#xa;    compl.side='LR'&#xa;    reaction.substrat_complexes.append(compl)&#xa;    lmol_is_complex=True&#xa;    rmol_is_complex=True&#xa;&#xa;  elif clmol:&#xa;    if lmol_is_complex:&#xa;      raise TypeError('Reactant is already a complex cannot add another complex.')&#xa;&#xa;    clmol[0]=clmol[0]+lmol&#xa;    compl.side='L'&#xa;    reaction.substrat_complexes.append(compl)&#xa;    lmol_is_complex=True&#xa;&#xa;  elif crmol:&#xa;    if rmol_is_complex:&#xa;      raise TypeError('Reactant is already a complex cannot add another complex.')&#xa;&#xa;    crmol[0]=crmol[0]+rmol&#xa;    compl.side='R'&#xa;    reaction.substrat_complexes.append(compl)&#xa;    rmol_is_complex=True&#xa;&#xa;&#xa;if not lmol_is_complex:&#xa;  self.molecule2complex(lmol,reaction,'L')&#xa;&#xa;if not rmol_is_complex:&#xa;  self.molecule2complex(rmol,reaction,'R')&#xa;&#xa;" id="d4yJquTihtkJ"/>
    <sourcecode value="compl=BiologicalComplex()&#xa;compl.side=side&#xa;compl.molecules.append(mol)&#xa;reaction.substrat_complexes.append(compl)" id="dipBM0CDFcBJ"/>
    <sourcecode value="self.states=[]&#xa;self.final_states=[]&#xa;" id="seFYnMhtfNLw"/>
    <sourcecode value="required_complexes=AlternativeComplexes('')&#xa;negative=[]&#xa;for comp in all_single_complexes:&#xa;  if negative==[]:&#xa;    required_complexes.add_complex(comp[0])&#xa;    negative=comp[1]&#xa;&#xa;  else:&#xa;    for neg in negative:&#xa;      required_complexes.add_complex(neg.complex_addition(comp[0],root))&#xa;&#xa;    negative=[first_comp.complex_addition(sec_comp,root)for first_comp,sec_comp in product(negative,comp[1])]&#xa;&#xa;&#xa;return required_complexes,negative&#xa;" id="42S1atEQYTyL"/>
    <sourcecode value="if bool_ctype==&quot;!&quot;:&#xa;  if input_cont.ctype=='or':&#xa;    compl=result[1][0]&#xa;    compl.input_conditions=[Contingency(None,'!',input_cont.state)]&#xa;    compl.is_positive=True&#xa;    required_complexes.add_complex(compl)&#xa;&#xa;  elif input_cont.ctype=='and':&#xa;    compl=result[0][0]&#xa;    compl.input_conditions=[Contingency(None,'!',input_cont.state)]&#xa;&#xa;&#xa;elif bool_ctype==&quot;x&quot;:&#xa;  if input_cont.ctype=='or':&#xa;    compl=result[1][0]&#xa;    compl.input_conditions=[Contingency(None,'x',input_cont.state)]&#xa;    compl.is_positive=False&#xa;&#xa;  elif input_cont.ctype=='and':&#xa;    compl=result[0][0]&#xa;    compl.input_conditions=[Contingency(None,'x',input_cont.state)]&#xa;    compl.is_positive=False&#xa;    required_complexes.add_complex(compl)&#xa;&#xa;&#xa;else:&#xa;  if input_cont.ctype=='or':&#xa;    compl=result[1][0]&#xa;&#xa;  elif input_cont.ctype=='and':&#xa;    compl=result[0][0]&#xa;&#xa;  compl.input_conditions=[Contingency(None,'!',input_cont.state),Contingency(None,'x',input_cont.state)]&#xa;  compl.is_positive='both'&#xa;&#xa;" id="tBxuBJH8Rq8H"/>
    <sourcecode value="all_single_complexes=[]&#xa;for comp in positive_complexes:&#xa;  negative=self.build_negative_complexes(comp,root)&#xa;  all_single_complexes.append((comp,negative))&#xa;&#xa;result=self.helper_required_complexes(all_single_complexes,root)&#xa;if positive_complexes.ctype==&quot;!&quot;:&#xa;required_complexes=result[0]if positive_complexes.input_condition:&#xa;  self.apply_input_contingency('!',\&#xa;  positive_complexes.input_condition,required_complexes,result)&#xa;elif positive_complexes.ctype==&quot;x&quot;:&#xa;  required_complexes=AlternativeComplexes('')&#xa;  for neg_comp in result[1]:&#xa;    required_complexes.add_complex(neg_comp)&#xa;&#xa;  if positive_complexes.input_condition:&#xa;    self.apply_input_contingency('x',\&#xa;    positive_complexes.input_condition,required_complexes,result)&#xa;&#xa;elif'k'in positive_complexes.ctype:&#xa;  required_complexes=result[0]&#xa;  for neg_comp in result[1]:&#xa;    required_complexes.add_complex(neg_comp)&#xa;&#xa;  if positive_complexes.input_condition:&#xa;    self.apply_input_contingency(positive_complexes.ctype,\&#xa;    positive_complexes.input_condition,required_complexes,result)&#xa;&#xa;return required_complexes&#xa;" id="GrXkpiisrM7B"/>
    <sourcecode value="complexes=[]&#xa;for state_group in self.final_states:&#xa;  comp=BiologicalComplex()&#xa;  self.stack=state_group&#xa;  while self.stack:&#xa;    state=self.stack.pop()&#xa;    if state.state.type=='Input':&#xa;      alter_comp.input_condition=state&#xa;&#xa;    elif state.state.type==&quot;Covalent Modification&quot;:&#xa;      comp.add_state_mod(complexes,state)&#xa;&#xa;    elif state.state.type==&quot;loc&quot;:&#xa;      pass&#xa;&#xa;    elif state.state.type==&quot;Association&quot;:&#xa;      result=comp.add_state(state)&#xa;      if result:&#xa;        self.stack=result+self.stack&#xa;&#xa;&#xa;    else:&#xa;      assert&quot;reaction not defined&quot;&#xa;&#xa;&#xa;  if comp.molecules:&#xa;    complexes.append(comp)&#xa;&#xa;&#xa;return complexes,alter_comp&#xa;" id="HwIIyrfYpVoZ"/>
    <sourcecode value="alter_complexes=[]&#xa;self.get_state_sets(bool_cont)&#xa;alter_complexes.append(copy.deepcopy(self.final_states))&#xa;alter_comp=AlternativeComplexes(str(bool_cont.state))&#xa;alter_comp.ctype=bool_cont.ctype&#xa;complexes,alter_comp=self.create_basic_complexes_from_boolean(alter_comp)&#xa;complexes=sorted(complexes,key=lambda comp:len(comp))&#xa;for cid,comp in enumerate(complexes):&#xa;  comp.cid=str(cid+1)&#xa;  alter_comp.add_complex(comp)&#xa;&#xa;alter_complexes.append(alter_comp)&#xa;return alter_complexes&#xa;" id="33nqYaNvCvxC"/>
    <sourcecode value="for ele in state_stack:&#xa;  if state.state.has_component(ele.state.components[0]):&#xa;    return True&#xa;&#xa;  elif len(ele.state.components)>1 and state.state.has_component(ele.state.components[1]):&#xa;    return True&#xa;&#xa;&#xa;return False&#xa;" id="7CwJ5uUFOj2q"/>
    <sourcecode value="for ele in stack:&#xa;  if ele.state.type!='Input':&#xa;    return False&#xa;&#xa;&#xa;return True&#xa;" id="Ho7Sw3cWkib1"/>
    <sourcecode value="stacks=[]&#xa;input_stacks=[]&#xa;for state_group in self.final_states:&#xa;  self.stack=state_group&#xa;  new_stack=True&#xa;  for state in self.stack:&#xa;    found_connection=False&#xa;    if stacks:&#xa;      for i,stack in enumerate(stacks):&#xa;        for j,state_stack in enumerate(stack):&#xa;          if new_stack and self.check_state_connected_to_stack(state,state_stack):&#xa;            stacks[i].append(self.stack)&#xa;            found_connection=True&#xa;            new_stack=False&#xa;            break&#xa;&#xa;          elif not new_stack and self.check_state_connected_to_stack(state,state_stack):&#xa;          stacks[i].append(self.stack)found_connection=True break&#xa;        if found_connection:&#xa;          break&#xa;&#xa;&#xa;      if not found_connection:&#xa;      if not self.check_if_input(self.stack):&#xa;        stacks.append([self.stack])&#xa;&#xa;      else:&#xa;        input_stacks.append(self.stack)&#xa;&#xa;      new_stack=False&#xa;      break else:&#xa;        break&#xa;&#xa;&#xa;    else:&#xa;      if not self.check_if_input(self.stack):&#xa;        stacks.append([self.stack])&#xa;&#xa;      else:&#xa;        input_stacks.append(self.stack)&#xa;&#xa;      break&#xa;&#xa;&#xa;&#xa;while input_stacks:&#xa;  input_stack=input_stacks.pop()&#xa;  for stack in stacks:&#xa;    stack.append(input_stack)&#xa;&#xa;&#xa;return stacks&#xa;" id="CFvwyXwYFMG3"/>
    <sourcecode value="self.states.append([bool_cont])&#xa;while self.states:&#xa;  state_list=self.states.pop()&#xa;  self.get_states(state_list)&#xa;&#xa;" id="ZaC5jsWv7Sq3"/>
    <sourcecode value="to_remove=[]&#xa;to_add=[]&#xa;to_clone=[]&#xa;for node in node_list:&#xa;  if node.has_children:&#xa;    to_remove.append(node)&#xa;    child=node.children[0]&#xa;    if child.ctype=='and'or'--'in child.ctype:&#xa;      to_add.extend(node.children)&#xa;&#xa;    elif child.ctype=='or':&#xa;      if node.ctype==&quot;and&quot;:&#xa;        to_clone.append(node.children)&#xa;&#xa;      else:&#xa;        to_clone.extend(node.children)&#xa;&#xa;&#xa;    elif child.ctype=='not'and node.ctype==&quot;and&quot;:&#xa;      for child in node.children:&#xa;        child.ctype=&quot;andnot&quot;&#xa;        to_add.append(child)&#xa;&#xa;&#xa;    elif child.ctype=='not'and node.ctype==&quot;or&quot;:&#xa;      for child in node.children:&#xa;        child.ctype=&quot;ornot&quot;&#xa;        to_clone.append(child)&#xa;&#xa;&#xa;&#xa;&#xa;for node in to_remove:&#xa;  node_list.remove(node)&#xa;&#xa;if to_add:&#xa;  for node in to_add:&#xa;    node_list.append(node)&#xa;&#xa;  bool_flag=False&#xa;  for node in node_list:&#xa;    if node.has_children and len(node.children)>0:&#xa;      bool_flag=True&#xa;&#xa;&#xa;  if bool_flag:&#xa;    self.states.append(node_list)&#xa;&#xa;  else:&#xa;    self.final_states.append(node_list)&#xa;&#xa;&#xa;elif to_clone:&#xa;  to_clone_copy=copy.deepcopy(to_clone)&#xa;  to_combine=[to_clone.pop(to_clone.index(ele))for ele in reversed(to_clone_copy)if isinstance(ele,list)]&#xa;  to_combine=list(itertools.product(*to_combine))&#xa;  if to_combine[0]:&#xa;    to_clone+=to_combine&#xa;&#xa;  for node in to_clone:&#xa;    if isinstance(node,tuple):&#xa;      result=node_list+list(node)&#xa;&#xa;    else:&#xa;      result=node_list+[node]&#xa;&#xa;    bool_flag=False&#xa;    for node in result:&#xa;      if node.has_children and len(node.children)>0:&#xa;        bool_flag=True&#xa;&#xa;&#xa;    if bool_flag:&#xa;      self.states.append(result)&#xa;&#xa;    else:&#xa;      self.final_states.append(result)&#xa;&#xa;&#xa;&#xa;" id="lBLrbBuWvUiz"/>
    <sourcecode value="ordered_states=self.get_states_from_complex(compl,root_molecule)&#xa;if len(ordered_states[0]):&#xa;  ordered_states=ordered_states[0]&#xa;&#xa;else:&#xa;  ordered_states=ordered_states[1]&#xa;&#xa;alter_comp=AlternativeComplexes('')&#xa;counter=len(ordered_states)-1&#xa;while counter:&#xa;comp=BiologicalComplex()comp.is_positive=False for state in ordered_states[:counter]:&#xa;  comp.add_state(state)&#xa;&#xa;last_state=ordered_states[counter]&#xa;mols=comp.get_molecules(last_state.components[0].name)if len(last_state.components)>1:&#xa;  mols+=comp.get_molecules(last_state.components[1].name)&#xa;  mols[0].set_site(last_state)&#xa;&#xa;alter_comp.add_complex(comp)&#xa;counter-=1 comp=BiologicalComplex()&#xa;comp.is_positive=False&#xa;mol=Molecule(root_molecule.name)&#xa;mol.set_site(ordered_states[0])&#xa;comp.molecules.append(mol)&#xa;alter_comp.add_complex(comp)&#xa;return alter_comp&#xa;" id="4WSxyBwI5TYx"/>
    <sourcecode value="result=[[],[]]&#xa;stack=[root_molecule]&#xa;while stack:&#xa;  states_mols=self._get_complex_layer(compl,stack,result)&#xa;  result[0]+=states_mols[0]&#xa;  result[1]+=states_mols[1]&#xa;  stack=states_mols[2]&#xa;&#xa;return result&#xa;" id="TknaR4gNuahf"/>
    <sourcecode value="if not already:&#xa;  already=[]&#xa;&#xa;result_pos=[]&#xa;result_neg=[]&#xa;new_roots=[]&#xa;for root_molecule in root_list:&#xa;  mol=compl.get_molecules(root_molecule.name)[0]&#xa;  for bond in mol.binding_partners:&#xa;    if bond not in already[0]:&#xa;      result_pos.append(bond)&#xa;      new_root=bond.get_partner(mol.get_component())&#xa;      new_roots.append(new_root)&#xa;&#xa;&#xa;  for mod in mol.modifications:&#xa;    if mod not in already[0]:&#xa;      result_pos.append(mod)&#xa;      new_roots=[]&#xa;&#xa;&#xa;  for site in mol.binding_sites:&#xa;    if site not in already[1]:&#xa;      result_neg.append(site)&#xa;      new_root=site.get_partner(mol.get_component())&#xa;      new_roots.append(new_root)&#xa;&#xa;&#xa;  for mod_site in mol.modification_sites:&#xa;    if mod_site not in already[1]:&#xa;      result_neg.append(mod_site)&#xa;&#xa;&#xa;&#xa;return result_pos,result_neg,new_roots" id="6EL5ZlFi1pwj"/>
    <sourcecode value="self.reaction_pool=reaction_pool&#xa;self.molecule_pool=molecules&#xa;self.contingency_pool=contingencies&#xa;rule_factory=RuleFactory(self.reaction_pool,self.contingency_pool)&#xa;self.rule_pool=rule_factory.rule_pool&#xa;self.warnings=warnings&#xa;" id="k5Nmk5qeUM4r"/>
    <sourcecode value="output=BnglOutput(self.rule_pool,self.molecule_pool,self.warnings)&#xa;return output.get_src()" id="VKjyX4pEh0vC"/>
    <sourcecode value="self.rule_pool=rule_pool&#xa;self.molecules=molecule_pool.get_system_molecules().values()&#xa;self.translator=BnglTranslator()&#xa;self.rates=[]&#xa;self.max_stoich=4&#xa;self.warnings=warnings&#xa;" id="FiqW2Y9L3PME"/>
    <sourcecode value="self.create_rules_section()&#xa;self.create_molecule_type_section()&#xa;self.create_seed_species_section()&#xa;self.create_parameters_section()&#xa;self.create_action()&#xa;self.create_worning_section()&#xa;" id="alokOUubGPoS"/>
    <sourcecode value="return'begin %s\n%s\nend %s\n\n'%(name,value.strip(),name)&#xa;" id="mHDUOA6yttiI"/>
    <sourcecode value="self.observables_txt=self.format_string('observables','')&#xa;self.create_sections_txt()&#xa;model='%s%s%s%s%s'%(self.parameters_txt,self.molecules_txt,self.species_txt,self.observables_txt,self.rules_txt)&#xa;bngl_text=self.format_string('model',model)+self.action_txt.strip()&#xa;bngl_text=self.worning_txt+bngl_text&#xa;return bngl_text&#xa;" id="Y51SvmaeSDQK"/>
    <sourcecode value="self.worning_txt=self.translator.get_warning_str(self.warnings)&#xa;" id="x9RazyvrKry7"/>
    <sourcecode value="result=&quot;&quot;&#xa;for mol in sorted(self.molecules,key=lambda molecule:molecule.name):&#xa;  mol_str=self.translator.get_molecule_str(mol)&#xa;  result+=mol_str+'\n'&#xa;&#xa;self.molecules_txt=self.format_string('molecule types',result)&#xa;" id="BR7JjMYeVzDT"/>
    <sourcecode value="result=&quot;&quot;&#xa;for mol in sorted(self.molecules,key=lambda molecule:molecule.name):&#xa;  result+=&quot;%-90s 100\n&quot;%self.translator.get_species_str(mol)&#xa;&#xa;self.species_txt=self.format_string('seed species',result)&#xa;" id="Nvr8oFVzgaHN"/>
    <sourcecode value="result=&quot;&quot;&#xa;for rule_container in sorted(self.rule_pool,key=lambda rcont:rcont.rid):&#xa;  result+=self.translator.get_reaction_header(rule_container)&#xa;  for rule in rule_container:&#xa;    if rule.header:&#xa;      result+=self.translator.get_rule_header(rule)&#xa;&#xa;    result+=self.translator.get_rule_str(rule)&#xa;    self.rates+=rule.rates&#xa;&#xa;&#xa;self.rules_txt=self.format_string('reaction rules',result)&#xa;" id="QGJx8HpVAeez"/>
    <sourcecode value="special_rates=:&#xa;&#xa;&#xa;normal_rates=:&#xa;&#xa;&#xa;special_param_str=&quot;;normal_param_str=&quot;;for rule_container in sorted(self.rule_pool,key=lambda rcont:rcont.rid):&#xa;  for rule in rule_container:&#xa;    for rate in sorted(rule.rate_values.keys()):&#xa;      if rate.startswith('k_'):&#xa;        special_rates[rate]=rule.rate_values[rate]&#xa;&#xa;      else:&#xa;        if rate not in normal_rates.keys():&#xa;          normal_param_str+=&quot;%s %s\n&quot;%(rate,rule.rate_values[rate])&#xa;          normal_rates[rate]=rule.rate_values[rate]&#xa;&#xa;&#xa;&#xa;&#xa;&#xa;for rate in special_rates.keys():&#xa;  special_param_str+=&quot;%s %s\n&quot;%(rate,special_rates[rate])&#xa;&#xa;self.parameters_txt=self.format_string('parameters',special_param_str+normal_param_str.strip())&#xa;" id="BsPU4IiSX1Pf"/>
    <sourcecode value="self.action_txt=&quot;generate_network({overwrite=>1,max_stoich=>{%s}});&quot;%\&#xa;','.join(['%s=>%s'%(mol.name,self.max_stoich)for mol in sorted(self.molecules,key=lambda molecule:molecule.name)]" id="YBAY5BHG4fi6"/>
    <sourcecode value="pass&#xa;" id="hLnLppmsDDZp"/>
    <sourcecode value="self.root=root_node&#xa;self.requirements=[]&#xa;self.nodes_dict=:&#xa;&#xa;&#xa;self._create_node_dict(self.root)&#xa;" id="WOGmCoydwZjH"/>
    <sourcecode value="result=self._get_str(self.root)&#xa;result=result.strip()&#xa;if len(result)>0 and result[-1]==',':&#xa;  result=result[:-1]&#xa;&#xa;return result&#xa;" id="vUNp35720QpA"/>
    <sourcecode value="result=''&#xa;if not node:&#xa;return result elif not node.has_children:&#xa;  if node.ctype=='none'or not node.ctype:return''&#xa;  result+=' '+str(node)&#xa;  if node.ctype in['k+','k-','!','0','x','?']:&#xa;    result+=', '&#xa;&#xa;&#xa;elif node.has_children:&#xa;  children_str=''&#xa;  for child in node.children:&#xa;  children_str+=self._get_str(child)if node.ctype and node.ctype!='none':&#xa;    result+=' %s (%s)'%(node.ctype,children_str)&#xa;&#xa;  else:&#xa;    result+=children_str&#xa;&#xa;&#xa;result=re.sub('\( or |\( and |\( xor |\( not','(',result)&#xa;result=re.sub('\s{2,3}',' ',result)&#xa;return result&#xa;" id="JpDqwjasEwfF"/>
    <sourcecode value="if node not in self.nodes_dict:&#xa;  self.nodes_dict[node]=RequirementNode()&#xa;&#xa;if node.has_children:&#xa;  for child in node.children:&#xa;    self._create_node_dict(child)&#xa;&#xa;&#xa;" id="sqe6kKJh6ZgH"/>
    <sourcecode value="req_node=self.nodes_dict[cont]&#xa;if not cont.has_children:&#xa;  req_node.get_leaf(cont)&#xa;&#xa;elif cont.has_children:&#xa;  for child in cont.children:&#xa;    self.requirements2nodes(child)&#xa;&#xa;  child_nodes=[self.nodes_dict[child]for child in cont.children]&#xa;  if cont.children[0].ctype=='or':&#xa;    req_node.get_or_positive(child_nodes)&#xa;&#xa;  elif cont.children[0].ctype=='and'\&#xa;  or cont.ctype=='none'or not cont.ctype:&#xa;    req_node.get_and_positive(child_nodes)&#xa;&#xa;&#xa;" id="ynW2LAHxwEkX"/>
    <sourcecode value="self.requirements2nodes(self.root)&#xa;for req_list in self.nodes_dict[self.root].positive:&#xa;  temp=[]&#xa;  for req in req_list:&#xa;    temp.append(req.get_contingency())&#xa;&#xa;  self.requirements.append(temp)&#xa;&#xa;return self.requirements&#xa;" id="QLoNZYu8LM8L"/>
    <sourcecode value="self.xls_tables=xls_tables&#xa;self.contingencies=ContingencyFactory(self.xls_tables).parse_contingencies()&#xa;self.requirements=self.generate_requirements()&#xa;" id="Nfbh2k0LRZ2k"/>
    <sourcecode value="reqs=RequirementsPool()&#xa;for reaction in self.contingencies.keys():&#xa;  req_gen=RequirementsGenerator(self.contingencies[reaction])&#xa;  reqs[reaction]=req_gen.get_requirements()&#xa;&#xa;return reqs&#xa;" id="K0zlZzVAYMAy"/>
    <sourcecode value="result=:&#xa;&#xa;&#xa;for reaction in self.requirements.keys():&#xa;  result[reaction]=[]&#xa;  for req_list in self.requirements[reaction]:&#xa;    temp=[str(req)for req in req_list]&#xa;    result[reaction].append(temp)&#xa;&#xa;&#xa;return result" id="z1bbbbFwbEfB"/>
    <sourcecode value="self.reaction=reaction&#xa;self.name=self.reaction.name&#xa;self.rid=self.reaction.rid&#xa;self.specific_reqs=[]&#xa;self.header=False&#xa;" id="Uxcx7bdHZH8P"/>
    <sourcecode value="if self.reaction.definition['Reversibility']=='irreversible':&#xa;  return'->'&#xa;&#xa;elif self.reaction.definition['Reversibility']=='reversible':&#xa;  return'&lt;->'&#xa;&#xa;" id="Mjvvy3JBrwmX"/>
    <sourcecode value="return self.reaction.rate.get_rates_for_reaction()&#xa;" id="dF6B3CrPtkJr"/>
    <sourcecode value="return self.reaction.rate.get_rate_values()" id="rLy5O012G6BH"/>
    <sourcecode value="self.reactions=reaction_container&#xa;self.reaction_name=self.reactions.name&#xa;self.name=self.get_name()&#xa;self.rid=self.reactions.rid&#xa;self.sp_state=None&#xa;self.common_reqs=[]&#xa;self.contingencies=None&#xa;" id="QmhqIMCroqN5"/>
    <sourcecode value="self.append(rule)&#xa;" id="9STwJq1d7b3B"/>
    <sourcecode value="react=self.reactions[0]&#xa;return'%s %s %s'%(react.left_reactant.name,react.rtype,react.right_reactant.name)&#xa;" id="lIuqux1FTCyh"/>
    <sourcecode value="pass&#xa;" id="f4EnPuTa7aZ0"/>
    <sourcecode value="all_rules=sorted(self.values(),key=lambda r:r.rid)&#xa;return iter(all_rules)&#xa;" id="6ekqPUZ5Wnsv"/>
    <sourcecode value="self.reaction_pool=reaction_pool&#xa;self.contingency_pool=contingency_pool&#xa;self.rule_pool=RulePool()&#xa;self.generate_rules()&#xa;" id="ZNm8bPHmYaX3"/>
    <sourcecode value="for reaction_container in self.reaction_pool:&#xa;  rule_container=RuleContainer(reaction_container)&#xa;  rule_container.sp_state=reaction_container.sp_state&#xa;  common_cont=reaction_container.get_common_contingencies()&#xa;  rule_container.common_reqs=common_cont&#xa;  if self.contingency_pool.has_key(reaction_container.name):&#xa;    gen=RequirementsGenerator(self.contingency_pool[reaction_container.name])&#xa;    rule_container.contingencies=gen&#xa;&#xa;  else:&#xa;    rule_container.contingencies=None&#xa;&#xa;  header=True if len(reaction_container)>1 else False&#xa;  for reaction in reaction_container:&#xa;    rule=Rule(reaction)&#xa;    rule.header=header&#xa;    rule_container.add_rule(rule)&#xa;    if header:&#xa;      rule.specific_reqs=reaction.get_specific_contingencies(common_cont)&#xa;&#xa;&#xa;  self.rule_pool[reaction_container.name]=rule_container" id="qnR17DnjO5ZS"/>
    <sourcecode value="pass&#xa;" id="X9PA3ZxBSydG"/>
    <sourcecode value="result=&quot;&quot;&#xa;molecules=[]&#xa;bonds=compl.get_bonds()&#xa;mols_track=:&#xa;&#xa;&#xa;for mol in sorted(compl.molecules,key=lambda mol:mol.name):&#xa;  if mol.name not in mols_track:&#xa;    mols_track[mol.name]=1&#xa;&#xa;  else:&#xa;    mols_track[mol.name]+=1&#xa;&#xa;  domains=[]&#xa;  if mol.localisation:&#xa;  dom=mol.localisation.components[0].domain if mol.localisation.loc:&#xa;    modif=mol.localisation.modifier&#xa;&#xa;  else:&#xa;    modif=mol.localisation.not_modifier&#xa;&#xa;  domains.append('%s~%s'%(dom,modif))&#xa;  mod_domains=[]&#xa;  for modif in mol.modifications:&#xa;    mod_domains.append('%s~%s'%(modif.components[0].domain,modif.modifier))&#xa;&#xa;  for place in mol.modification_sites:&#xa;    mod_domains.append('%s~%s'%(place.components[0].domain,place.not_modifier))&#xa;&#xa;  mod_domains.sort()&#xa;  domains+=mod_domains&#xa;  bind_domains=[]&#xa;  used_domains=[]&#xa;  for binding in mol.binding_partners:&#xa;    if binding.type=='Intraprotein':&#xa;      doms=self.get_ipi_binding_domains(binding)&#xa;      if bonds.has_key((mol,binding)):&#xa;        if doms[0]not in used_domains:&#xa;          bind_domains.append('%s!%i'%(doms[0],bonds[(mol,binding)]))&#xa;          used_domains.append(doms[0])&#xa;&#xa;        if doms[1]not in used_domains:&#xa;        bind_domains.append('%s!%i'%(doms[1],bonds[(mol,binding)]))used_domains.append(doms[1])&#xa;&#xa;    else:&#xa;      side=self.get_side(mol,compl,mols_track)&#xa;      dom=self.get_binding_domain(mol.name,binding,mol.mid,side)&#xa;      if bonds.has_key((mol,binding))and dom not in used_domains:&#xa;        bind_domains.append('%s!%i'%(dom,bonds[(mol,binding)]))&#xa;        used_domains.append(dom)&#xa;&#xa;&#xa;&#xa;  for site in mol.binding_sites:&#xa;    if site.type=='Intraprotein':&#xa;      doms=self.get_ipi_binding_domains(site)&#xa;      for dom in doms:&#xa;        if dom not in used_domains:&#xa;          bind_domains.append(dom)&#xa;          used_domains.append(dom)&#xa;&#xa;&#xa;&#xa;    else:&#xa;      side=self.get_side(mol,compl,mols_track)&#xa;      dom=self.get_binding_domain(mol.name,site,mol.mid,compl.side)&#xa;      if dom and dom not in used_domains:&#xa;        bind_domains.append(dom)&#xa;        used_domains.append(dom)&#xa;&#xa;&#xa;&#xa;  bind_domains.sort()&#xa;  domains+=bind_domains&#xa;  if domains:&#xa;    molecules.append(&quot;%s(%s)&quot;%(mol.name,','.join(domains)))&#xa;&#xa;  else:&#xa;    molecules.append(mol.name)&#xa;&#xa;&#xa;result='.'.join(molecules)&#xa;return re.sub('[-/]','',result)&#xa;" id="g9eFEd7jnWtq"/>
    <sourcecode value="if compl.side in['L','R']:&#xa;  return compl.side&#xa;&#xa;if track_dict[mol.name]%2==1:&#xa;  return'L'&#xa;&#xa;else:&#xa;  return'R'&#xa;&#xa;" id="Lji6FZwHMvm4"/>
    <sourcecode value="comp=binding.components[0]&#xa;return[comp.domain,comp.second_domain]&#xa;" id="3jAovMkhUykY"/>
    <sourcecode value="if binding.homodimer:&#xa;  return binding.get_component(name,side).domain&#xa;&#xa;comp=Component(name=name,domain=None,cid=mid)&#xa;if comp==binding.components[0]:&#xa;  return binding.components[0].domain&#xa;&#xa;elif comp==binding.components[1]:&#xa;  return binding.components[1].domain&#xa;&#xa;" id="KM0pJlLDdRZo"/>
    <sourcecode value="if binding.homodimer:&#xa;  dom1=binding.components[0].domain&#xa;  dom2=binding.components[1].domain&#xa;  if dom1==dom2:&#xa;    return[dom1]&#xa;&#xa;  return[dom1,dom2]&#xa;&#xa;comp=Component(name=name,domain=None,cid=mid)&#xa;if comp==binding.components[0]:&#xa;  return[binding.components[0].domain]&#xa;&#xa;elif comp==binding.components[1]:&#xa;  return[binding.components[1].domain]&#xa;&#xa;" id="YC3KNuOF7fkk"/>
    <sourcecode value="domains=[]&#xa;used_domains=[]&#xa;loc_str=''&#xa;if mode=='species':&#xa;  if mol.localisation:&#xa;    loc_str+='~%s'%mol.localisation.not_modifier&#xa;&#xa;&#xa;else:&#xa;  if mol.localisation:&#xa;    loc_str+='~%s~%s'%(mol.localisation.not_modifier,mol.localisation.modifier)&#xa;&#xa;  if mol.alternative_localisations:&#xa;    for loc in sorted(mol.alternative_localisations):&#xa;      loc_str+='~%s'%loc&#xa;&#xa;&#xa;&#xa;if loc_str:&#xa;  dom=mol.localisation.components[0].domain&#xa;  domains.append('%s%s'%(dom,loc_str))&#xa;  used_domains.append(dom)&#xa;&#xa;mod_domains=[]&#xa;for modif in mol.modifications:&#xa;  if modif.components[0].domain not in used_domains:&#xa;    used_domains.append(modif.components[0].domain)&#xa;    if mode=='species':&#xa;      mod_domains.append('%s~%s'%(modif.components[0].domain,modif.not_modifier))&#xa;&#xa;    else:&#xa;      mod_domains.append('%s~%s~%s'%(modif.components[0].domain,modif.not_modifier,modif.modifier))&#xa;&#xa;&#xa;&#xa;for site in mol.modification_sites:&#xa;  if site.components[0].domain not in used_domains:&#xa;    used_domains.append(site.components[0].domain)&#xa;    if mode=='species':&#xa;      mod_domains.append('%s~%s'%(site.components[0].domain,site.not_modifier))&#xa;&#xa;    else:&#xa;      mod_domains.append('%s~%s~%s'%(site.components[0].domain,site.not_modifier,site.modifier))&#xa;&#xa;&#xa;&#xa;mod_domains.sort()&#xa;domains+=mod_domains&#xa;bind_domains=[]&#xa;for binding in mol.binding_partners:&#xa;  if binding.type=='Intraprotein':&#xa;    doms=self.get_ipi_binding_domains(binding)&#xa;    for dom in doms:&#xa;      if dom not in used_domains:&#xa;        bind_domains.append(dom)&#xa;        used_domains.append(dom)&#xa;&#xa;&#xa;&#xa;  else:&#xa;    doms=self.get_binding_domain_for_molecules(mol.name,binding,mol.mid)&#xa;    for dom in doms:&#xa;      if dom not in used_domains:&#xa;        bind_domains.append(dom)&#xa;        used_domains.append(dom)&#xa;&#xa;&#xa;&#xa;&#xa;for site in mol.binding_sites:&#xa;  if site.type=='Intraprotein':&#xa;    doms=self.get_ipi_binding_domains(site)&#xa;    for dom in doms:&#xa;      if dom not in used_domains:&#xa;        bind_domains.append(dom)&#xa;        used_domains.append(dom)&#xa;&#xa;&#xa;&#xa;  else:&#xa;    doms=self.get_binding_domain_for_molecules(mol.name,site,mol.mid)&#xa;    for dom in doms:&#xa;      if dom not in used_domains:&#xa;        bind_domains.append(dom)&#xa;        used_domains.append(dom)&#xa;&#xa;&#xa;&#xa;&#xa;bind_domains.sort()&#xa;domains+=bind_domains&#xa;if domains:&#xa;  result=&quot;%s(%s)&quot;%(mol.name,','.join(domains))&#xa;&#xa;else:&#xa;  result=mol.name&#xa;&#xa;return re.sub('[-/]','',result)&#xa;" id="ZcoKduQYOlaX"/>
    <sourcecode value="return self.get_molecule_str(mol,'species')&#xa;" id="8OyqhMWTApxu"/>
    <sourcecode value="result='%s%3s;cont=rule_container.contingencies&#xa;if cont:&#xa;result+=&quot;common_reqs=self.get_reqs_str(rule_container.common_reqs)&#xa;if common_reqs:&#xa;  result+=&quot;;&#xa;result+=&quot;;result+=&quot;;return result&#xa;" id="6hLEUG8IbJfA"/>
    <sourcecode value="out=&quot;;out+=&quot;;return out&#xa;" id="yCFZVvjbBYVj"/>
    <sourcecode value="reactants=[]&#xa;for compl in sorted(rule.reaction.substrat_complexes,key=lambda comp:comp.side):&#xa;  reactants.append(self.get_complex_str(compl))&#xa;&#xa;products=[]&#xa;for compl in sorted(rule.reaction.product_complexes,key=lambda comp:comp.side):&#xa;  products.append(self.get_complex_str(compl))&#xa;&#xa;reactant_str=' + '.join(reactants)&#xa;product_str=' + '.join(products)&#xa;rate_str=', '.join(rule.rates)&#xa;return&quot;%s %s %s    %s\n&quot;%(reactant_str,rule.arrow,product_str,rate_str)&#xa;" id="w5B6dgn8fckH"/>
    <sourcecode value="present=lambda cont:'False'if cont.ctype=='x'else'True'&#xa;return', '.join(['%s %s'%(str(cont.state),present(cont))for cont in cont_list])&#xa;" id="FmpuPXABAV8I"/>
    <sourcecode value="result=''&#xa;if warnings:&#xa;  for state in warnings.not_in_products:&#xa;    result+=&quot;;&#xa;&#xa;" id="CgIL9RddXM8P"/>
    <sourcecode value="self.positive=[[]]&#xa;" id="IGmVULJLcQvQ"/>
    <sourcecode value="return&quot;Positive: %i&quot;%(len(self.positive))&#xa;" id="3tF9Lj3b0p7S"/>
    <sourcecode value="result=[]&#xa;for node in nodes:&#xa;  result+=node.positive&#xa;&#xa;self.positive=result&#xa;" id="fCsHS2LVtafD"/>
    <sourcecode value="all_pos=[node.positive for node in nodes]&#xa;result=reduce(product,all_pos)&#xa;self.positive=[flatten(x)for x in result]&#xa;" id="WynNYQaq6N8a"/>
    <sourcecode value="if node.ctype=='!'or node.inherited_ctype=='!':&#xa;  self.positive=[[ContingencyWrapper(node,'positive')]]&#xa;&#xa;elif node.ctype=='x'or node.inherited_ctype=='x':&#xa;  self.positive=[[ContingencyWrapper(node,'negative')]]&#xa;&#xa;" id="gN0mk8L11WVO"/>
   </codegenerator>
  </codegeneration>
 </XMI.extensions>
</XMI>
